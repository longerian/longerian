### Eclipse Workspace Patch 1.0
#P k9mail
Index: src/com/android/email/activity/setup/AccountSetupOutgoing.java
===================================================================
--- src/com/android/email/activity/setup/AccountSetupOutgoing.java	(revision 718)
+++ src/com/android/email/activity/setup/AccountSetupOutgoing.java	(working copy)
@@ -1,285 +0,0 @@
-
-package com.android.email.activity.setup;
-
-import java.net.URI;
-import java.net.URISyntaxException;
-
-import com.android.email.K9Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.os.Bundle;
-import android.text.Editable;
-import android.text.TextWatcher;
-import android.text.method.DigitsKeyListener;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.View.OnClickListener;
-import android.widget.AdapterView;
-import android.widget.ArrayAdapter;
-import android.widget.Button;
-import android.widget.CheckBox;
-import android.widget.CompoundButton;
-import android.widget.EditText;
-import android.widget.Spinner;
-import android.widget.CompoundButton.OnCheckedChangeListener;
-
-import com.android.email.Account;
-import com.android.email.Preferences;
-import com.android.email.R;
-import com.android.email.Utility;
-
-public class AccountSetupOutgoing extends K9Activity implements OnClickListener,
-        OnCheckedChangeListener {
-    private static final String EXTRA_ACCOUNT = "account";
-
-    private static final String EXTRA_MAKE_DEFAULT = "makeDefault";
-
-    private static final int smtpPorts[] = {
-            25, 465, 465, 25, 25
-    };
-
-    private static final String smtpSchemes[] = {
-            "smtp", "smtp+ssl", "smtp+ssl+", "smtp+tls", "smtp+tls+"
-    };
-    private static final int webdavPorts[] = {
-        80, 443, 443, 443, 443
-    };
-    private static final String webdavSchemes[] = {
-    	"webdav", "webdav+ssl", "webdav+ssl+", "webdav+tls", "webdav+tls+"
-    };
-
-    private EditText mUsernameView;
-    private EditText mPasswordView;
-    private EditText mServerView;
-    private EditText mPortView;
-    private CheckBox mRequireLoginView;
-    private ViewGroup mRequireLoginSettingsView;
-    private Spinner mSecurityTypeView;
-    private Button mNextButton;
-    private Account mAccount;
-    private boolean mMakeDefault;
-
-    public static void actionOutgoingSettings(Context context, Account account, boolean makeDefault) {
-        Intent i = new Intent(context, AccountSetupOutgoing.class);
-        i.putExtra(EXTRA_ACCOUNT, account);
-        i.putExtra(EXTRA_MAKE_DEFAULT, makeDefault);
-        context.startActivity(i);
-    }
-
-    public static void actionEditOutgoingSettings(Context context, Account account) {
-        Intent i = new Intent(context, AccountSetupOutgoing.class);
-        i.setAction(Intent.ACTION_EDIT);
-        i.putExtra(EXTRA_ACCOUNT, account);
-        context.startActivity(i);
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.account_setup_outgoing);
-
-        mAccount = (Account)getIntent().getSerializableExtra(EXTRA_ACCOUNT);
-        
-        try {
-			if (new URI(mAccount.getStoreUri()).getScheme().startsWith("webdav")) {
-				mAccount.setTransportUri(mAccount.getStoreUri());
-				AccountSetupCheckSettings.actionCheckSettings(this, mAccount, false, true);
-			}
-		} catch (URISyntaxException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
-		}
-
-        
-        mUsernameView = (EditText)findViewById(R.id.account_username);
-        mPasswordView = (EditText)findViewById(R.id.account_password);
-        mServerView = (EditText)findViewById(R.id.account_server);
-        mPortView = (EditText)findViewById(R.id.account_port);
-        mRequireLoginView = (CheckBox)findViewById(R.id.account_require_login);
-        mRequireLoginSettingsView = (ViewGroup)findViewById(R.id.account_require_login_settings);
-        mSecurityTypeView = (Spinner)findViewById(R.id.account_security_type);
-        mNextButton = (Button)findViewById(R.id.next);
-
-        mNextButton.setOnClickListener(this);
-        mRequireLoginView.setOnCheckedChangeListener(this);
-
-        SpinnerOption securityTypes[] = {
-                new SpinnerOption(0, getString(R.string.account_setup_incoming_security_none_label)),
-                new SpinnerOption(1,
-                        getString(R.string.account_setup_incoming_security_ssl_optional_label)),
-                new SpinnerOption(2, getString(R.string.account_setup_incoming_security_ssl_label)),
-                new SpinnerOption(3,
-                        getString(R.string.account_setup_incoming_security_tls_optional_label)),
-                new SpinnerOption(4, getString(R.string.account_setup_incoming_security_tls_label)),
-        };
-
-        ArrayAdapter<SpinnerOption> securityTypesAdapter = new ArrayAdapter<SpinnerOption>(this,
-                android.R.layout.simple_spinner_item, securityTypes);
-        securityTypesAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
-        mSecurityTypeView.setAdapter(securityTypesAdapter);
-
-        /*
-         * Updates the port when the user changes the security type. This allows
-         * us to show a reasonable default which the user can change.
-         */
-        mSecurityTypeView.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
-            public void onItemSelected(AdapterView arg0, View arg1, int arg2, long arg3) {
-                updatePortFromSecurityType();
-            }
-
-            public void onNothingSelected(AdapterView<?> arg0) {
-            }
-        });
-
-        /*
-         * Calls validateFields() which enables or disables the Next button
-         * based on the fields' validity.
-         */
-        TextWatcher validationTextWatcher = new TextWatcher() {
-            public void afterTextChanged(Editable s) {
-                validateFields();
-            }
-
-            public void beforeTextChanged(CharSequence s, int start, int count, int after) {
-            }
-
-            public void onTextChanged(CharSequence s, int start, int before, int count) {
-            }
-        };
-        mUsernameView.addTextChangedListener(validationTextWatcher);
-        mPasswordView.addTextChangedListener(validationTextWatcher);
-        mServerView.addTextChangedListener(validationTextWatcher);
-        mPortView.addTextChangedListener(validationTextWatcher);
-
-        /*
-         * Only allow digits in the port field.
-         */
-        mPortView.setKeyListener(DigitsKeyListener.getInstance("0123456789"));
-
-        mAccount = (Account)getIntent().getSerializableExtra(EXTRA_ACCOUNT);
-        mMakeDefault = (boolean)getIntent().getBooleanExtra(EXTRA_MAKE_DEFAULT, false);
-
-        /*
-         * If we're being reloaded we override the original account with the one
-         * we saved
-         */
-        if (savedInstanceState != null && savedInstanceState.containsKey(EXTRA_ACCOUNT)) {
-            mAccount = (Account)savedInstanceState.getSerializable(EXTRA_ACCOUNT);
-        }
-
-        try {
-            URI uri = new URI(mAccount.getTransportUri());
-            String username = null;
-            String password = null;
-            if (uri.getUserInfo() != null) {
-                String[] userInfoParts = uri.getUserInfo().split(":", 2);
-                username = userInfoParts[0];
-                if (userInfoParts.length > 1) {
-                    password = userInfoParts[1];
-                }
-            }
-
-            if (username != null) {
-                mUsernameView.setText(username);
-                mRequireLoginView.setChecked(true);
-            }
-
-            if (password != null) {
-                mPasswordView.setText(password);
-            }
-
-            for (int i = 0; i < smtpSchemes.length; i++) {
-                if (smtpSchemes[i].equals(uri.getScheme())) {
-                    SpinnerOption.setSpinnerOptionValue(mSecurityTypeView, i);
-                }
-            }
-
-            if (uri.getHost() != null) {
-                mServerView.setText(uri.getHost());
-            }
-
-            if (uri.getPort() != -1) {
-                mPortView.setText(Integer.toString(uri.getPort()));
-            } else {
-                updatePortFromSecurityType();
-            }
-        } catch (URISyntaxException use) {
-            /*
-             * We should always be able to parse our own settings.
-             */
-            throw new Error(use);
-        }
-
-        validateFields();
-    }
-
-    @Override
-    public void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        outState.putSerializable(EXTRA_ACCOUNT, mAccount);
-    }
-
-    private void validateFields() {
-        mNextButton
-                .setEnabled(
-                        Utility.domainFieldValid(mServerView) && 
-                        Utility.requiredFieldValid(mPortView) && 
-                        (!mRequireLoginView.isChecked() || 
-                                (Utility.requiredFieldValid(mUsernameView) && 
-                                        Utility.requiredFieldValid(mPasswordView))));
-        Utility.setCompoundDrawablesAlpha(mNextButton, mNextButton.isEnabled() ? 255 : 128);
-    }
-
-    private void updatePortFromSecurityType() {
-        int securityType = (Integer)((SpinnerOption)mSecurityTypeView.getSelectedItem()).value;
-        mPortView.setText(Integer.toString(smtpPorts[securityType]));
-    }
-
-    @Override
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        if (resultCode == RESULT_OK) {
-            if (Intent.ACTION_EDIT.equals(getIntent().getAction())) {
-                mAccount.save(Preferences.getPreferences(this));
-                finish();
-            } else {
-                AccountSetupOptions.actionOptions(this, mAccount, mMakeDefault);
-                finish();
-            }
-        }
-    }
-
-    private void onNext() {
-        int securityType = (Integer)((SpinnerOption)mSecurityTypeView.getSelectedItem()).value;
-        URI uri;
-        try {
-            String userInfo = null;
-            if (mRequireLoginView.isChecked()) {
-                userInfo = mUsernameView.getText().toString() + ":"
-                        + mPasswordView.getText().toString();
-            }
-            uri = new URI(smtpSchemes[securityType], userInfo, mServerView.getText().toString(),
-                    Integer.parseInt(mPortView.getText().toString()), null, null, null);
-            mAccount.setTransportUri(uri.toString());
-        } catch (URISyntaxException use) {
-            /*
-             * It's unrecoverable if we cannot create a URI from components that
-             * we validated to be safe.
-             */
-            throw new Error(use);
-        }
-        AccountSetupCheckSettings.actionCheckSettings(this, mAccount, false, true);
-    }
-
-    public void onClick(View v) {
-        switch (v.getId()) {
-            case R.id.next:
-                onNext();
-                break;
-        }
-    }
-
-    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
-        mRequireLoginSettingsView.setVisibility(isChecked ? View.VISIBLE : View.GONE);
-        validateFields();
-    }
-}
Index: src/com/android/email/mail/store/WebDavStore.java
===================================================================
--- src/com/android/email/mail/store/WebDavStore.java	(revision 718)
+++ src/com/android/email/mail/store/WebDavStore.java	(working copy)
@@ -1,2034 +0,0 @@
-package com.android.email.mail.store;
-
-import java.io.BufferedReader;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.PrintStream;
-import java.io.UnsupportedEncodingException;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.security.GeneralSecurityException;
-import java.security.KeyManagementException;
-import java.security.NoSuchAlgorithmException;
-import java.text.DateFormat;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.Stack;
-
-import javax.net.ssl.SSLException;
-import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.SAXParserFactory;
-
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpException;
-import org.apache.http.HttpHost;
-import org.apache.http.HttpRequest;
-import org.apache.http.HttpRequestInterceptor;
-import org.apache.http.HttpResponse;
-import org.apache.http.auth.AuthScope;
-import org.apache.http.auth.Credentials;
-import org.apache.http.auth.UsernamePasswordCredentials;
-import org.apache.http.client.CookieStore;
-import org.apache.http.client.CredentialsProvider;
-import org.apache.http.client.entity.UrlEncodedFormEntity;
-import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.client.methods.HttpPost;
-import org.apache.http.conn.scheme.Scheme;
-import org.apache.http.conn.scheme.SchemeRegistry;
-import org.apache.http.entity.StringEntity;
-import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.message.BasicNameValuePair;
-import org.apache.http.protocol.ExecutionContext;
-import org.apache.http.protocol.HttpContext;
-import org.xml.sax.Attributes;
-import org.xml.sax.InputSource;
-import org.xml.sax.SAXException;
-import org.xml.sax.XMLReader;
-import org.xml.sax.helpers.DefaultHandler;
-
-import android.util.Log;
-
-import com.android.email.Email;
-import com.android.email.Utility;
-import com.android.email.mail.CertificateValidationException;
-import com.android.email.mail.FetchProfile;
-import com.android.email.mail.Flag;
-import com.android.email.mail.Folder;
-import com.android.email.mail.Message;
-import com.android.email.mail.MessageRetrievalListener;
-import com.android.email.mail.MessagingException;
-import com.android.email.mail.Store;
-import com.android.email.mail.internet.MimeMessage;
-import com.android.email.mail.transport.TrustedSocketFactory;
-
-/**
- * <pre>
- * Uses WebDAV formatted HTTP calls to an MS Exchange server to fetch emails
- * and email information.  This has only been tested on an MS Exchange
- * Server 2003.  It uses Form-Based authentication and requires that
- * Outlook Web Access be enabled on the server.
- * </pre>
- */
-public class WebDavStore extends Store {
-    public static final int CONNECTION_SECURITY_NONE = 0;
-    public static final int CONNECTION_SECURITY_TLS_OPTIONAL = 1;
-    public static final int CONNECTION_SECURITY_TLS_REQUIRED = 2;
-    public static final int CONNECTION_SECURITY_SSL_REQUIRED = 3;
-    public static final int CONNECTION_SECURITY_SSL_OPTIONAL = 4;
-
-    private static final Flag[] PERMANENT_FLAGS = { Flag.DELETED, Flag.SEEN, Flag.ANSWERED };
-
-    private int mConnectionSecurity;
-    private String mUsername; /* Stores the username for authentications */
-    private String alias;
-    private String mPassword; /* Stores the password for authentications */
-    private String mUrl;      /* Stores the base URL for the server */
-    private String mHost;     /* Stores the host name for the server */
-    private String mPath;     /* Stores the path for the server */
-    private String mAuthPath; /* Stores the path off of the server to post data to for form based authentication */
-    private String mMailboxPath; /* Stores the user specified path to the mailbox */
-    private URI mUri;         /* Stores the Uniform Resource Indicator with all connection info */
-    private String mRedirectUrl;
-    private String mAuthString;
-
-    private CookieStore mAuthCookies; /* Stores cookies from authentication */
-    private boolean mAuthenticated = false; /* Stores authentication state */
-    private long mLastAuth = -1; /* Stores the timestamp of last auth */
-    private long mAuthTimeout = 5 * 60;
-
-    private HashMap<String, WebDavFolder> mFolderList = new HashMap<String, WebDavFolder>();
-    private boolean mSecure;
-    private DefaultHttpClient mHttpClient = null;
-
-    /**
-     * webdav://user:password@server:port CONNECTION_SECURITY_NONE
-     * webdav+tls://user:password@server:port CONNECTION_SECURITY_TLS_OPTIONAL
-     * webdav+tls+://user:password@server:port CONNECTION_SECURITY_TLS_REQUIRED
-     * webdav+ssl+://user:password@server:port CONNECTION_SECURITY_SSL_REQUIRED
-     * webdav+ssl://user:password@server:port CONNECTION_SECURITY_SSL_OPTIONAL
-     *
-     * @param _uri
-     */
-    public WebDavStore(String _uri) throws MessagingException {
-        try {
-            mUri = new URI(_uri);
-        } catch (URISyntaxException use) {
-            throw new MessagingException("Invalid WebDavStore URI", use);
-        }
-        String scheme = mUri.getScheme();
-        if (scheme.equals("webdav")) {
-            mConnectionSecurity = CONNECTION_SECURITY_NONE;
-        } else if (scheme.equals("webdav+ssl")) {
-            mConnectionSecurity = CONNECTION_SECURITY_SSL_OPTIONAL;
-        } else if (scheme.equals("webdav+ssl+")) {
-            mConnectionSecurity = CONNECTION_SECURITY_SSL_REQUIRED;
-        } else if (scheme.equals("webdav+tls")) {
-            mConnectionSecurity = CONNECTION_SECURITY_TLS_OPTIONAL;
-        } else if (scheme.equals("webdav+tls+")) {
-            mConnectionSecurity = CONNECTION_SECURITY_TLS_REQUIRED;
-        } else {
-            throw new MessagingException("Unsupported protocol");
-        }
-
-        mHost = mUri.getHost();
-        if (mHost.startsWith("http")) {
-            String[] hostParts = mHost.split("://", 2);
-            if (hostParts.length > 1) {
-                mHost = hostParts[1];
-            }
-        }
-
-        String[] pathParts = mUri.getPath().split("\\|");
-
-        for (int i = 0, count = pathParts.length; i < count; i++) {
-            if (i == 0) {
-                if (pathParts[0] != null &&
-                    pathParts[0].length() > 1) {
-                    if (!pathParts[0].substring(1).equals("")) {
-                        mPath = pathParts[0].substring(1);
-                    } else {
-                        mPath = "";
-                    }
-                } else {
-                    mPath = "";
-                }
-            } else if (i == 1) {
-                if (pathParts[1] != null &&
-                    pathParts[1].length() > 1) {
-                    mAuthPath = "/" + pathParts[1];
-                }
-            } else if (i == 2) {
-                if (pathParts[2] != null &&
-                    pathParts[2].length() > 1) {
-                    mMailboxPath = "/" + pathParts[2];
-                    if (mPath == null ||
-                        mPath.equals("")) {
-                        mPath = mMailboxPath;
-                    }
-                }
-            }
-        }
-        
-        if (mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED ||
-            mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED ||
-            mConnectionSecurity == CONNECTION_SECURITY_TLS_OPTIONAL ||
-            mConnectionSecurity == CONNECTION_SECURITY_SSL_OPTIONAL) {
-            this.mUrl = "https://" + mHost + ":" + mUri.getPort() + mPath;
-        } else {
-            this.mUrl = "http://" + mHost + ":" + mUri.getPort() + mPath;
-        }
-
-        if (mUri.getUserInfo() != null) {
-            String[] userInfoParts = mUri.getUserInfo().split(":", 2);
-            mUsername = userInfoParts[0];
-            String userParts[] = mUsername.split("/", 2);
-
-            if (userParts.length > 1) {
-                alias = userParts[1];
-            } else {
-                alias = mUsername;
-            }
-            if (userInfoParts.length > 1) {
-                mPassword = userInfoParts[1];
-            }
-        }
-        mSecure = mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED;
-        mAuthString = "Basic " + Utility.base64Encode(mUsername + ":" + mPassword);
-    }
-
-
-    @Override
-    public void checkSettings() throws MessagingException {
-        Log.e(Email.LOG_TAG, "WebDavStore.checkSettings() not implemented");
-    }
-
-    @Override
-    public Folder[] getPersonalNamespaces() throws MessagingException {
-        ArrayList<Folder> folderList = new ArrayList<Folder>();
-        HashMap<String, String> headers = new HashMap<String, String>();
-        DataSet dataset = new DataSet();
-        String messageBody;
-        String[] folderUrls;
-        int urlLength;
-
-        /**
-         * We have to check authentication here so we have the proper URL stored
-         */
-        getHttpClient();
-        messageBody = getFolderListXml();
-        headers.put("Brief", "t");
-        dataset = processRequest(this.mUrl, "SEARCH", messageBody, headers);
-
-        folderUrls = dataset.getHrefs();
-        urlLength = folderUrls.length;
-
-        for (int i = 0; i < urlLength; i++) {
-            String[] urlParts = folderUrls[i].split("/");
-            String folderName = urlParts[urlParts.length - 1];
-            String fullPathName = "";
-            WebDavFolder wdFolder;
-
-            if (folderName.equalsIgnoreCase(Email.INBOX)) {
-                folderName = "INBOX";
-            } else {
-                for (int j = 5, count = urlParts.length; j < count; j++) {
-                    if (j != 5) {
-                        fullPathName = fullPathName + "/" + urlParts[j];
-                    } else {
-                        fullPathName = urlParts[j];
-                    }
-                }
-                try {
-                    folderName = java.net.URLDecoder.decode(fullPathName, "UTF-8");
-                } catch (UnsupportedEncodingException uee) {
-                    /** If we don't support UTF-8 there's a problem, don't decode it then */
-                    folderName = fullPathName;
-                }
-            }
-
-            wdFolder = new WebDavFolder(folderName);
-            wdFolder.setUrl(folderUrls[i]);
-            folderList.add(wdFolder);
-            this.mFolderList.put(folderName, wdFolder);
-        }
-
-        return folderList.toArray(new WebDavFolder[] {});
-    }
-
-    @Override
-    public Folder getFolder(String name) throws MessagingException {
-        WebDavFolder folder;
-
-        if ((folder = this.mFolderList.get(name)) == null) {
-            folder = new WebDavFolder(name);
-        }
-
-        return folder;
-    }
-
-    /***************************************************************
-     * WebDAV XML Request body retrieval functions
-     */
-
-    private String getFolderListXml() {
-        StringBuffer buffer = new StringBuffer(200);
-        buffer.append("<?xml version='1.0' ?>");
-        buffer.append("<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n");
-        buffer.append("SELECT \"DAV:uid\", \"DAV:ishidden\"\r\n");
-        buffer.append(" FROM SCOPE('deep traversal of \""+this.mUrl+"\"')\r\n");
-        buffer.append(" WHERE \"DAV:ishidden\"=False AND \"DAV:isfolder\"=True\r\n");
-        buffer.append("</a:sql></a:searchrequest>\r\n");
-        return buffer.toString();
-    }
-
-    private String getMessageCountXml(String messageState) {
-        StringBuffer buffer = new StringBuffer(200);
-        buffer.append("<?xml version='1.0' ?>");
-        buffer.append("<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n");
-        buffer.append("SELECT \"DAV:visiblecount\"\r\n");
-        buffer.append(" FROM \"\"\r\n");
-        buffer.append(" WHERE \"DAV:ishidden\"=False AND \"DAV:isfolder\"=False AND \"urn:schemas:httpmail:read\"="+messageState+"\r\n");
-        buffer.append(" GROUP BY \"DAV:ishidden\"\r\n");
-        buffer.append("</a:sql></a:searchrequest>\r\n");
-        return buffer.toString();
-    }
-
-    private String getMessageEnvelopeXml(String[] uids) {
-        StringBuffer buffer = new StringBuffer(200);
-        buffer.append("<?xml version='1.0' ?>");
-        buffer.append("<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n");
-        buffer.append("SELECT \"DAV:uid\", \"DAV:getcontentlength\",");
-        buffer.append(" \"urn:schemas:mailheader:mime-version\",");
-        buffer.append(" \"urn:schemas:mailheader:content-type\",");
-        buffer.append(" \"urn:schemas:mailheader:subject\",");
-        buffer.append(" \"urn:schemas:mailheader:date\",");
-        buffer.append(" \"urn:schemas:mailheader:thread-topic\",");
-        buffer.append(" \"urn:schemas:mailheader:thread-index\",");
-        buffer.append(" \"urn:schemas:mailheader:from\",");
-        buffer.append(" \"urn:schemas:mailheader:to\",");
-        buffer.append(" \"urn:schemas:mailheader:in-reply-to\",");
-        buffer.append(" \"urn:schemas:mailheader:cc\",");
-        buffer.append(" \"urn:schemas:httpmail:read\"");
-        buffer.append(" \r\n");
-        buffer.append(" FROM \"\"\r\n");
-        buffer.append(" WHERE \"DAV:ishidden\"=False AND \"DAV:isfolder\"=False AND ");
-        for (int i = 0, count = uids.length; i < count; i++) {
-            if (i != 0) {
-                buffer.append("  OR ");
-            }
-            buffer.append(" \"DAV:uid\"='"+uids[i]+"' ");
-        }
-        buffer.append("\r\n");
-        buffer.append("</a:sql></a:searchrequest>\r\n");
-        return buffer.toString();
-    }
-
-    private String getMessagesXml() {
-        StringBuffer buffer = new StringBuffer(200);
-        buffer.append("<?xml version='1.0' ?>");
-        buffer.append("<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n");
-        buffer.append("SELECT \"DAV:uid\"\r\n");
-        buffer.append(" FROM \"\"\r\n");
-        buffer.append(" WHERE \"DAV:ishidden\"=False AND \"DAV:isfolder\"=False\r\n");
-        buffer.append("</a:sql></a:searchrequest>\r\n");
-        return buffer.toString();
-    }
-
-    private String getMessageUrlsXml(String[] uids) {
-        StringBuffer buffer = new StringBuffer(600);
-        buffer.append("<?xml version='1.0' ?>");
-        buffer.append("<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n");
-        buffer.append("SELECT \"urn:schemas:httpmail:read\", \"DAV:uid\"\r\n");
-        buffer.append(" FROM \"\"\r\n");
-        buffer.append(" WHERE \"DAV:ishidden\"=False AND \"DAV:isfolder\"=False AND ");
-        for (int i = 0, count = uids.length; i < count; i++) {
-            if (i != 0) {
-                buffer.append("  OR ");
-            }
-
-            buffer.append(" \"DAV:uid\"='"+uids[i]+"' ");
-
-        }
-        buffer.append("\r\n");
-        buffer.append("</a:sql></a:searchrequest>\r\n");
-        return buffer.toString();
-    }
-
-    private String getMessageFlagsXml(String[] uids) throws MessagingException {
-        if (uids.length == 0) {
-            throw new MessagingException("Attempt to get flags on 0 length array for uids");
-        }
-
-        StringBuffer buffer = new StringBuffer(200);
-        buffer.append("<?xml version='1.0' ?>");
-        buffer.append("<a:searchrequest xmlns:a='DAV:'><a:sql>\r\n");
-        buffer.append("SELECT \"urn:schemas:httpmail:read\", \"DAV:uid\"\r\n");
-        buffer.append(" FROM \"\"\r\n");
-        buffer.append(" WHERE \"DAV:ishidden\"=False AND \"DAV:isfolder\"=False AND ");
-
-        for (int i = 0, count = uids.length; i < count; i++) {
-            if (i != 0) {
-                buffer.append(" OR ");
-            }
-            buffer.append(" \"DAV:uid\"='"+uids[i]+"' ");
-        }
-        buffer.append("\r\n");
-        buffer.append("</a:sql></a:searchrequest>\r\n");
-        return buffer.toString();
-    }
-
-    private String getMarkMessagesReadXml(String[] urls) {
-        StringBuffer buffer = new StringBuffer(600);
-        buffer.append("<?xml version='1.0' ?>\r\n");
-        buffer.append("<a:propertyupdate xmlns:a='DAV:' xmlns:b='urn:schemas:httpmail:'>\r\n");
-        buffer.append("<a:target>\r\n");
-        for (int i = 0, count = urls.length; i < count; i++) {
-            buffer.append(" <a:href>"+urls[i]+"</a:href>\r\n");
-        }
-        buffer.append("</a:target>\r\n");
-        buffer.append("<a:set>\r\n");
-        buffer.append(" <a:prop>\r\n");
-        buffer.append("  <b:read>1</b:read>\r\n");
-        buffer.append(" </a:prop>\r\n");
-        buffer.append("</a:set>\r\n");
-        buffer.append("</a:propertyupdate>\r\n");
-        return buffer.toString();
-    }
-
-    /***************************************************************
-     * Authentication related methods
-     */
-
-    /**
-     * Performs Form Based authentication regardless of the current
-     * authentication state
-     * @throws MessagingException 
-     */
-    public void authenticate() throws MessagingException {
-        try {
-            doFBA();
-            //this.mAuthCookies = doAuthentication(this.mUsername, this.mPassword, this.mUrl);
-        } catch (IOException ioe) {
-            Log.e(Email.LOG_TAG, "Error during authentication: " + ioe + "\nStack: " + processException(ioe));
-            this.mAuthCookies = null;
-        }
-
-        if (this.mAuthCookies == null) {
-            this.mAuthenticated = false;
-        } else {
-            this.mAuthenticated = true;
-            this.mLastAuth = System.currentTimeMillis()/1000;
-        }
-    }
-
-    /**
-     * Determines if a new authentication is needed.
-     * Returns true if new authentication is needed.
-     */
-    public boolean needAuth() {
-        boolean status = false;
-        long currentTime = -1;
-        if (this.mAuthenticated == false) {
-            status = true;
-        }
-
-        currentTime = System.currentTimeMillis()/1000;
-        if ((currentTime - this.mLastAuth) > (this.mAuthTimeout)) {
-            status = true;
-        }
-        return status;
-    }
-
-    public static String getHttpRequestResponse(HttpEntity request, HttpEntity response) throws IllegalStateException, IOException{
-        String responseText = "";
-        String requestText = "";
-        if (response != null) {
-            BufferedReader reader = new BufferedReader(new InputStreamReader(response.getContent()), 8192);
-            String tempText = "";
-
-            while ((tempText = reader.readLine()) != null) {
-                responseText += tempText;
-            }
-        }
-        if (request != null) {
-            BufferedReader reader = new BufferedReader(new InputStreamReader(request.getContent()), 8192);
-            String tempText = "";
-
-            while ((tempText = reader.readLine()) != null) {
-                requestText += tempText;
-            }
-            requestText = requestText.replaceAll("password=.*?&", "password=(omitted)&");
-        }
-        return "Request: " + requestText +
-            "\n\nResponse: " + responseText;
-
-    }
-
-    /**
-     * Performs the Form Based Authentication
-     * Returns the CookieStore object for later use or null
-     * @throws MessagingException 
-     */
-    public void doFBA() throws IOException, MessagingException {
-        /*    public CookieStore doAuthentication(String username, String password,
-              String url) throws IOException, MessagingException {*/
-        String authPath;
-        String url = this.mUrl;
-        String username = this.mUsername;
-        String password = this.mPassword;
-        CookieStore cookies = null;
-        String[] urlParts = url.split("/");
-        String finalUrl = "";
-        String loginUrl = new String();
-        String destinationUrl = new String();
-
-        if (this.mAuthPath != null &&
-            !this.mAuthPath.equals("") &&
-            !this.mAuthPath.equals("/")) {
-            authPath = this.mAuthPath;
-        } else {
-            authPath = "/exchweb/bin/auth/owaauth.dll";
-        }
-
-        for (int i = 0; i <= 2; i++) {
-            if (i != 0) {
-                finalUrl = finalUrl + "/" + urlParts[i];
-            } else {
-                finalUrl = urlParts[i];
-            }
-        }
-
-        if (finalUrl.equals("")) {
-            throw new MessagingException("doFBA failed, unable to construct URL to post login credentials to.");
-        }
-
-        loginUrl = finalUrl + authPath;
-
-        try {
-            /* Browser Client */
-            DefaultHttpClient httpclient = mHttpClient;
-
-            /**
-             * This is in a separate block because I really don't like how it's done.
-             * This basically scrapes the OWA login page for the form submission URL.
-             * UGLY!
-             * Added an if-check to see if there's a user supplied authentication path for FBA
-             */
-            if (this.mAuthPath == null ||
-                this.mAuthPath.equals("") ||
-                this.mAuthPath.equals("/")) {
-                HttpGet httpget = new HttpGet(finalUrl);
-
-                httpclient.addRequestInterceptor(new HttpRequestInterceptor() {
-                        public void process(HttpRequest request, HttpContext context)
-                                                    throws HttpException, IOException {
-                            mRedirectUrl = ((HttpHost) context.getAttribute(ExecutionContext.HTTP_TARGET_HOST)).toURI() + request.getRequestLine().getUri();
-                        }
-                    });
-                HashMap<String, String> headers = new HashMap<String, String>();
-                InputStream istream = sendRequest(finalUrl, "GET", null, headers, false);
-
-                if (istream != null) {
-                    BufferedReader reader = new BufferedReader(new InputStreamReader(istream), 4096);
-                    String tempText = new String();
-                    boolean matched = false;
-
-                    while ((tempText = reader.readLine()) != null &&
-                           !matched) {
-                        if (tempText.indexOf(" action") >= 0) {
-                            String[] tagParts = tempText.split("\"");
-                            if (tagParts[1].lastIndexOf('/') < 0 &&
-                                mRedirectUrl != null &&
-                                !mRedirectUrl.equals("")) {
-                                /* We have to do a multi-stage substring here because of potential GET parameters */
-                                mRedirectUrl = mRedirectUrl.substring(0, mRedirectUrl.lastIndexOf('?'));
-                                mRedirectUrl = mRedirectUrl.substring(0, mRedirectUrl.lastIndexOf('/'));
-                                loginUrl = mRedirectUrl + "/" + tagParts[1];
-                                this.mAuthPath = "/" + tagParts[1];
-                            } else {
-                                loginUrl = finalUrl + tagParts[1];
-                                this.mAuthPath = "/" + tagParts[1];
-                            }
-                        }
-
-                        if (tempText.indexOf("destination") >= 0) {
-                            String[] tagParts = tempText.split("value");
-                            if (tagParts[1] != null) {
-                                String[] valueParts = tagParts[1].split("\"");
-                                destinationUrl = valueParts[1];
-                                matched = true;
-                            }
-                        }
-                    }
-                    istream.close();
-                }
-            }
-
-            /* Post Method */
-            HttpPost httppost = new HttpPost(loginUrl);
-
-            /** Build the POST data to use */
-            ArrayList<BasicNameValuePair> pairs = new ArrayList();
-            pairs.add(new BasicNameValuePair("username", username));
-            pairs.add(new BasicNameValuePair("password", password));
-            if (this.mMailboxPath != null &&
-                !this.mMailboxPath.equals("")) {
-                pairs.add(new BasicNameValuePair("destination", finalUrl + this.mMailboxPath));
-            } else if (destinationUrl != null &&
-                       !destinationUrl.equals("")) {
-                pairs.add(new BasicNameValuePair("destination", destinationUrl));
-            } else {
-                pairs.add(new BasicNameValuePair("destination", "/"));
-            }
-            pairs.add(new BasicNameValuePair("flags", "0"));
-            pairs.add(new BasicNameValuePair("SubmitCreds", "Log+On"));
-            pairs.add(new BasicNameValuePair("forcedownlevel", "0"));
-            pairs.add(new BasicNameValuePair("trusted", "0"));
-
-            try {
-                UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(pairs);
-                HashMap<String, String> headers = new HashMap<String, String>();
-                String tempUrl = "";
-                InputStream istream = sendRequest(loginUrl, "POST", formEntity, headers, false);
-
-                /** Get the URL for the mailbox and set it for the store */
-                if (istream != null) {
-                    BufferedReader reader = new BufferedReader(new InputStreamReader(istream), 8192);
-                    String tempText = "";
-
-                    while ((tempText = reader.readLine()) != null) {
-                        if (tempText.indexOf("BASE href") >= 0) {
-                            String[] tagParts = tempText.split("\"");
-                            tempUrl = tagParts[1];
-                        }
-                    }
-                }
-
-                if (this.mMailboxPath != null &&
-                    !this.mMailboxPath.equals("")) {
-                    this.mUrl = finalUrl + "/" + this.mMailboxPath + "/";
-                } else if (tempUrl.equals("")) {
-                    this.mUrl = finalUrl + "/Exchange/" + this.alias + "/";
-                } else {
-                    this.mUrl = tempUrl;
-                }
-
-            } catch (UnsupportedEncodingException uee) {
-                Log.e(Email.LOG_TAG, "Error encoding POST data for authentication: " + uee + "\nTrace: " + processException(uee));
-            }
-        } catch (SSLException e) {
-            throw new CertificateValidationException(e.getMessage(), e);
-        }
-        
-        this.mAuthenticated = true;
-    }
-
-    public CookieStore getAuthCookies() {
-        return mAuthCookies;
-    }
-
-    public String getAlias() {
-        return alias;
-    }
-
-    public String getUrl() {
-        return mUrl;
-    }
-
-    public DefaultHttpClient getHttpClient() throws MessagingException {
-        SchemeRegistry reg;
-        Scheme s;
-        boolean needAuth = false;
-        
-        if (mHttpClient == null) {
-            mHttpClient = new DefaultHttpClient();
-            needAuth = true;
-        }
-
-        reg = mHttpClient.getConnectionManager().getSchemeRegistry();
-        try {
-            s = new Scheme("https", new TrustedSocketFactory(mHost, mSecure), 443);
-        } catch (NoSuchAlgorithmException nsa) {
-            Log.e(Email.LOG_TAG, "NoSuchAlgorithmException in getHttpClient: " + nsa);
-            throw new MessagingException("NoSuchAlgorithmException in getHttpClient: " + nsa);
-        } catch (KeyManagementException kme) {
-            Log.e(Email.LOG_TAG, "KeyManagementException in getHttpClient: " + kme);
-            throw new MessagingException("KeyManagementException in getHttpClient: " + kme);
-        }
-        reg.register(s);
-
-        if (needAuth) {
-            HashMap<String, String> headers = new HashMap<String, String>();
-            processRequest(this.mUrl, "GET", null, headers, false);
-        }
-
-        /*
-        if (needAuth()) {
-            if (!checkAuth()) {
-                try {
-                    CookieStore cookies = mHttpClient.getCookieStore();
-                    cookies.clear();
-                    mHttpClient.setCookieStore(cookies);
-                    cookies = doAuthentication(this.mUsername, this.mPassword, this.mUrl);
-                    if (cookies != null) {
-                        this.mAuthenticated = true;
-                        this.mLastAuth = System.currentTimeMillis()/1000;
-                    }
-                    mHttpClient.setCookieStore(cookies);
-                } catch (IOException ioe) {
-                    Log.e(Email.LOG_TAG, "IOException: " + ioe + "\nTrace: " + processException(ioe));
-                }
-            } else {
-                Credentials creds = new UsernamePasswordCredentials(mUsername, mPassword);
-                CredentialsProvider credsProvider = mHttpClient.getCredentialsProvider();
-                credsProvider.setCredentials(new AuthScope(mHost, 80, AuthScope.ANY_REALM), creds);
-                credsProvider.setCredentials(new AuthScope(mHost, 443, AuthScope.ANY_REALM), creds);
-                credsProvider.setCredentials(new AuthScope(mHost, mUri.getPort(), AuthScope.ANY_REALM), creds);
-                mHttpClient.setCredentialsProvider(credsProvider);
-                // Assume we're authenticated and ok here since the checkAuth() was 401 and we've now set the credentials
-                this.mAuthenticated = true;
-                this.mLastAuth = System.currentTimeMillis()/1000;
-            }
-        }
-        */
-        return mHttpClient;
-    }
-
-    private boolean checkAuth() {
-        DefaultHttpClient httpclient = mHttpClient;
-        HttpResponse response;
-        HttpGet httpget = new HttpGet(mUrl);
-        try {
-            response = httpclient.execute(httpget);
-        } catch (IOException ioe) {
-            Log.e(Email.LOG_TAG, "Error checking authentication status");
-            return false;
-        }
-        
-        HttpEntity entity = response.getEntity();
-        int statusCode = response.getStatusLine().getStatusCode();
-
-        if (statusCode == 401) {
-            return true;
-        }
-
-        return false;
-    }
-    
-    public DefaultHttpClient getTrustedHttpClient() throws KeyManagementException, NoSuchAlgorithmException{
-        if (mHttpClient == null) {
-            mHttpClient = new DefaultHttpClient();
-            SchemeRegistry reg = mHttpClient.getConnectionManager().getSchemeRegistry();
-            Scheme s = new Scheme("https",new TrustedSocketFactory(mHost,mSecure),443);
-            reg.register(s);
-
-
-    		//Add credentials for NTLM/Digest/Basic Auth
-    		Credentials creds = new UsernamePasswordCredentials(mUsername, mPassword);
-    		CredentialsProvider credsProvider  = mHttpClient.getCredentialsProvider();
-    		// setting AuthScope for 80 and 443, in case we end up getting redirected
-    		// from 80 to 443.
-    		credsProvider.setCredentials(new AuthScope(mHost, 80, AuthScope.ANY_REALM), creds);
-    		credsProvider.setCredentials(new AuthScope(mHost, 443, AuthScope.ANY_REALM), creds);
-    		credsProvider.setCredentials(new AuthScope(mHost, mUri.getPort(), AuthScope.ANY_REALM), creds);
-    		mHttpClient.setCredentialsProvider(credsProvider);
-    	} 
-
-        return mHttpClient;
-    }
-
-    private InputStream sendRequest(String url, String method, StringEntity messageBody, HashMap<String, String> headers, boolean tryAuth)
-                                    throws MessagingException {
-        DefaultHttpClient httpclient;
-        InputStream istream = null;
-
-        if (url == null ||
-            method == null) {
-            return istream;
-        }
-
-        try {
-            httpclient = getHttpClient();
-        } catch (MessagingException me) {
-            Log.e(Email.LOG_TAG, "Generated MessagingException getting HttpClient: " + me);
-            return istream;
-        }
-
-        try {
-            int statusCode = -1;
-            StringEntity messageEntity = null;
-            HttpGeneric httpmethod = new HttpGeneric(url);
-            HttpResponse response;
-            HttpEntity entity;
-
-            if (messageBody != null) {
-                httpmethod.setEntity(messageBody);
-            }
-
-            for (String headerName : headers.keySet()) {
-                httpmethod.setHeader(headerName, headers.get(headerName));
-            }
-
-            if (mAuthString != null && mAuthenticated) {
-                httpmethod.setHeader("Authorization", mAuthString);
-            }
-
-            httpmethod.setMethod(method);
-            response = httpclient.execute(httpmethod);
-            statusCode = response.getStatusLine().getStatusCode();
-
-            entity = response.getEntity();
-
-            if (statusCode == 401) {
-                if (tryAuth) {
-                    mAuthenticated = true;
-                    sendRequest(url, method, messageBody, headers, false);
-                } else {
-                    throw new MessagingException("Invalid username or password for Basic authentication");
-                }
-            } else if (statusCode == 440) {
-                if (tryAuth) {
-                    doFBA();
-                    sendRequest(url, method, messageBody, headers, false);
-                } else {
-                    throw new MessagingException("Authentication failure in sendRequest");
-                }
-            } else if (statusCode < 200 ||
-                       statusCode >= 300) {
-                throw new IOException("Error during request processing: "+
-                                      response.getStatusLine().toString()+ "\n\n"+
-                                      getHttpRequestResponse(messageEntity, entity));
-            } else {
-                if (tryAuth &&
-                    mAuthenticated == false) {
-                    doFBA();
-                    sendRequest(url, method, messageBody, headers, false);
-                }
-            }
-
-            if (entity != null) {
-                istream = entity.getContent();
-            }
-        } catch (UnsupportedEncodingException uee) {
-            Log.e(Email.LOG_TAG, "UnsupportedEncodingException: " + uee + "\nTrace: " + processException(uee));
-        } catch (IOException ioe) {
-            Log.e(Email.LOG_TAG, "IOException: " + ioe + "\nTrace: " + processException(ioe));
-        }
-
-        return istream;
-    }
-
-    /**
-     * Performs an httprequest to the supplied url using the supplied method.
-     * messageBody and headers are optional as not all requests will need them.
-     * There are two signatures to support calls that don't require parsing of the response.
-     */
-    private DataSet processRequest(String url, String method, String messageBody, HashMap<String, String> headers)
-                                   throws MessagingException {
-        return processRequest(url, method, messageBody, headers, true);
-    }
-
-    private DataSet processRequest(String url, String method, String messageBody, HashMap<String, String> headers, boolean needsParsing)
-                                   throws MessagingException {
-        DataSet dataset = new DataSet();
-        DefaultHttpClient httpclient;
-
-        if (url == null ||
-            method == null) {
-            return dataset;
-        }
-
-        try {
-            httpclient = getHttpClient();
-        } catch (MessagingException me) {
-            Log.e(Email.LOG_TAG, "Generated MessagingException getting HttpClient: " + me);
-            return dataset;
-        }
-
-        try {
-            /*
-            int statusCode = -1;
-            */
-            StringEntity messageEntity = null;
-            /*
-            HttpGeneric httpmethod = new HttpGeneric(url);
-            HttpResponse response;
-            HttpEntity entity;
-            */
-            if (messageBody != null) {
-                messageEntity = new StringEntity(messageBody);
-                messageEntity.setContentType("text/xml");
-                //                httpmethod.setEntity(messageEntity);
-            }
-            /*
-            for (String headerName : headers.keySet()) {
-                httpmethod.setHeader(headerName, headers.get(headerName));
-            }
-
-            httpmethod.setMethod(method);
-
-            response = httpclient.execute(httpmethod);
-            statusCode = response.getStatusLine().getStatusCode();
-
-            entity = response.getEntity();
-
-            if (statusCode < 200 ||
-                statusCode > 300) {
-    			throw new IOException("Error during request processing: "+
-    					response.getStatusLine().toString()+ "\n\n"+
-    					getHttpRequestResponse(messageEntity, entity));
-            }
-
-            if (entity != null &&*/
-            InputStream istream = sendRequest(url, method, messageEntity, headers, true);
-            if (istream != null &&
-                needsParsing) {
-                try {
-                    /*InputStream istream = entity.getContent();*/
-                    SAXParserFactory spf = SAXParserFactory.newInstance();
-                    SAXParser sp = spf.newSAXParser();
-                    XMLReader xr = sp.getXMLReader();
-                    WebDavHandler myHandler = new WebDavHandler();
-                        
-                    xr.setContentHandler(myHandler);
-                    xr.parse(new InputSource(istream));
-
-                    dataset = myHandler.getDataSet();
-                } catch (SAXException se) {
-                    Log.e(Email.LOG_TAG, "SAXException in processRequest() " + se + "\nTrace: " + processException(se));
-                } catch (ParserConfigurationException pce) {
-                    Log.e(Email.LOG_TAG, "ParserConfigurationException in processRequest() " + pce + "\nTrace: " + processException(pce));
-                }
-
-                istream.close();
-            }
-        } catch (UnsupportedEncodingException uee) {
-            Log.e(Email.LOG_TAG, "UnsupportedEncodingException: " + uee + "\nTrace: " + processException(uee));
-        } catch (IOException ioe) {
-            Log.e(Email.LOG_TAG, "IOException: " + ioe + "\nTrace: " + processException(ioe));
-        }
-
-        return dataset;
-    }
-
-    /**
-     * Returns a string of the stacktrace for a Throwable to allow for easy inline printing of errors.
-     */
-    private String processException(Throwable t) {
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        PrintStream ps = new PrintStream(baos);
-
-        t.printStackTrace(ps);
-        ps.close();
-
-        return baos.toString();
-    }
-    
-    /*************************************************************************
-     * Helper and Inner classes
-     */
-
-    /**
-     * A WebDav Folder
-     */
-    class WebDavFolder extends Folder {
-        private String mName;
-        private String mLocalUsername;
-        private String mFolderUrl;
-        private boolean mIsOpen = false;
-        private int mMessageCount = 0;
-        private int mUnreadMessageCount = 0;
-        
-        public WebDavFolder(String name) {
-            String[] userParts;
-            String encodedName = new String();
-            try {
-                String[] urlParts = name.split("/");
-                String url = "";
-                for (int i = 0, count = urlParts.length; i < count; i++) {
-                    if (i != 0) {
-                        url = url + "/" + java.net.URLEncoder.encode(urlParts[i], "UTF-8");
-                    } else {
-                        url = java.net.URLEncoder.encode(urlParts[i], "UTF-8");
-                    }
-                }
-                encodedName = url;
-            } catch (UnsupportedEncodingException uee) {
-                Log.e(Email.LOG_TAG, "UnsupportedEncodingException URLEncoding folder name, skipping encoded");
-                encodedName = name;
-            }
-
-            encodedName = encodedName.replaceAll("\\+", "%20");
-            this.mName = name;
-            userParts = WebDavStore.this.mUsername.split("/", 2);
-
-            if (userParts.length > 1) {
-                this.mLocalUsername = userParts[1];
-            } else {
-                this.mLocalUsername = WebDavStore.this.mUsername;
-            }
-
-            /**
-             * In some instances, it is possible that our folder objects have been collected,
-             * but getPersonalNamespaces() isn't called again (ex. Android destroys the email client).
-             * Perform an authentication to get the appropriate URLs in place again
-             */
-            try {
-                getHttpClient();
-            } catch (MessagingException me) {
-                Log.e(Email.LOG_TAG, "MessagingException during authentication for WebDavFolder: " + me);
-                return;
-            }
-
-            if (encodedName.equals("INBOX")) {
-                encodedName = "Inbox";
-            }
-            
-            this.mFolderUrl = WebDavStore.this.mUrl + encodedName;
-        }
-
-        public void setUrl(String url) {
-            if (url != null) {
-                this.mFolderUrl = url;
-            }
-        }
-
-        @Override
-        public void open(OpenMode mode) throws MessagingException {
-            getHttpClient();
-
-            this.mIsOpen = true;
-        }
-
-        private int getMessageCount(boolean read, CookieStore authCookies) {
-            String isRead;
-            int messageCount = 0;
-            DataSet dataset = new DataSet();
-            HashMap<String, String> headers = new HashMap<String, String>();
-            String messageBody;
-            
-            if (read) {
-                isRead = new String("True");
-            } else {
-                isRead = new String("False");
-            }
-
-            messageBody = getMessageCountXml(isRead);
-            headers.put("Brief", "t");
-            try {
-                dataset = processRequest(this.mFolderUrl, "SEARCH", messageBody, headers);
-                if (dataset != null) {
-                    messageCount = dataset.getMessageCount();
-                }
-            } catch (MessagingException me) {
-                messageCount = 0;
-            }
-
-            return messageCount;
-        }
-
-        @Override
-        public int getMessageCount() throws MessagingException {
-            open(OpenMode.READ_WRITE);
-            this.mMessageCount = getMessageCount(true, WebDavStore.this.mAuthCookies);
-
-            return this.mMessageCount;
-        }
-
-        @Override
-        public int getUnreadMessageCount() throws MessagingException {
-            open(OpenMode.READ_WRITE);
-            this.mUnreadMessageCount = getMessageCount(false, WebDavStore.this.mAuthCookies);
-
-            return this.mUnreadMessageCount;
-        }
-
-        @Override
-        public boolean isOpen() {
-            return this.mIsOpen;
-        }
-
-        @Override
-        public OpenMode getMode() throws MessagingException {
-            return OpenMode.READ_WRITE;
-        }
-
-        @Override
-        public String getName() {
-            return this.mName;
-        }
-
-        @Override
-        public boolean exists() {
-            return true;
-        }
-
-        @Override
-        public void close(boolean expunge) throws MessagingException {
-            this.mMessageCount = 0;
-            this.mUnreadMessageCount = 0;
-                
-            this.mIsOpen = false;
-        }
-
-        @Override
-        public boolean create(FolderType type) throws MessagingException {
-            return true;
-        }
-
-        @Override
-        public void delete(boolean recursive) throws MessagingException {
-            throw new Error("WebDavFolder.delete() not implemeneted");
-        }
-
-        @Override
-        public Message getMessage(String uid) throws MessagingException {
-            return new WebDavMessage(uid, this);
-        }
-
-        @Override
-        public Message[] getMessages(int start, int end, MessageRetrievalListener listener)
-                throws MessagingException {
-            ArrayList<Message> messages = new ArrayList<Message>();
-            String[] uids;
-            DataSet dataset = new DataSet();
-            HashMap<String, String> headers = new HashMap<String, String>();
-            int uidsLength = -1;
-            
-            String messageBody;
-            int prevStart = start;
-
-            /** Reverse the message range since 0 index is newest */
-            start = this.mMessageCount - end;
-            end = this.mMessageCount - prevStart;
-
-            if (start < 0 || end < 0 || end < start) {
-                throw new MessagingException(String.format("Invalid message set %d %d", start, end));
-            }
-
-            if (start == 0 && end < 10) {
-                end = 10;
-            }
-            
-            /** Verify authentication */
-            messageBody = getMessagesXml();
-
-            headers.put("Brief", "t");
-            headers.put("Range", "rows=" + start + "-" + end);
-            dataset = processRequest(this.mFolderUrl, "SEARCH", messageBody, headers);
-
-            uids = dataset.getUids();
-            HashMap<String, String> uidToUrl = dataset.getUidToUrl();
-            uidsLength = uids.length;
-
-            for (int i = 0; i < uidsLength; i++) {
-                if (listener != null) {
-                    listener.messageStarted(uids[i], i, uidsLength);
-                }
-                WebDavMessage message = new WebDavMessage(uids[i], this);
-                message.setUrl(uidToUrl.get(uids[i]));
-                messages.add(message);
-                            
-                if (listener != null) {
-                    listener.messageFinished(message, i, uidsLength);
-                }
-            }
-
-            return messages.toArray(new Message[] {});
-        }
-
-        @Override
-        public Message[] getMessages(MessageRetrievalListener listener) throws MessagingException {
-            return getMessages(null, listener);
-        }
-
-        @Override
-        public Message[] getMessages(String[] uids, MessageRetrievalListener listener) throws MessagingException {
-            ArrayList<Message> messageList = new ArrayList<Message>();
-            Message[] messages;
-
-            if (uids == null ||
-                uids.length == 0) {
-                return messageList.toArray(new Message[] {});
-            }
-            
-            for (int i = 0, count = uids.length; i < count; i++) {
-                if (listener != null) {
-                    listener.messageStarted(uids[i], i, count);
-                }
-
-                WebDavMessage message = new WebDavMessage(uids[i], this);
-                messageList.add(message);
-                    
-                if (listener != null) {
-                    listener.messageFinished(message, i, count);
-                }
-            }
-            messages = messageList.toArray(new Message[] {});
-
-            return messages;
-        }
-
-        private HashMap<String, String> getMessageUrls(String[] uids) {
-            HashMap<String, String> uidToUrl = new HashMap<String, String>();
-            HashMap<String, String> headers = new HashMap<String, String>();
-            DataSet dataset = new DataSet();
-            String messageBody;
-
-            /** Retrieve and parse the XML entity for our messages */
-            messageBody = getMessageUrlsXml(uids);
-            headers.put("Brief", "t");
-
-            try {
-                dataset = processRequest(this.mFolderUrl, "SEARCH", messageBody, headers);
-                uidToUrl = dataset.getUidToUrl();
-            } catch (MessagingException me) {
-                Log.e(Email.LOG_TAG, "MessagingException from processRequest in getMessageUrls(): " + me);
-            }
-
-            return uidToUrl;
-        }
-        
-        @Override
-        public void fetch(Message[] messages, FetchProfile fp, MessageRetrievalListener listener)
-                throws MessagingException {
-            HashMap<String, Boolean> uidToReadStatus = new HashMap<String, Boolean>();
-
-            if (messages == null ||
-                messages.length == 0) {
-                return;
-            }
-
-            /**
-             * Fetch message flag info for the array
-             */
-            if (fp.contains(FetchProfile.Item.FLAGS)) {
-                fetchFlags(messages, listener);
-            }
-
-            /**
-             * Fetch message envelope information for the array
-             */
-            if (fp.contains(FetchProfile.Item.ENVELOPE)) {
-                fetchEnvelope(messages, listener);
-            }
-
-            if (fp.contains(FetchProfile.Item.BODY_SANE)) {
-                fetchMessages(messages, listener, FETCH_BODY_SANE_SUGGESTED_SIZE / 76);
-            }
-
-            if (fp.contains(FetchProfile.Item.BODY)) {
-                fetchMessages(messages, listener, -1);
-            }
-
-            if (fp.contains(FetchProfile.Item.STRUCTURE)) {
-                for (int i = 0, count = messages.length; i < count; i++) {
-                    if (!(messages[i] instanceof WebDavMessage)) {
-                        throw new MessagingException("WebDavStore fetch called with non-WebDavMessage");
-                    }
-                    WebDavMessage wdMessage = (WebDavMessage) messages[i];
-
-                    if (listener != null) {
-                        listener.messageStarted(wdMessage.getUid(), i, count);
-                    }
-
-                    wdMessage.setBody(null);
-
-                    if (listener != null) {
-                        listener.messageFinished(wdMessage, i, count);
-                    }
-                }
-            }
-        }
-
-        /**
-         * Fetches the full messages or up to lines lines and passes them to the message parser.
-         */
-        private void fetchMessages(Message[] messages, MessageRetrievalListener listener, int lines) throws MessagingException {
-            DefaultHttpClient httpclient;
-            httpclient = getHttpClient();
-            
-            /**
-             * We can't hand off to processRequest() since we need the stream to parse.
-             */
-            for (int i = 0, count = messages.length; i < count; i++) {
-                WebDavMessage wdMessage;
-                int statusCode = 0;
-                
-                if (!(messages[i] instanceof WebDavMessage)) {
-                    throw new MessagingException("WebDavStore fetch called with non-WebDavMessage");
-                }
-
-                wdMessage = (WebDavMessage) messages[i];
-
-                if (listener != null) {
-                    listener.messageStarted(wdMessage.getUid(), i, count);
-                }
-
-                /**
-                 * If fetch is called outside of the initial list (ie, a locally stored
-                 * message), it may not have a URL associated.  Verify and fix that
-                 */
-                if (wdMessage.getUrl().equals("")) {
-                    wdMessage.setUrl(getMessageUrls(new String[] {wdMessage.getUid()}).get(wdMessage.getUid()));
-                    if (wdMessage.getUrl().equals("")) {
-                        throw new MessagingException("Unable to get URL for message");
-                    }
-                }
-
-                try {
-                    HttpGet httpget = new HttpGet(new URI(wdMessage.getUrl()));
-                    HttpResponse response;
-                    HttpEntity entity;
-                    
-                    httpget.setHeader("translate", "f");
-
-                    response = httpclient.execute(httpget);
-                    
-                    statusCode = response.getStatusLine().getStatusCode();
-
-                    entity = response.getEntity();
-
-                    if (statusCode < 200 ||
-                        statusCode > 300) {
-            			throw new IOException("Error during fetch: "+
-            					response.getStatusLine().toString()+ "\n\n"+
-            					getHttpRequestResponse(null, entity));
-                    }
-
-                    if (entity != null) {
-                        InputStream istream = null;
-                        StringBuffer buffer = new StringBuffer();
-                        String tempText = new String();
-                        String resultText = new String();
-                        String bodyBoundary = "";
-                        BufferedReader reader;
-                        int currentLines = 0;
-                            
-                        istream = entity.getContent();
-                            
-                        if (lines != -1) {
-                            reader = new BufferedReader(new InputStreamReader(istream), 8192);
-
-                            while ((tempText = reader.readLine()) != null &&
-                                   (currentLines < lines)) {
-                                buffer.append(tempText+"\r\n");
-                                currentLines++;
-                            }
-
-                            istream.close();
-                            resultText = buffer.toString();
-                            istream = new ByteArrayInputStream(resultText.getBytes("UTF-8"));
-                        }
-
-                        wdMessage.parse(istream);
-                    }
-                
-                } catch (IllegalArgumentException iae) {
-                    Log.e(Email.LOG_TAG, "IllegalArgumentException caught " + iae + "\nTrace: " + processException(iae));
-                } catch (URISyntaxException use) {
-                    Log.e(Email.LOG_TAG, "URISyntaxException caught " + use + "\nTrace: " + processException(use));
-                } catch (IOException ioe) {
-                    Log.e(Email.LOG_TAG, "Non-success response code loading message, response code was " + statusCode + "\nURL: " + wdMessage.getUrl() + "\nError: " + ioe.getMessage() + "\nTrace: " + processException(ioe));
-                }
-
-                if (listener != null) {
-                    listener.messageFinished(wdMessage, i, count);
-                }
-            }
-        }
-        
-        /**
-         * Fetches and sets the message flags for the supplied messages.
-         * The idea is to have this be recursive so that we do a series of medium calls
-         * instead of one large massive call or a large number of smaller calls.
-         */
-        private void fetchFlags(Message[] startMessages, MessageRetrievalListener listener) throws MessagingException {
-            HashMap<String, Boolean> uidToReadStatus = new HashMap<String, Boolean>();
-            HashMap<String, String> headers = new HashMap<String, String>();
-            DataSet dataset = new DataSet();
-            String messageBody = new String();
-            Message[] messages = new Message[20];
-            String[] uids;
-            
-
-            if (startMessages == null ||
-                startMessages.length == 0) {
-                return;
-            }
-
-            if (startMessages.length > 20) {
-                Message[] newMessages = new Message[startMessages.length - 20];
-                for (int i = 0, count = startMessages.length; i < count; i++) {
-                    if (i < 20) {
-                        messages[i] = startMessages[i];
-                    } else {
-                        newMessages[i - 20] = startMessages[i];
-                    }
-                }
-
-                fetchFlags(newMessages, listener);
-            } else {
-                messages = startMessages;
-            }
-
-            uids = new String[messages.length];
-
-            for (int i = 0, count = messages.length; i < count; i++) {
-                uids[i] = messages[i].getUid();
-            }
-
-            messageBody = getMessageFlagsXml(uids);
-            headers.put("Brief", "t");
-            dataset = processRequest(this.mFolderUrl, "SEARCH", messageBody, headers);
-
-            if (dataset == null) {
-                throw new MessagingException("Data Set from request was null");
-            }
-            
-            uidToReadStatus = dataset.getUidToRead();
-
-            for (int i = 0, count = messages.length; i < count; i++) {
-                if (!(messages[i] instanceof WebDavMessage)) {
-                    throw new MessagingException("WebDavStore fetch called with non-WebDavMessage");
-                }
-                WebDavMessage wdMessage = (WebDavMessage) messages[i];
-                
-                if (listener != null) {
-                    listener.messageStarted(messages[i].getUid(), i, count);
-                }
-
-                wdMessage.setFlagInternal(Flag.SEEN, uidToReadStatus.get(wdMessage.getUid()));
-
-                if (listener != null) {
-                    listener.messageFinished(messages[i], i, count);
-                }
-            }
-        }
-        
-        /**
-         * Fetches and parses the message envelopes for the supplied messages.
-         * The idea is to have this be recursive so that we do a series of medium calls
-         * instead of one large massive call or a large number of smaller calls.
-         * Call it a happy balance
-         */
-        private void fetchEnvelope(Message[] startMessages, MessageRetrievalListener listener) throws MessagingException {
-            HashMap<String, ParsedMessageEnvelope> envelopes = new HashMap<String, ParsedMessageEnvelope>();
-            HashMap<String, String> headers = new HashMap<String, String>();
-            DataSet dataset = new DataSet();
-            String messageBody = new String();
-            String[] uids;
-            Message[] messages = new Message[10];
-
-            if (startMessages == null ||
-                startMessages.length == 0) {
-                return;
-            }
-
-            if (startMessages.length > 10) {
-                Message[] newMessages = new Message[startMessages.length - 10];
-                for (int i = 0, count = startMessages.length; i < count; i++) {
-                    if (i < 10) {
-                        messages[i] = startMessages[i];
-                    } else {
-                        newMessages[i - 10] = startMessages[i];
-                    }
-                }
-
-                fetchEnvelope(newMessages, listener);
-            } else {
-                messages = startMessages;
-            }
-
-            uids = new String[messages.length];
-
-            for (int i = 0, count = messages.length; i < count; i++) {
-                uids[i] = messages[i].getUid();
-            }
-
-            messageBody = getMessageEnvelopeXml(uids);
-            headers.put("Brief", "t");
-            dataset = processRequest(this.mFolderUrl, "SEARCH", messageBody, headers);
-
-            envelopes = dataset.getMessageEnvelopes();
-
-            int count = messages.length;
-            for (int i = messages.length - 1; i >= 0; i--) {
-                if (!(messages[i] instanceof WebDavMessage)) {
-                    throw new MessagingException("WebDavStore fetch called with non-WebDavMessage");
-                }
-                WebDavMessage wdMessage = (WebDavMessage) messages[i];
-                
-                if (listener != null) {
-                    listener.messageStarted(messages[i].getUid(), i, count);
-                }
-
-                wdMessage.setNewHeaders(envelopes.get(wdMessage.getUid()));
-                wdMessage.setFlagInternal(Flag.SEEN, envelopes.get(wdMessage.getUid()).getReadStatus());
-
-                if (listener != null) {
-                    listener.messageFinished(messages[i], i, count);
-                }
-            }
-        }
-
-        @Override
-        public Flag[] getPermanentFlags() throws MessagingException {
-            return PERMANENT_FLAGS;
-        }
-
-        @Override
-        public void setFlags(Message[] messages, Flag[] flags, boolean value)
-                throws MessagingException {
-            String[] uids = new String[messages.length];
-
-            for (int i = 0, count = messages.length; i < count; i++) {
-                uids[i] = messages[i].getUid();
-            }
-
-            for (int i = 0, count = flags.length; i < count; i++) {
-                Flag flag = flags[i];
-
-                if (flag == Flag.SEEN) {
-                    markServerMessagesRead(uids);
-                } else if (flag == Flag.DELETED) {
-                    deleteServerMessages(uids);
-                }
-            }
-        }
-
-        private void markServerMessagesRead(String[] uids) throws MessagingException {
-            String messageBody = new String();
-            HashMap<String, String> headers = new HashMap<String, String>();
-            HashMap<String, String> uidToUrl = getMessageUrls(uids);
-            DataSet dataset = new DataSet();
-            String[] urls = new String[uids.length];
-
-            for (int i = 0, count = uids.length; i < count; i++) {
-                urls[i] = uidToUrl.get(uids[i]);
-            }
-            
-            messageBody = getMarkMessagesReadXml(urls);
-            headers.put("Brief", "t");
-            headers.put("If-Match", "*");
-
-            processRequest(this.mFolderUrl, "BPROPPATCH", messageBody, headers, false);
-        }
-
-        private void deleteServerMessages(String[] uids) throws MessagingException {
-            HashMap<String, String> uidToUrl = getMessageUrls(uids);
-            String[] urls = new String[uids.length];
-
-            for (int i = 0, count = uids.length; i < count; i++) {
-                HashMap<String, String> headers = new HashMap<String, String>();
-                String uid = uids[i];
-                String url = uidToUrl.get(uid);
-                String destinationUrl = generateDeleteUrl(url);
-
-                /**
-                 * If the destination is the same as the origin, assume delete forever
-                 */
-                if (destinationUrl.equals(url)) {
-                    headers.put("Brief", "t");
-                    processRequest(url, "DELETE", null, headers, false);
-                } else {
-                    headers.put("Destination", generateDeleteUrl(url));
-                    headers.put("Brief", "t");
-                    processRequest(url, "MOVE", null, headers, false);
-                }
-            }
-        }
-
-        private String generateDeleteUrl(String startUrl) {
-            String[] urlParts = startUrl.split("/");
-            String filename = urlParts[urlParts.length - 1];
-            String finalUrl = WebDavStore.this.mUrl + "Deleted%20Items/" + filename;
-
-            return finalUrl;
-        }
-
-        @Override
-        public void appendMessages(Message[] messages) throws MessagingException {
-            Log.e(Email.LOG_TAG, "appendMessages() not implmented");
-        }
-
-        @Override
-        public Message[] expunge() throws MessagingException {
-            /** Do nothing, deletes occur as soon as the call is made rather than flags on the message */
-            return null;
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            return false;
-        }
-
-        public String getUidFromMessageId(Message message) throws MessagingException {
-            Log.e(Email.LOG_TAG, "Unimplemented method getUidFromMessageId in WebDavStore.WebDavFolder could lead to duplicate messages "
-                  + " being uploaded to the Sent folder");
-            return null;
-        }
-
-        public void setFlags(Flag[] flags, boolean value) throws MessagingException {
-            Log.e(Email.LOG_TAG, "Unimplemented method setFlags(Flag[], boolean) breaks markAllMessagesAsRead and EmptyTrash");
-            // Try to make this efficient by not retrieving all of the messages
-            return;
-        }
-    }
-    
-    /**
-     * A WebDav Message
-     */
-    class WebDavMessage extends MimeMessage {
-        private String mUrl = new String();
-        
-        WebDavMessage(String uid, Folder folder) throws MessagingException {
-            this.mUid = uid;
-            this.mFolder = folder;
-        }
-
-        public void setUrl(String url) {
-            //TODO: This is a not as ugly hack (ie, it will actually work)
-            //XXX: prevent URLs from getting to us that are broken
-            if (!(url.toLowerCase().contains("http"))) {
-                if (!(url.startsWith("/"))){
-                    url = "/" + url;
-                }
-                url = WebDavStore.this.mUrl + this.mFolder + url;
-            }
-
-            String[] urlParts = url.split("/");
-            int length = urlParts.length;
-            String end = urlParts[length - 1];
-            
-            this.mUrl = new String();
-            url = new String();
-
-            /**
-             * We have to decode, then encode the URL because Exchange likes to
-             * not properly encode all characters
-             */
-            try {
-                end = java.net.URLDecoder.decode(end, "UTF-8");
-                end = java.net.URLEncoder.encode(end, "UTF-8");
-                end = end.replaceAll("\\+", "%20");
-            } catch (UnsupportedEncodingException uee) {
-                Log.e(Email.LOG_TAG, "UnsupportedEncodingException caught in setUrl: " + uee + "\nTrace: " + processException(uee));
-            } catch (IllegalArgumentException iae) {
-                Log.e(Email.LOG_TAG, "IllegalArgumentException caught in setUrl: " + iae + "\nTrace: " + processException(iae));
-            }
-
-            for (int i = 0; i < length - 1; i++) {
-                if (i != 0) {
-                    url = url + "/" + urlParts[i];
-                } else {
-                    url = urlParts[i];
-                }
-            }
-
-            url = url + "/" + end;
-
-            this.mUrl = url;
-        }
-
-        public String getUrl() {
-            return this.mUrl;
-        }
-        
-        public void setSize(int size) {
-            this.mSize = size;
-        }
-
-        public void parse(InputStream in) throws IOException, MessagingException {
-            super.parse(in);
-        }
-
-        public void setFlagInternal(Flag flag, boolean set) throws MessagingException {
-            super.setFlag(flag, set);
-        }
-
-        public void setNewHeaders(ParsedMessageEnvelope envelope) throws MessagingException {
-            String[] headers = envelope.getHeaderList();
-            HashMap<String, String> messageHeaders = envelope.getMessageHeaders();
-            
-            for (int i = 0, count = headers.length; i < count; i++) {
-                String headerValue = messageHeaders.get(headers[i]);
-                if (headers[i].equals("Content-Length")) {
-                    int size = new Integer(messageHeaders.get(headers[i])).intValue();
-                    this.setSize(size);
-                }
-
-                if (headerValue != null &&
-                    !headerValue.equals("")) {
-                    this.addHeader(headers[i], headerValue);
-                }
-            }
-        }
-        
-        @Override
-        public void setFlag(Flag flag, boolean set) throws MessagingException {
-            super.setFlag(flag, set);
-            mFolder.setFlags(new Message[] { this }, new Flag[] { flag }, set);
-        }
-    }
-    
-    /** 
-     * XML Parsing Handler
-     * Can handle all XML handling needs
-     */
-    public class WebDavHandler extends DefaultHandler {
-        private DataSet mDataSet = new DataSet();
-        private Stack<String> mOpenTags = new Stack<String>();
-        
-        public DataSet getDataSet() {
-            return this.mDataSet;
-        }
-
-        @Override
-        public void startDocument() throws SAXException {
-            this.mDataSet = new DataSet();
-        }
-
-        @Override
-        public void endDocument() throws SAXException {
-            /* Do nothing */
-        }
-
-        @Override
-        public void startElement(String namespaceURI, String localName,
-                                 String qName, Attributes atts) throws SAXException {
-            mOpenTags.push(localName);
-        }
-
-        @Override
-        public void endElement(String namespaceURI, String localName, String qName) {
-            mOpenTags.pop();
-
-            /** Reset the hash temp variables */
-            if (localName.equals("response")) {
-                this.mDataSet.finish();
-            }
-        }
-
-        @Override
-        public void characters(char ch[], int start, int length) {
-            String value = new String(ch, start, length);
-            mDataSet.addValue(value, mOpenTags.peek());
-        }
-    }
-
-    /**
-     * Data set for a single E-Mail message's required headers (the envelope)
-     * Only provides accessor methods to the stored data.  All processing should be
-     * done elsewhere.  This is done rather than having multiple hashmaps 
-     * associating UIDs to values
-     */
-    public class ParsedMessageEnvelope {
-        /**
-         * Holds the mappings from the name returned from Exchange to the MIME format header name
-         */
-        private final HashMap<String, String> mHeaderMappings = new HashMap<String, String>() {
-        {
-            put("mime-version", "MIME-Version");
-            put("content-type", "Content-Type");
-            put("subject", "Subject");
-            put("date", "Date");
-            put("thread-topic", "Thread-Topic");
-            put("thread-index", "Thread-Index");
-            put("from", "From");
-            put("to", "To");
-            put("in-reply-to", "In-Reply-To");
-            put("cc", "Cc");
-            put("getcontentlength", "Content-Length");
-        }
-        };
-        
-        private boolean mReadStatus = false;
-        private String mUid = new String();
-        private HashMap<String, String> mMessageHeaders = new HashMap<String, String>();
-        private ArrayList<String> mHeaders = new ArrayList<String>();
-        
-        public void addHeader(String field, String value) {
-            String headerName = mHeaderMappings.get(field);
-
-            if (headerName != null) {
-                this.mMessageHeaders.put(mHeaderMappings.get(field), value);
-                this.mHeaders.add(mHeaderMappings.get(field));
-            }
-        }
-
-        public HashMap<String, String> getMessageHeaders() {
-            return this.mMessageHeaders;
-        }
-
-        public String[] getHeaderList() {
-            return this.mHeaders.toArray(new String[] {});
-        }
-        
-        public void setReadStatus(boolean status) {
-            this.mReadStatus = status;
-        }
-
-        public boolean getReadStatus() {
-            return this.mReadStatus;
-        }
-
-        public void setUid(String uid) {
-            if (uid != null) {
-                this.mUid = uid;
-            }
-        }
-
-        public String getUid() {
-            return this.mUid;
-        }
-    }
-
-    /**
-     * Dataset for all XML parses.
-     * Data is stored in a single format inside the class and is formatted appropriately depending on the accessor calls made.
-     */
-    public class DataSet {
-        private HashMap<String, HashMap> mData = new HashMap<String, HashMap>();
-        private HashMap<String, String> mLostData = new HashMap<String, String>();
-        private String mUid = new String();
-        private HashMap<String, String> mTempData = new HashMap<String, String>();
-
-        public void addValue(String value, String tagName) {
-            if (tagName.equals("uid")) {
-                mUid = value;
-            }
-
-            if (mTempData.containsKey(tagName)) {
-                mTempData.put(tagName, mTempData.get(tagName) + value);
-            } else {
-                mTempData.put(tagName, value);
-            }
-        }
-
-        public void finish() {
-            if (mUid != null &&
-                mTempData != null) {
-                mData.put(mUid, mTempData);
-            } else if (mTempData != null) {
-                /* Lost Data are for requests that don't include a message UID.
-                 * These requests should only have a depth of one for the response so it will never get stomped over.
-                 */
-                mLostData = mTempData;
-                String visibleCount = mLostData.get("visiblecount");
-            }
-
-            mUid = new String();
-            mTempData = new HashMap<String, String>();
-        }
-
-        /**
-         * Returns a hashmap of Message UID => Message Url
-         */
-        public HashMap<String, String> getUidToUrl() {
-            HashMap<String, String> uidToUrl = new HashMap<String, String>();
-
-            for (String uid : mData.keySet()) {
-                HashMap<String, String> data = mData.get(uid);
-                String value = data.get("href");
-                if (value != null &&
-                    !value.equals("")) {
-                    uidToUrl.put(uid, value);
-                }
-            }
-
-            return uidToUrl;
-        }
-
-        /**
-         * Returns a hashmap of Message UID => Read Status
-         */
-        public HashMap<String, Boolean> getUidToRead() {
-            HashMap<String, Boolean> uidToRead = new HashMap<String, Boolean>();
-
-            for (String uid : mData.keySet()) {
-                HashMap<String, String> data = mData.get(uid);
-                String readStatus = data.get("read");
-                if (readStatus != null &&
-                    !readStatus.equals("")) {
-                    Boolean value = readStatus.equals("0") ? false : true;
-                    uidToRead.put(uid, value);
-                }
-            }
-
-            return uidToRead;
-        }
-
-        /**
-         * Returns an array of all hrefs (urls) that were received
-         */
-        public String[] getHrefs() {
-            ArrayList<String> hrefs = new ArrayList<String>();
-
-            for (String uid : mData.keySet()) {
-                HashMap<String, String> data = mData.get(uid);
-                String href = data.get("href");
-                hrefs.add(href);
-            }
-
-            return hrefs.toArray(new String[] {});
-        }
-
-        /**
-         * Return an array of all Message UIDs that were received
-         */
-        public String[] getUids() {
-            ArrayList<String> uids = new ArrayList<String>();
-
-            for (String uid : mData.keySet()) {
-                uids.add(uid);
-            }
-
-            return uids.toArray(new String[] {});
-        }
-
-        /**
-         * Returns the message count as it was retrieved
-         */
-        public int getMessageCount() {
-            int messageCount = -1;
-
-            for (String uid : mData.keySet()) {
-                HashMap<String, String> data = mData.get(uid);
-                String count = data.get("visiblecount");
-
-                if (count != null &&
-                    !count.equals("")) {
-                    messageCount = new Integer(count).intValue();
-                }
-                
-            }
-
-            return messageCount;
-        }
-
-        /**
-         * Returns a HashMap of message UID => ParsedMessageEnvelope
-         */
-        public HashMap<String, ParsedMessageEnvelope> getMessageEnvelopes() {
-            HashMap<String, ParsedMessageEnvelope> envelopes = new HashMap<String, ParsedMessageEnvelope>();
-
-            for (String uid : mData.keySet()) {
-                ParsedMessageEnvelope envelope = new ParsedMessageEnvelope();
-                HashMap<String, String> data = mData.get(uid);
-
-                if (data != null) {
-                    for (String header : data.keySet()) {
-                        if (header.equals("read")) {
-                            String read = data.get(header);
-                            Boolean readStatus = read.equals("0") ? false : true;
-
-                            envelope.setReadStatus(readStatus);
-                        } else if (header.equals("date")) {
-                            /**
-                             * Exchange doesn't give us rfc822 dates like it claims.  The date is in the format:
-                             * yyyy-MM-dd'T'HH:mm:ss.SSS<Single digit representation of timezone, so far, all instances are Z>
-                             */
-                            String date = data.get(header);
-                            date = date.substring(0, date.length() - 1);
-                            
-                            DateFormat dfInput = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS");
-                            DateFormat dfOutput = new SimpleDateFormat("EEE, d MMM yy HH:mm:ss Z");
-                            String tempDate = "";
-
-                            try {
-                                Date parsedDate = dfInput.parse(date);
-                                tempDate = dfOutput.format(parsedDate);
-                            } catch (java.text.ParseException pe) {
-                                Log.e(Email.LOG_TAG, "Error parsing date: "+ pe + "\nTrace: " + processException(pe));
-                            }
-                            envelope.addHeader(header, tempDate);
-                        } else {
-                            envelope.addHeader(header, data.get(header));
-                        }
-                    }
-                } 
-
-                if (envelope != null) {
-                    envelopes.put(uid, envelope);
-                }
-            }
-
-            return envelopes;
-        }
-    }
-    
-    /**
-     * New HTTP Method that allows changing of the method and generic handling
-     * Needed for WebDAV custom methods such as SEARCH and PROPFIND
-     */
-    public class HttpGeneric extends HttpEntityEnclosingRequestBase {
-        public String METHOD_NAME = "POST";
-
-        public HttpGeneric() {
-            super();
-        }
-
-        public HttpGeneric(final URI uri) {
-            super();
-            setURI(uri);
-        }
-
-        /**
-         * @throws IllegalArgumentException if the uri is invalid. 
-         */
-        public HttpGeneric(final String uri) {
-            super();
-
-            String[] urlParts = uri.split("/");
-            int length = urlParts.length;
-            String end = urlParts[length - 1];
-            String url = new String();
-            
-            /**
-             * We have to decode, then encode the URL because Exchange likes to
-             * not properly encode all characters
-             */
-            try {
-                if (length > 3) {
-                    end = java.net.URLDecoder.decode(end, "UTF-8");
-                    end = java.net.URLEncoder.encode(end, "UTF-8");
-                    end = end.replaceAll("\\+", "%20");
-                }
-            } catch (UnsupportedEncodingException uee) {
-                Log.e(Email.LOG_TAG, "UnsupportedEncodingException caught in HttpGeneric(String uri): " + uee + "\nTrace: " + processException(uee));
-            } catch (IllegalArgumentException iae) {
-                Log.e(Email.LOG_TAG, "IllegalArgumentException caught in HttpGeneric(String uri): " + iae + "\nTrace: " + processException(iae));
-            }
-
-            for (int i = 0; i < length - 1; i++) {
-                if (i != 0) {
-                    url = url + "/" + urlParts[i];
-                } else {
-                    url = urlParts[i];
-                }
-            }
-
-            url = url + "/" + end;
-            setURI(URI.create(url));
-        }
-
-        @Override
-        public String getMethod() {
-            return METHOD_NAME;
-        }
-
-        public void setMethod(String method) {
-            if (method != null) {
-                METHOD_NAME = method;
-            }
-        }
-    }
-}
Index: src/com/android/email/mail/store/TrustManagerFactory.java
===================================================================
--- src/com/android/email/mail/store/TrustManagerFactory.java	(revision 718)
+++ src/com/android/email/mail/store/TrustManagerFactory.java	(working copy)
@@ -102,20 +102,9 @@
     static {
         try {
             javax.net.ssl.TrustManagerFactory tmf = javax.net.ssl.TrustManagerFactory.getInstance("X509");
-            Application app = Email.app;
-            keyStoreFile = new File(app.getDir("KeyStore", Context.MODE_PRIVATE) + File.separator + "KeyStore.bks");
             keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
-    		java.io.FileInputStream fis;
-			try {
-				fis = new java.io.FileInputStream(keyStoreFile);
-			} catch (FileNotFoundException e1) {
-				fis = null;
-			}
     		try {
-    			keyStore.load(fis, "".toCharArray());
-        		//if (fis != null) {
-        		//	fis.close();
-        		//}
+    			keyStore.load(null, "".toCharArray());
     		} catch (IOException e) {
                 Log.e(LOG_TAG, "KeyStore IOException while initializing TrustManagerFactory ", e);
     			keyStore = null;
Index: src/com/android/email/mail/store/ImapResponseParser.java
===================================================================
--- src/com/android/email/mail/store/ImapResponseParser.java	(revision 718)
+++ src/com/android/email/mail/store/ImapResponseParser.java	(working copy)
@@ -235,7 +235,8 @@
                 sb.append((char)ch);
             }
         }
-        throw new IOException("readQuotedString(): end of stream reached");
+        // TODO: chstuder: Remove "read so far"
+        throw new IOException("readQuotedString(): end of stream reached (Read '" + sb.toString() + "' so far.)");
     }
 
     private int expect(char ch) throws IOException {
Index: src/com/android/email/activity/setup/AccountSettings.java
===================================================================
--- src/com/android/email/activity/setup/AccountSettings.java	(revision 718)
+++ src/com/android/email/activity/setup/AccountSettings.java	(working copy)
@@ -1,365 +0,0 @@
-
-package com.android.email.activity.setup;
-
-import android.content.Context;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.os.Bundle;
-import android.view.KeyEvent;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.widget.Button;
-import com.android.email.K9PreferenceActivity;
-import android.preference.EditTextPreference;
-import android.preference.ListPreference;
-import android.preference.CheckBoxPreference;
-import android.preference.Preference;
-import android.preference.PreferenceScreen;
-import android.preference.RingtonePreference;
-import android.preference.Preference.OnPreferenceClickListener;
-
-import com.android.email.Account;
-import com.android.email.Email;
-import com.android.email.Preferences;
-import com.android.email.R;
-import com.android.email.activity.ChooseFolder;
-import com.android.email.activity.ChooseIdentity;
-import com.android.email.activity.ManageIdentities;
-
-public class AccountSettings extends K9PreferenceActivity {
-    private static final String EXTRA_ACCOUNT = "account";
-    
-    private static final int SELECT_AUTO_EXPAND_FOLDER = 1;
-
-    private static final int ACTIVITY_MANAGE_IDENTITIES = 2;
-
-    private static final String PREFERENCE_TOP_CATERGORY = "account_settings";
-    private static final String PREFERENCE_DESCRIPTION = "account_description";
-    private static final String PREFERENCE_COMPOSITION = "composition";
-    private static final String PREFERENCE_MANAGE_IDENTITIES = "manage_identities";
-    private static final String PREFERENCE_FREQUENCY = "account_check_frequency";
-    private static final String PREFERENCE_DISPLAY_COUNT = "account_display_count";
-    private static final String PREFERENCE_DEFAULT = "account_default";
-    private static final String PREFERENCE_HIDE_BUTTONS = "hide_buttons_enum";
-    private static final String PREFERENCE_NOTIFY = "account_notify";
-    private static final String PREFERENCE_NOTIFY_SYNC = "account_notify_sync";
-    private static final String PREFERENCE_VIBRATE = "account_vibrate";
-    private static final String PREFERENCE_RINGTONE = "account_ringtone";
-    private static final String PREFERENCE_INCOMING = "incoming";
-    private static final String PREFERENCE_OUTGOING = "outgoing";
-    private static final String PREFERENCE_DISPLAY_MODE = "folder_display_mode";
-    private static final String PREFERENCE_SYNC_MODE = "folder_sync_mode";
-    private static final String PREFERENCE_TARGET_MODE = "folder_target_mode";
-    private static final String PREFERENCE_DELETE_POLICY = "delete_policy";
-    private static final String PREFERENCE_AUTO_EXPAND_FOLDER = "account_setup_auto_expand_folder";
-
-    private Account mAccount;
-
-    private EditTextPreference mAccountDescription;
-    private ListPreference mCheckFrequency;
-    private ListPreference mDisplayCount;
-    private CheckBoxPreference mAccountDefault;
-    private CheckBoxPreference mAccountNotify;
-    private ListPreference mAccountHideButtons;
-    private CheckBoxPreference mAccountNotifySync;
-    private CheckBoxPreference mAccountVibrate;
-    private RingtonePreference mAccountRingtone;
-    private ListPreference mDisplayMode;
-    private ListPreference mSyncMode;
-    private ListPreference mTargetMode;
-    private ListPreference mDeletePolicy;
-    private Preference mAutoExpandFolder;
-
-    public static void actionSettings(Context context, Account account) {
-        Intent i = new Intent(context, AccountSettings.class);
-        i.putExtra(EXTRA_ACCOUNT, account);
-        context.startActivity(i);
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        mAccount = (Account)getIntent().getSerializableExtra(EXTRA_ACCOUNT);
-
-        addPreferencesFromResource(R.xml.account_settings_preferences);
-
-        Preference category = findPreference(PREFERENCE_TOP_CATERGORY);
-        category.setTitle(getString(R.string.account_settings_title_fmt));
-
-        mAccountDescription = (EditTextPreference) findPreference(PREFERENCE_DESCRIPTION);
-        mAccountDescription.setSummary(mAccount.getDescription());
-        mAccountDescription.setText(mAccount.getDescription());
-        mAccountDescription.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
-            public boolean onPreferenceChange(Preference preference, Object newValue) {
-                final String summary = newValue.toString();
-                mAccountDescription.setSummary(summary);
-                mAccountDescription.setText(summary);
-                return false;
-            }
-        });
-
-
-        mCheckFrequency = (ListPreference) findPreference(PREFERENCE_FREQUENCY);
-        mCheckFrequency.setValue(String.valueOf(mAccount.getAutomaticCheckIntervalMinutes()));
-        mCheckFrequency.setSummary(mCheckFrequency.getEntry());
-        mCheckFrequency.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
-            public boolean onPreferenceChange(Preference preference, Object newValue) {
-                final String summary = newValue.toString();
-                int index = mCheckFrequency.findIndexOfValue(summary);
-                mCheckFrequency.setSummary(mCheckFrequency.getEntries()[index]);
-                mCheckFrequency.setValue(summary);
-                return false;
-            }
-        });
-        
-        mDisplayMode = (ListPreference) findPreference(PREFERENCE_DISPLAY_MODE);
-        mDisplayMode.setValue(mAccount.getFolderDisplayMode().name());
-        mDisplayMode.setSummary(mDisplayMode.getEntry());
-        mDisplayMode.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
-            public boolean onPreferenceChange(Preference preference, Object newValue) {
-                final String summary = newValue.toString();
-                int index = mDisplayMode.findIndexOfValue(summary);
-                mDisplayMode.setSummary(mDisplayMode.getEntries()[index]);
-                mDisplayMode.setValue(summary);
-                return false;
-            }
-        });
- 
-        mSyncMode = (ListPreference) findPreference(PREFERENCE_SYNC_MODE);
-        mSyncMode.setValue(mAccount.getFolderSyncMode().name());
-        mSyncMode.setSummary(mSyncMode.getEntry());
-        mSyncMode.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
-            public boolean onPreferenceChange(Preference preference, Object newValue) {
-                final String summary = newValue.toString();
-                int index = mSyncMode.findIndexOfValue(summary);
-                mSyncMode.setSummary(mSyncMode.getEntries()[index]);
-                mSyncMode.setValue(summary);
-                return false;
-            }
-        });
-        
-        mTargetMode = (ListPreference) findPreference(PREFERENCE_TARGET_MODE);
-        mTargetMode.setValue(mAccount.getFolderTargetMode().name());
-        mTargetMode.setSummary(mTargetMode.getEntry());
-        mTargetMode.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
-            public boolean onPreferenceChange(Preference preference, Object newValue) {
-                final String summary = newValue.toString();
-                int index = mTargetMode.findIndexOfValue(summary);
-                mTargetMode.setSummary(mTargetMode.getEntries()[index]);
-                mTargetMode.setValue(summary);
-                return false;
-            }
-        });
-        
-        mDeletePolicy = (ListPreference) findPreference(PREFERENCE_DELETE_POLICY);
-        mDeletePolicy.setValue("" + mAccount.getDeletePolicy());
-        mDeletePolicy.setSummary(mDeletePolicy.getEntry());
-        mDeletePolicy.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
-            public boolean onPreferenceChange(Preference preference, Object newValue) {
-                final String summary = newValue.toString();
-                int index = mDeletePolicy.findIndexOfValue(summary);
-                mDeletePolicy.setSummary(mDeletePolicy.getEntries()[index]);
-                mDeletePolicy.setValue(summary);
-                return false;
-            }
-        });
-
-        mDisplayCount = (ListPreference) findPreference(PREFERENCE_DISPLAY_COUNT);
-        mDisplayCount.setValue(String.valueOf(mAccount.getDisplayCount()));
-        mDisplayCount.setSummary(mDisplayCount.getEntry());
-        mDisplayCount.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
-            public boolean onPreferenceChange(Preference preference, Object newValue) {
-                final String summary = newValue.toString();
-                int index = mDisplayCount.findIndexOfValue(summary);
-                mDisplayCount.setSummary(mDisplayCount.getEntries()[index]);
-                mDisplayCount.setValue(summary);
-                return false;
-            }
-        });
-        
-        mAccountDefault = (CheckBoxPreference) findPreference(PREFERENCE_DEFAULT);
-        mAccountDefault.setChecked(
-                mAccount.equals(Preferences.getPreferences(this).getDefaultAccount()));
-
-        mAccountHideButtons = (ListPreference) findPreference(PREFERENCE_HIDE_BUTTONS);
-        mAccountHideButtons.setValue("" + mAccount.getHideMessageViewButtons());
-        mAccountHideButtons.setSummary(mAccountHideButtons.getEntry());
-        mAccountHideButtons.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
-            public boolean onPreferenceChange(Preference preference, Object newValue) {
-                final String summary = newValue.toString();
-                int index = mAccountHideButtons.findIndexOfValue(summary);
-                mAccountHideButtons.setSummary(mAccountHideButtons.getEntries()[index]);
-                mAccountHideButtons.setValue(summary);
-                return false;
-            }
-        });
-           
-        mAccountNotify = (CheckBoxPreference) findPreference(PREFERENCE_NOTIFY);
-        mAccountNotify.setChecked(mAccount.isNotifyNewMail());
-
-        mAccountNotifySync = (CheckBoxPreference) findPreference(PREFERENCE_NOTIFY_SYNC);
-        mAccountNotifySync.setChecked(mAccount.isShowOngoing());
-
-        mAccountRingtone = (RingtonePreference) findPreference(PREFERENCE_RINGTONE);
-
-        // XXX: The following two lines act as a workaround for the RingtonePreference
-        //      which does not let us set/get the value programmatically
-        SharedPreferences prefs = mAccountRingtone.getPreferenceManager().getSharedPreferences();
-        prefs.edit().putString(PREFERENCE_RINGTONE, mAccount.getRingtone()).commit();
-
-        mAccountVibrate = (CheckBoxPreference) findPreference(PREFERENCE_VIBRATE);
-        mAccountVibrate.setChecked(mAccount.isVibrate());
-
-        mAutoExpandFolder = (Preference)findPreference(PREFERENCE_AUTO_EXPAND_FOLDER);
-
-        mAutoExpandFolder.setSummary(translateFolder(mAccount.getAutoExpandFolderName()));
-        
-        mAutoExpandFolder.setOnPreferenceClickListener(
-            new Preference.OnPreferenceClickListener() {
-              public boolean onPreferenceClick(Preference preference) {
-                onChooseAutoExpandFolder();
-                  return false;
-              }
-          });
-        
-        findPreference(PREFERENCE_COMPOSITION).setOnPreferenceClickListener(
-                new Preference.OnPreferenceClickListener() {
-                    public boolean onPreferenceClick(Preference preference) {
-                        onCompositionSettings();
-                        return true;
-                    }
-                });
-
-        findPreference(PREFERENCE_MANAGE_IDENTITIES).setOnPreferenceClickListener(
-            new Preference.OnPreferenceClickListener() {
-                public boolean onPreferenceClick(Preference preference) {
-                    onManageIdentities();
-                    return true;
-                }
-            });
-
-        findPreference(PREFERENCE_INCOMING).setOnPreferenceClickListener(
-                new Preference.OnPreferenceClickListener() {
-                    public boolean onPreferenceClick(Preference preference) {
-                        onIncomingSettings();
-                        return true;
-                    }
-                });
-
-        findPreference(PREFERENCE_OUTGOING).setOnPreferenceClickListener(
-                new Preference.OnPreferenceClickListener() {
-                    public boolean onPreferenceClick(Preference preference) {
-                        onOutgoingSettings();
-                        return true;
-                    }
-                });
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        mAccount.refresh(Preferences.getPreferences(this));
-    }
-
-    private void saveSettings() {
-        if (mAccountDefault.isChecked()) {
-            Preferences.getPreferences(this).setDefaultAccount(mAccount);
-        }
-        mAccount.setDescription(mAccountDescription.getText());
-        mAccount.setNotifyNewMail(mAccountNotify.isChecked());
-        mAccount.setShowOngoing(mAccountNotifySync.isChecked());
-        mAccount.setAutomaticCheckIntervalMinutes(Integer.parseInt(mCheckFrequency.getValue()));
-        mAccount.setDisplayCount(Integer.parseInt(mDisplayCount.getValue()));
-        mAccount.setVibrate(mAccountVibrate.isChecked());
-        mAccount.setFolderDisplayMode(Account.FolderMode.valueOf(mDisplayMode.getValue()));
-        mAccount.setFolderSyncMode(Account.FolderMode.valueOf(mSyncMode.getValue()));
-        mAccount.setFolderTargetMode(Account.FolderMode.valueOf(mTargetMode.getValue()));
-        mAccount.setDeletePolicy(Integer.parseInt(mDeletePolicy.getValue()));
-        SharedPreferences prefs = mAccountRingtone.getPreferenceManager().getSharedPreferences();
-        mAccount.setRingtone(prefs.getString(PREFERENCE_RINGTONE, null));
-        mAccount.setHideMessageViewButtons(Account.HideButtons.valueOf(mAccountHideButtons.getValue()));
-        mAccount.setAutoExpandFolderName(reverseTranslateFolder(mAutoExpandFolder.getSummary().toString()));
-        mAccount.save(Preferences.getPreferences(this));
-        Email.setServicesEnabled(this);
-        // TODO: refresh folder list here
-    }
-    
-    @Override
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        if (resultCode == RESULT_OK) {
-          switch (requestCode) {
-          case SELECT_AUTO_EXPAND_FOLDER:
-            mAutoExpandFolder.setSummary(translateFolder(data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER)));
-            break;
-          }
-        }
-        super.onActivityResult(requestCode, resultCode, data);
-    }
-
-    @Override
-    public boolean onKeyDown(int keyCode, KeyEvent event) {
-        if (keyCode == KeyEvent.KEYCODE_BACK) {
-            saveSettings();
-        }
-        return super.onKeyDown(keyCode, event);
-    }
-
-    private void onCompositionSettings() {
-        AccountSetupComposition.actionEditCompositionSettings(this, mAccount);
-    }
-
-    private void onManageIdentities() {
-      Intent intent = new Intent(this, ManageIdentities.class);
-      intent.putExtra(ChooseIdentity.EXTRA_ACCOUNT, mAccount);
-      startActivityForResult(intent, ACTIVITY_MANAGE_IDENTITIES);
-  }
-
-    private void onIncomingSettings() {
-        AccountSetupIncoming.actionEditIncomingSettings(this, mAccount);
-    }
-
-    private void onOutgoingSettings() {
-        AccountSetupOutgoing.actionEditOutgoingSettings(this, mAccount);
-    }
-
-    public void onChooseAutoExpandFolder()
-    {
-        Intent selectIntent = new Intent(this, ChooseFolder.class);
-        selectIntent.putExtra(ChooseFolder.EXTRA_ACCOUNT, mAccount);
-
-        selectIntent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, mAutoExpandFolder.getSummary());
-        selectIntent.putExtra(ChooseFolder.EXTRA_SHOW_CURRENT, "yes");
-        selectIntent.putExtra(ChooseFolder.EXTRA_SHOW_FOLDER_NONE, "yes");
-        selectIntent.putExtra(ChooseFolder.EXTRA_SHOW_DISPLAYABLE_ONLY, "yes");
-          startActivityForResult(selectIntent, SELECT_AUTO_EXPAND_FOLDER);
-            
-    }
-    
-    private String translateFolder(String in)
-    {
-
-      if (Email.INBOX.equalsIgnoreCase(in))
-      {
-         return getString(R.string.special_mailbox_name_inbox);
-      }
-      else
-      {
-        return in;
-      }
-    }
-    
-    private String reverseTranslateFolder(String in)
-    {
-
-      if (getString(R.string.special_mailbox_name_inbox).equals(in))
-      {
-         return Email.INBOX;
-      }
-      else
-      {
-        return in;
-      }
-    }
-
-}
Index: src/com/android/email/activity/FolderList.java
===================================================================
--- src/com/android/email/activity/FolderList.java	(revision 718)
+++ src/com/android/email/activity/FolderList.java	(working copy)
@@ -1,1186 +0,0 @@
-package com.android.email.activity;
-
-import java.text.DateFormat;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Date;
-
-import com.android.email.K9ListActivity;
-import android.app.NotificationManager;
-import android.content.Context;
-import android.content.Intent;
-import android.net.Uri;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Process;
-import android.util.Config;
-import android.util.Log;
-import android.view.ContextMenu;
-import android.view.KeyEvent;
-import android.view.LayoutInflater;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.Window;
-import android.widget.AdapterView.AdapterContextMenuInfo;
-import android.widget.AdapterView.OnItemClickListener;
-import android.view.ContextMenu.ContextMenuInfo;
-import android.widget.BaseAdapter;
-import android.widget.AdapterView;
-import android.widget.ListView;
-import android.widget.TextView;
-import android.widget.Toast;
-
-import com.android.email.Account;
-import com.android.email.Email;
-import com.android.email.MessagingController;
-import com.android.email.MessagingListener;
-import com.android.email.Preferences;
-import com.android.email.R;
-import com.android.email.MessagingController.SORT_TYPE;
-import com.android.email.activity.FolderList.FolderInfoHolder;
-import com.android.email.activity.MessageList.MessageInfoHolder;
-import com.android.email.activity.setup.AccountSettings;
-import com.android.email.activity.setup.FolderSettings;
-import com.android.email.mail.Folder;
-import com.android.email.mail.Message;
-import com.android.email.mail.MessagingException;
-import com.android.email.mail.Store;
-import com.android.email.mail.store.LocalStore.LocalFolder;
-
-import android.os.PowerManager;
-import android.os.PowerManager.WakeLock;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-
-/**
- * FolderList is the primary user interface for the program. This
- * Activity shows list of the Account's folders 
- */
-
-public class FolderList extends K9ListActivity {
-
-    private static final String INTENT_DATA_PATH_SUFFIX = "/accounts";
-
-    private static final int DIALOG_MARK_ALL_AS_READ = 1;
-
-    private static final String EXTRA_ACCOUNT = "account";
-
-    private static final String EXTRA_INITIAL_FOLDER = "initialFolder";
-
-    private static final String EXTRA_CLEAR_NOTIFICATION = "clearNotification";
-
-    private static final String EXTRA_STARTUP = "startup";
-
-    private static final boolean REFRESH_REMOTE = true;
-
-    private ListView mListView;
-
-    private FolderListAdapter mAdapter;
-
-    private LayoutInflater mInflater;
-
-    private Account mAccount;
-
-    private String mInitialFolder;
-
-    private boolean mRestoringState;
-
-    private boolean mRefreshRemote;
-
-    private FolderListHandler mHandler = new FolderListHandler();
-
-    private DateFormat dateFormat = null;
-
-    private DateFormat timeFormat = null;
-
-    private SORT_TYPE sortType = SORT_TYPE.SORT_DATE;
-
-    private boolean sortAscending = true;
-
-    private boolean sortDateAscending = false;
-
-    private boolean mStartup = false;
-
-    private static final ThreadPoolExecutor threadPool = new ThreadPoolExecutor(1, 1, 120000L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());
-
-    private DateFormat getDateFormat() {
-        if (dateFormat == null) {
-            String dateFormatS = android.provider.Settings.System.getString(getContentResolver(),
-                                 android.provider.Settings.System.DATE_FORMAT);
-
-            if (dateFormatS != null) {
-                dateFormat = new java.text.SimpleDateFormat(dateFormatS);
-            } else {
-                dateFormat = new java.text.SimpleDateFormat(Email.BACKUP_DATE_FORMAT);
-            }
-        }
-
-        return dateFormat;
-    }
-
-    private DateFormat getTimeFormat() {
-
-        if (timeFormat == null) {
-            String timeFormatS = android.provider.Settings.System.getString(getContentResolver(),
-                                 android.provider.Settings.System.TIME_12_24);
-            boolean b24 =  !(timeFormatS == null || timeFormatS.equals("12"));
-            timeFormat = new java.text.SimpleDateFormat(b24 ? Email.TIME_FORMAT_24 : Email.TIME_FORMAT_12);
-        }
-
-        return timeFormat;
-    }
-
-    private void clearFormats() {
-        dateFormat = null;
-        timeFormat = null;
-    }
-
-    class FolderListHandler extends Handler {
-
-        private static final int MSG_PROGRESS = 2;
-        private static final int MSG_DATA_CHANGED = 3;
-        private static final int MSG_EXPAND_GROUP = 5;
-        private static final int MSG_FOLDER_LOADING = 7;
-        private static final int MSG_SYNC_MESSAGES = 13;
-        private static final int MSG_FOLDER_SYNCING = 18;
-        private static final int MSG_SENDING_OUTBOX = 19;
-        private static final int MSG_ACCOUNT_SIZE_CHANGED = 20;
-        private static final int MSG_WORKING_ACCOUNT = 21;
-
-        @Override
-        public void handleMessage(android.os.Message msg) {
-            switch (msg.what) {
-                case MSG_PROGRESS:
-                    setProgressBarIndeterminateVisibility(msg.arg1 != 0);
-                    break;
-                case MSG_DATA_CHANGED:
-                     mAdapter.notifyDataSetChanged();
-                     break;
-                case MSG_FOLDER_LOADING: {
-                    FolderInfoHolder folder = mAdapter.getFolder((String) msg.obj);
-    
-                    if (folder != null) {
-                        folder.loading = msg.arg1 != 0;
-                    }
-    
-                    break;
-                }
-    
-                case MSG_ACCOUNT_SIZE_CHANGED: {
-                    Long[] sizes = (Long[])msg.obj;
-                    String toastText = getString(R.string.account_size_changed, mAccount.getDescription(), SizeFormatter.formatSize(getApplication(), sizes[0]), SizeFormatter.formatSize(getApplication(), sizes[1]));
-                    
-                    Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_LONG);
-                    toast.show();
-                    break;
-                }
-    
-                case MSG_WORKING_ACCOUNT: {
-                    int res = msg.arg1;
-                    String toastText = getString(res, mAccount.getDescription());
-    
-                    Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_SHORT);
-                    toast.show();
-                    break;
-                }
-    
-    
-                case MSG_FOLDER_SYNCING: {
-                    String folderName = (String)((Object[]) msg.obj)[0];
-                    String dispString;
-                    dispString = mAccount.getDescription();
-    
-                    if (folderName != null) {
-                        dispString += " (" + getString(R.string.status_loading) + folderName + ")";
-                    }
-    
-                    setTitle(dispString);
-    
-                    break;
-                }
-    
-                case MSG_SENDING_OUTBOX: {
-                    boolean sending = (msg.arg1 != 0);
-                    String dispString;
-                    dispString = mAccount.getDescription();
-    
-                    if (sending) {
-                        dispString += " (" + getString(R.string.status_sending) + ")";
-                    }
-    
-                    setTitle(dispString);
-    
-                    break;
-                }
-    
-                default:
-                    super.handleMessage(msg);
-            }
-        }
-
-        public void synchronizeMessages(FolderInfoHolder folder, Message[] messages) {
-            android.os.Message msg = new android.os.Message();
-            msg.what = MSG_SYNC_MESSAGES;
-            msg.obj = new Object[] { folder, messages };
-            sendMessage(msg);
-        }
-
-        public void workingAccount(int res) {
-            android.os.Message msg = new android.os.Message();
-            msg.what = MSG_WORKING_ACCOUNT;
-            msg.arg1 = res;
-            sendMessage(msg);
-        }
-
-        public void accountSizeChanged(long oldSize, long newSize) {
-            android.os.Message msg = new android.os.Message();
-            msg.what = MSG_ACCOUNT_SIZE_CHANGED;
-            msg.obj = new Long[] { oldSize, newSize };
-            sendMessage(msg);
-        }
-
-        public void folderLoading(String folder, boolean loading) {
-            android.os.Message msg = new android.os.Message();
-            msg.what = MSG_FOLDER_LOADING;
-            msg.arg1 = loading ? 1 : 0;
-            msg.obj = folder;
-            sendMessage(msg);
-        }
-
-        public void progress(boolean progress) {
-            android.os.Message msg = new android.os.Message();
-            msg.what = MSG_PROGRESS;
-            msg.arg1 = progress ? 1 : 0;
-            sendMessage(msg);
-        }
-
-        public void dataChanged() {
-            sendEmptyMessage(MSG_DATA_CHANGED);
-        }
-
-        public void folderSyncing(String folder) {
-            android.os.Message msg = new android.os.Message();
-            msg.what = MSG_FOLDER_SYNCING;
-            msg.obj = new String[] { folder };
-            sendMessage(msg);
-        }
-
-        public void sendingOutbox(boolean sending) {
-            android.os.Message msg = new android.os.Message();
-            msg.what = MSG_SENDING_OUTBOX;
-            msg.arg1 = sending ? 1 : 0;
-            sendMessage(msg);
-        }
-    }
-
-    /**
-    * This class is responsible for reloading the list of local messages for a
-    * given folder, notifying the adapter that the message have been loaded and
-    * queueing up a remote update of the folder.
-     */
-
-    class FolderUpdateWorker implements Runnable {
-        String mFolder;
-        FolderInfoHolder mHolder;
-        boolean mSynchronizeRemote;
-
-        /**
-        * Create a worker for the given folder and specifying whether the worker
-        * should synchronize the remote folder or just the local one.
-        * 
-         * @param folder
-         * @param synchronizeRemote
-         */
-        public FolderUpdateWorker(FolderInfoHolder folder, boolean synchronizeRemote) {
-            mFolder = folder.name;
-            mHolder = folder;
-            mSynchronizeRemote = synchronizeRemote;
-        }
-
-        public void run() {
-            // Lower our priority
-            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
-            PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
-            WakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "Email - UpdateWorker");
-            wakeLock.setReferenceCounted(false);
-            wakeLock.acquire(Email.WAKE_LOCK_TIMEOUT);
-            // Synchronously load the list of local messages
-
-            try {
-                try {
-                    Store localStore = Store.getInstance(mAccount.getLocalStoreUri(), getApplication());
-                    LocalFolder localFolder = (LocalFolder) localStore.getFolder(mFolder);
-
-                    if (localFolder.getMessageCount() == 0 && localFolder.getLastChecked() <= 0) {
-                        mSynchronizeRemote = true;
-                    }
-                } catch (MessagingException me) {
-                    Log.e(Email.LOG_TAG, "Unable to get count of local messages for folder " + mFolder, me);
-                }
-
-                if (mSynchronizeRemote) {
-                    // Tell the MessagingController to run a remote update of this folder
-                    // at it's leisure
-                    MessagingController.getInstance(getApplication()).synchronizeMailbox(mAccount, mFolder, mAdapter.mListener);
-                }
-            } finally {
-                wakeLock.release();
-            }
-
-        }
-    }
-
-    private static void actionHandleAccount(Context context, Account account, String initialFolder, boolean startup) {
-        Intent intent = new Intent(context, FolderList.class);
-        intent.putExtra(EXTRA_ACCOUNT, account);
-        intent.putExtra(EXTRA_STARTUP, startup);
-
-        if (initialFolder != null) {
-            intent.putExtra(EXTRA_INITIAL_FOLDER, initialFolder);
-        }
-
-        context.startActivity(intent);
-    }
-
-    public static void actionHandleAccount(Context context, Account account, String initialFolder) {
-        actionHandleAccount(context, account, initialFolder, false);
-    }
-
-    public static void actionHandleAccount(Context context, Account account, boolean startup) {
-        actionHandleAccount(context, account, null, startup);
-    }
-
-    public static Intent actionHandleAccountIntent(Context context, Account account, String initialFolder) {
-        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(Email.INTENT_DATA_URI_PREFIX + INTENT_DATA_PATH_SUFFIX + "/" + account.getAccountNumber()), context, FolderList.class);
-        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        intent.putExtra(EXTRA_ACCOUNT, account);
-        intent.putExtra(EXTRA_CLEAR_NOTIFICATION, true);
-
-        if (initialFolder != null) {
-            intent.putExtra(EXTRA_INITIAL_FOLDER, initialFolder);
-        }
-        else {
-            intent.putExtra(EXTRA_STARTUP, true);
-        }
-        return intent;
-    }
-
-    public static Intent actionHandleAccountIntent(Context context, Account account) {
-        return actionHandleAccountIntent(context, account, null);
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        Intent intent = getIntent();
-        mAccount = (Account)intent.getSerializableExtra(EXTRA_ACCOUNT);
-        Log.v(Email.LOG_TAG, "savedInstanceState: " + (savedInstanceState==null));
-        if (savedInstanceState == null) {
-            mInitialFolder = intent.getStringExtra(EXTRA_INITIAL_FOLDER);
-            Log.v(Email.LOG_TAG, "EXTRA_INITIAL_FOLDER: " + mInitialFolder);
-            mStartup = (boolean) intent.getBooleanExtra(EXTRA_STARTUP, false);
-            Log.v(Email.LOG_TAG, "startup: " + mStartup);
-            if (mInitialFolder == null
-                && mStartup) {
-                mInitialFolder = mAccount.getAutoExpandFolderName();
-                if (Email.FOLDER_NONE.equals(mInitialFolder)) {
-                    mInitialFolder = null;
-                }
-            }
-        }
-        else {
-            mInitialFolder = null;
-        }
-
-        Log.v(Email.LOG_TAG, "mInitialFolder: " + mInitialFolder);
-        if (mInitialFolder != null) {
-            onOpenFolder(mInitialFolder, true);
-            finish();
-        }
-        else {
-            requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
-
-            final FolderList xxx = this;
-
-            mListView = getListView();
-            mListView.setScrollBarStyle(View.SCROLLBARS_OUTSIDE_INSET);
-            mListView.setLongClickable(true);
-            //mListView.setFastScrollEnabled(true); // XXX TODO - reenable when we switch to 1.5
-            mListView.setScrollingCacheEnabled(true);
-            mListView.setOnItemClickListener(new OnItemClickListener() {
-                public void onItemClick(AdapterView parent, View v, int itemPosition, long id) {
-                    Log.v(Email.LOG_TAG,"We're clicking "+itemPosition+" -- "+id);
-                    MessageList.actionHandleFolder(xxx, mAccount, ((FolderInfoHolder)mAdapter.getItem(id)).name, false);
-                }
-            });
-            registerForContextMenu(mListView);
-
-            /*
-            * We manually save and restore the list's state because our adapter is
-            * slow.
-             */
-            mListView.setSaveEnabled(false);
-
-            mInflater = getLayoutInflater();
-
-            mAdapter = new FolderListAdapter();
-
-            final Object previousData = getLastNonConfigurationInstance();
-
-            if (previousData != null) {
-                //noinspection unchecked
-                mAdapter.mFolders = (ArrayList<FolderInfoHolder>) previousData;
-            }
-
-            setListAdapter(mAdapter);
-
-            if (savedInstanceState != null) {
-                mRestoringState = true;
-                //onRestoreListState(savedInstanceState);
-                mRestoringState = false;
-            }
-
-            setTitle(mAccount.getDescription());
-        }
-    }
-
-    @Override public Object onRetainNonConfigurationInstance() {
-        return mAdapter.mFolders;
-    }
-
-    @Override public void onPause() {
-        super.onPause();
-        MessagingController.getInstance(getApplication()).removeListener(mAdapter.mListener);
-    }
-
-    /**
-    * On resume we refresh the folder list (in the background) and we refresh the
-    * messages for any folder that is currently open. This guarantees that things
-    * like unread message count and read status are updated.
-     */
-    @Override public void onResume() {
-        super.onResume();
-        clearFormats();
-
-        MessagingController.getInstance(getApplication()).addListener(mAdapter.mListener);
-        mAccount.refresh(Preferences.getPreferences(this));
-        markAllRefresh();
-
-        onRefresh( !REFRESH_REMOTE );
-
-        NotificationManager notifMgr = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
-        notifMgr.cancel(mAccount.getAccountNumber());
-        notifMgr.cancel(-1000 - mAccount.getAccountNumber());
-
-    }
-
-    @Override public boolean onKeyDown(int keyCode, KeyEvent event) {
-        //Shortcuts that work no matter what is selected
-
-        switch (keyCode) {
-        case KeyEvent.KEYCODE_Q: {
-            onAccounts();
-            return true;
-        }
-
-        case KeyEvent.KEYCODE_S: {
-            onEditAccount();
-            return true;
-        }
-
-        case KeyEvent.KEYCODE_H: {
-            Toast toast = Toast.makeText(this, R.string.message_list_help_key, Toast.LENGTH_LONG);
-            toast.show();
-            return true;
-        }
-        }//switch
-
-
-        return super.onKeyDown(keyCode, event);
-    }//onKeyDown
-
-    private void onRefresh(final boolean forceRemote) {
-        if (forceRemote) {
-            mRefreshRemote = true;
-        }
-
-        new Thread() {
-
-            public void run() {
-                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
-                MessagingController.getInstance(getApplication()).listFolders(mAccount, forceRemote, mAdapter.mListener);
-
-                if (forceRemote) {
-                    MessagingController.getInstance(getApplication()).sendPendingMessages(mAccount, null);
-                }
-            }
-        }
-        .start();
-    }
-
-    private void onEditAccount() {
-        AccountSettings.actionSettings(this, mAccount);
-    }
-
-    private void onEditFolder(Account account, String folderName) {
-        FolderSettings.actionSettings(this, account, folderName);
-    }
-
-    private void onAccounts() {
-        // If we're a child activity (say because Welcome dropped us straight to the message list
-        // we won't have a parent activity and we'll need to get back to it
-        if (mStartup
-            || isTaskRoot()) {
-            startActivity(new Intent(this, Accounts.class));
-        }
-        finish();
-    }
-
-    private void markAllRefresh() {
-        mAdapter.mListener.accountReset(mAccount);
-    }
-
-    private void onEmptyTrash(final Account account) {
-        mHandler.dataChanged();
-
-        MessagingListener listener = new MessagingListener() {
-                                         @Override
-                                         public void controllerCommandCompleted(boolean moreToDo) {
-                                             Log.v(Email.LOG_TAG, "Empty Trash background task completed");
-                                         }
-                                     };
-
-        MessagingController.getInstance(getApplication()).emptyTrash(account, listener);
-    }
-
-    private void checkMail(final Account account) {
-        MessagingController.getInstance(getApplication()).checkMail(this, account, true, true, mAdapter.mListener);
-    }
-
-    private void checkMail(Account account, String folderName) {
-        MessagingController.getInstance(getApplication()).synchronizeMailbox(account, folderName, mAdapter.mListener);
-    }
-
-    @Override public boolean onOptionsItemSelected(MenuItem item) {
-        switch (item.getItemId()) {
-        case R.id.compose:
-            MessageCompose.actionCompose(this, mAccount);
-
-            return true;
-
-        case R.id.check_mail:
-            checkMail(mAccount);
-
-            return true;
-
-        case R.id.accounts:
-            onAccounts();
-
-            return true;
-
-        case R.id.list_folders:
-            onRefresh( REFRESH_REMOTE );
-
-            return true;
-
-        case R.id.account_settings:
-            onEditAccount();
-
-            return true;
-
-        case R.id.empty_trash:
-            onEmptyTrash(mAccount);
-
-            return true;
-
-        case R.id.compact:
-            onCompact(mAccount);
-
-            return true;
-
-        case R.id.clear:
-            onClear(mAccount);
-
-            return true;
-
-        default:
-            return super.onOptionsItemSelected(item);
-        }
-    }
-
-    private void onOpenFolder(String folder, boolean startup) {
-        MessageList.actionHandleFolder(this, mAccount, folder, startup);
-    }
-
-    private void onCompact(Account account) {
-        mHandler.workingAccount(R.string.compacting_account);
-        MessagingController.getInstance(getApplication()).compact(account, null);
-    }
-
-    private void onClear(Account account) {
-        mHandler.workingAccount(R.string.clearing_account);
-        MessagingController.getInstance(getApplication()).clear(account, null);
-    }
-
-    @Override public boolean onCreateOptionsMenu(Menu menu) {
-        super.onCreateOptionsMenu(menu);
-        getMenuInflater().inflate(R.menu.folder_list_option, menu);
-        return true;
-    }
-
-    @Override public boolean onContextItemSelected(MenuItem item) {
-        AdapterContextMenuInfo info = (AdapterContextMenuInfo) item .getMenuInfo();
-        FolderInfoHolder folder = (FolderInfoHolder) mAdapter.getItem(info.position);
-
-        switch (item.getItemId()) {
-        case R.id.open_folder:
-            onOpenFolder(folder.name, false);
-            break;
-        
-        case R.id.mark_all_as_read:
-            MessagingController.getInstance(getApplication()).markAllMessagesRead(mAccount, folder.name);
-            break;
-            
-        case R.id.send_messages:
-            Log.i(Email.LOG_TAG, "sending pending messages from " + folder.name);
-
-            MessagingController.getInstance(getApplication()).sendPendingMessages(mAccount, null);
-
-            break;
-
-        case R.id.check_mail:
-            Log.i(Email.LOG_TAG, "refresh folder " + folder.name);
-
-            threadPool.execute(new FolderUpdateWorker(folder, true));
-
-            break;
-
-        case R.id.folder_settings:
-            Log.i(Email.LOG_TAG, "edit folder settings for " + folder.name);
-
-            onEditFolder(mAccount, folder.name);
-
-            break;
-
-        case R.id.empty_trash:
-            Log.i(Email.LOG_TAG, "empty trash");
-
-            onEmptyTrash(mAccount);
-
-            break;
-        }
-
-        return super.onContextItemSelected(item);
-    }
-
-    @Override public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
-        super.onCreateContextMenu(menu, v, menuInfo);
-        AdapterContextMenuInfo info = (AdapterContextMenuInfo) menuInfo;
-        getMenuInflater().inflate(R.menu.folder_context, menu);
-        
-        FolderInfoHolder folder = (FolderInfoHolder) mAdapter.getItem(info.position);
-        
-        menu.setHeaderTitle((CharSequence) folder.displayName);
-
-        if (!folder.name.equals(mAccount.getTrashFolderName()))
-            menu.findItem(R.id.empty_trash).setVisible(false);
-
-        if (folder.outbox) {
-            menu.findItem(R.id.check_mail).setVisible(false);
-        } else {
-            menu.findItem(R.id.send_messages).setVisible(false);
-        }
-
-        menu.setHeaderTitle(folder.displayName);
-    }
-
-    private String truncateStatus(String mess) {
-        if (mess != null && mess.length() > 27) {
-            mess = mess.substring(0, 27);
-        }
-
-        return mess;
-    }
-
-    class FolderListAdapter extends BaseAdapter {
-        private ArrayList<FolderInfoHolder> mFolders = new ArrayList<FolderInfoHolder>();
-        
-        public Object getItem(long position) {
-            return getItem((int)position);
-        }
-
-        public Object getItem(int position) {
-            return mFolders.get(position);
-        }
-
-
-        public long getItemId(int position) {
-            return position ;
-        }
- 
-        public int getCount() {
-            return mFolders.size();
-        }
-
-        public boolean isEnabled(int item) {
-            return true;
-        }
-
-        public boolean areAllItemsEnabled() {
-            return true;
-        }
-
-       private MessagingListener mListener = new MessagingListener() {
-
-              @Override
-              public void listFoldersStarted(Account account) {
-                  if (!account.equals(mAccount)) {
-                      return;
-                  }
-    
-                  mHandler.progress(true);
-              }
-    
-              @Override
-              public void listFoldersFailed(Account account, String message) {
-                  if (!account.equals(mAccount)) {
-                      return;
-                  }
-    
-                  mHandler.progress(false);
-    
-                  if (Config.LOGV) {
-                      Log.v(Email.LOG_TAG, "listFoldersFailed " + message);
-                  }
-              }
-    
-              @Override
-              public void listFoldersFinished(Account account) {
-                  if (!account.equals(mAccount)) {
-                      return;
-                  }
-    
-                  mHandler.progress(false);
-    
-                  mHandler.dataChanged();
-    
-              }
-    
-              @Override
-              public void listFolders(Account account, Folder[] folders) {
-                  if (!account.equals(mAccount)) {
-                      return;
-                  }
-    
-                  ArrayList<FolderInfoHolder> newFolders = new ArrayList<FolderInfoHolder>();
-    
-                  Account.FolderMode aMode = account.getFolderDisplayMode();
-    
-                  for (Folder folder : folders) {
-                      try {
-                          folder.refresh( Preferences.getPreferences(getApplication().getApplicationContext()) );
-
-                          Folder.FolderClass fMode = folder.getDisplayClass();
-    
-                          if ((aMode == Account.FolderMode.FIRST_CLASS && fMode != Folder.FolderClass.FIRST_CLASS)
-                                  || (aMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
-                                      fMode != Folder.FolderClass.FIRST_CLASS &&
-                                      fMode != Folder.FolderClass.SECOND_CLASS)
-                                  || (aMode == Account.FolderMode.NOT_SECOND_CLASS && fMode == Folder.FolderClass.SECOND_CLASS)) {
-                              continue;
-                          }
-                      } catch (MessagingException me) {
-                          Log.e(Email.LOG_TAG, "Couldn't get prefs to check for displayability of folder " + folder.getName(), me);
-                      }
-
-                      FolderInfoHolder holder = null;
-
-                      int folderIndex = getFolderIndex(folder.getName());
-                      if (folderIndex >= 0 ) {
-                        holder = (FolderInfoHolder) getItem(folderIndex);
-                      }
-
-                      if (holder == null) {
-                          holder = new FolderInfoHolder(folder);
-                      } else {
-                        holder.populate(folder);
-
-                      }
-    
-                      newFolders.add(holder);
-                  } 
-                  mFolders.clear();
-    
-                  mFolders.addAll(newFolders);
-                  Collections.sort(mFolders);
-                  mHandler.dataChanged();
-                  mRefreshRemote = false;
-              }
-              
- 
-              @Override
-              public void accountReset(Account account) {
-                  if (!account.equals(mAccount)) {
-                      return;
-                  }
-    
-                  for (FolderInfoHolder folder : mFolders) {
-                      folder.needsRefresh = true;
-                  }
-              }
-    
-              public void synchronizeMailboxStarted(Account account, String folder) {
-                  if (!account.equals(mAccount)) {
-                      return;
-                  }
-    
-                  mHandler.progress(true);
-                  mHandler.folderLoading(folder, true);
-                  mHandler.folderSyncing(folder);
-              }
-    
-              @Override
-              public void synchronizeMailboxFinished(Account account, String folder, int totalMessagesInMailbox, int numNewMessages) {
-                  if (!account.equals(mAccount)) {
-                      return;
-                  }
-    
-                  // There has to be a cheaper way to get at the localFolder object than this
-                  try { 
-                      Folder localFolder = (Folder) Store.getInstance(account.getLocalStoreUri(), getApplication()).getFolder(folder);
-                      getFolder(folder).populate(localFolder);
-                  } 
-                  catch (MessagingException e) {
-
-                  }
-
-
-                  mHandler.progress(false);
-                  mHandler.folderLoading(folder, false);
-                  // mHandler.folderStatus(folder, null);
-                  mHandler.folderSyncing(null);
-    
-                  onRefresh( ! REFRESH_REMOTE );
-              }
-    
-              @Override
-              public void synchronizeMailboxFailed(Account account, String folder,
-                                                   String message) {
-                  if (!account.equals(mAccount)) {
-                      return;
-                  }
-    
-    
-                  mHandler.progress(false);
-    
-                  mHandler.folderLoading(folder, false);
-    
-                  //   String mess = truncateStatus(message);
-    
-                  //   mHandler.folderStatus(folder, mess);
-                  FolderInfoHolder holder = getFolder(folder);
-    
-                  if (holder != null) {
-                      holder.lastChecked = 0;
-                  }
-    
-                  mHandler.folderSyncing(null);
-              }
-    
-    
-              @Override
-              public void messageDeleted(Account account,
-                                         String folder, Message message) {
-                  synchronizeMailboxRemovedMessage(account,
-                                                   folder, message);
-              }
-    
-              @Override
-              public void emptyTrashCompleted(Account account) {
-                  if (!account.equals(mAccount)) {
-                      return;
-                  }
-    
-                  onRefresh( ! REFRESH_REMOTE);
-              }
-    
-              @Override
-              public void folderStatusChanged(Account account, String folderName) {
-                  if (!account.equals(mAccount)) {
-                      return;
-                  }
-    
-                  onRefresh( !REFRESH_REMOTE);
-              }
-    
-              @Override
-              public void sendPendingMessagesCompleted(Account account) {
-                  if (!account.equals(mAccount)) {
-                      return;
-                  }
-    
-                  mHandler.sendingOutbox(false);
-    
-                  onRefresh( !REFRESH_REMOTE);
-              }
-    
-              @Override
-              public void sendPendingMessagesStarted(Account account) {
-                  if (!account.equals(mAccount)) {
-                      return;
-                  }
-    
-                  mHandler.sendingOutbox(true);
-              }
-    
-              @Override
-              public void sendPendingMessagesFailed(Account account) {
-                  if (!account.equals(mAccount)) {
-                      return;
-                  }
-    
-                  mHandler.sendingOutbox(false);
-              }
-    
-              public void accountSizeChanged(Account account, long oldSize, long newSize) {
-                  if (!account.equals(mAccount)) {
-                      return;
-                  }
-    
-                  mHandler.accountSizeChanged(oldSize, newSize);
-    
-              }
-    
-          };
-
-
-        public int getFolderIndex(String folder) {
-            FolderInfoHolder searchHolder = new FolderInfoHolder();
-            searchHolder.name = folder;
-           return   mFolders.indexOf((Object) searchHolder);
-        }
-
-        public FolderInfoHolder getFolder(String folder) {
-            FolderInfoHolder holder = null;
-
-            int index = getFolderIndex(folder);
-            if(index >= 0 ){
-                holder = (FolderInfoHolder) getItem(index);
-                if (holder != null) {
-                    return holder;
-                }
-             }
-            return null;
-        }
-
-        public View getView(int position, View convertView, ViewGroup parent) {
-            if (position <= getCount()) {
-               return  getItemView(position, convertView, parent);
-            } else {
-                // XXX TODO - should catch an exception here
-                return null;
-            }
-        }
-
-        public View getItemView(int itemPosition, View convertView, ViewGroup parent) {
-            FolderInfoHolder folder = (FolderInfoHolder) getItem(itemPosition);
-            View view;
-            if ((convertView != null) && (convertView.getId() == R.layout.folder_list_item)) {
-                view = convertView;
-            } else {
-                view = mInflater.inflate(R.layout.folder_list_item, parent, false);
-                view.setId(R.layout.folder_list_item);
-            }
-
-
-            FolderViewHolder holder = (FolderViewHolder) view.getTag();
-
-            if (holder == null) {
-                holder = new FolderViewHolder();
-                holder.folderName = (TextView) view.findViewById(R.id.folder_name);
-                holder.newMessageCount = (TextView) view.findViewById(R.id.folder_unread_message_count);
-                holder.folderStatus = (TextView) view.findViewById(R.id.folder_status);
-                holder.rawFolderName = folder.name;
-
-                view.setTag(holder);
-            }
-
-            if (folder == null) {
-                return view;
-            }
-            
-            holder.folderName.setText(folder.displayName);
-            String statusText = "";
-
-            if (folder.loading) {
-                statusText = getString(R.string.status_loading);
-            } else if (folder.status != null) {
-                statusText = folder.status;
-            } else if (folder.lastChecked != 0) {
-                Date lastCheckedDate = new Date(folder.lastChecked);
-
-                statusText = (getDateFormat().format(lastCheckedDate) + " " + getTimeFormat()
-                              .format(lastCheckedDate));
-            }
-
-            if (statusText != null) {
-                holder.folderStatus.setText(statusText);
-                holder.folderStatus.setVisibility(View.VISIBLE);
-            } else {
-                holder.folderStatus.setText(null);
-                holder.folderStatus.setVisibility(View.GONE);
-            }
-
-            if (folder.unreadMessageCount != 0) {
-                holder.newMessageCount.setText(Integer
-                                               .toString(folder.unreadMessageCount));
-                holder.newMessageCount.setVisibility(View.VISIBLE);
-            } else {
-                holder.newMessageCount.setVisibility(View.GONE);
-            }
-
-            return view;
-        }
-
-        public boolean hasStableIds() {
-            return false;
-        }
-        
-        public boolean isItemSelectable(int position) {
-            return true;
-        }
-
-    }
-
-    public class FolderInfoHolder implements Comparable<FolderInfoHolder> {
-            public String name;
-
-            public String displayName;
-
-            public ArrayList<MessageInfoHolder> messages;
-
-            public long lastChecked;
-
-            public int unreadMessageCount;
-
-            public boolean loading;
-
-            public String status;
-
-            public boolean lastCheckFailed;
-
-            public boolean needsRefresh = false;
-
-            /**
-             * Outbox is handled differently from any other folder.
-             */
-            public boolean outbox;
-
-
-            public boolean equals(Object o) {
-                if (this.name.equals(((FolderInfoHolder)o).name)) {
-                    return true;
-                } else {
-                    return false;
-                }
-            }
-
-            public int compareTo(FolderInfoHolder o) {
-                String s1 = this.name;
-                String s2 = o.name;
-
-                if (Email.INBOX.equalsIgnoreCase(s1) && Email.INBOX.equalsIgnoreCase(s2)) {
-                   return 0;
-                } else if (Email.INBOX.equalsIgnoreCase(s1)) {
-                    return -1;
-                } else if (Email.INBOX.equalsIgnoreCase(s2)) {
-                    return 1;
-                } else {
-                    int ret = s1.compareToIgnoreCase(s2);
-                    if (ret != 0) {
-                        return ret;
-                    }
-                    else {
-                        return s1.compareTo(s2);
-                    }
-                }
-                
-            }
-          
-            // constructor for an empty object for comparisons
-             public FolderInfoHolder() {
-             }
- 
-             public FolderInfoHolder(Folder folder) {
-                    populate(folder);
-             }
-             public void populate (Folder folder) {  
-                      int unreadCount = 0;
-    
-                      try {
-                          folder.open(Folder.OpenMode.READ_WRITE);
-                          unreadCount = folder.getUnreadMessageCount();
-                      } catch (MessagingException me) {
-                          Log.e(Email.LOG_TAG, "Folder.getUnreadMessageCount() failed", me);
-                      }
-    
-                      this.name = folder.getName();
-    
-                      if (this.name.equalsIgnoreCase(Email.INBOX)) {
-                          this.displayName = getString(R.string.special_mailbox_name_inbox);
-                      } else {
-                          this.displayName = folder.getName();
-                      }
-    
-                      if (this.name.equals(mAccount.getOutboxFolderName())) {
-                          this.displayName = String.format( getString(R.string.special_mailbox_name_outbox_fmt), this.name);
-                          this.outbox = true;
-                      }
-    
-                      if (this.name.equals(mAccount.getDraftsFolderName())) {
-                          this.displayName = String.format( getString(R.string.special_mailbox_name_drafts_fmt), this.name);
-                      }
-    
-                      if (this.name.equals(mAccount.getTrashFolderName())) {
-                          this.displayName = String.format( getString(R.string.special_mailbox_name_trash_fmt), this.name);
-                      }
-    
-                      if (this.name.equals(mAccount.getSentFolderName())) {
-                          this.displayName = String.format( getString(R.string.special_mailbox_name_sent_fmt), this.name);
-                      }
-    
-                      if (this.messages == null) {
-                          this.messages = new ArrayList<MessageInfoHolder>();
-                      }
-    
-                      this.lastChecked = folder.getLastChecked();
-    
-                      String mess = truncateStatus(folder.getStatus());
-    
-                      this.status = mess;
-    
-                      this.unreadMessageCount = unreadCount;
-    
-                      try {
-                          folder.close(false);
-                      } catch (MessagingException me) {
-                          Log.e(Email.LOG_TAG, "Folder.close() failed", me);
-                      }
-                  }
-        }
-
-        class FolderViewHolder {
-            public TextView folderName;
-
-            public TextView folderStatus;
-
-            public TextView newMessageCount;
-
-            public String rawFolderName;
-        }
-
-    }
Index: src/com/android/email/provider/AttachmentProvider.java
===================================================================
--- src/com/android/email/provider/AttachmentProvider.java	(revision 718)
+++ src/com/android/email/provider/AttachmentProvider.java	(working copy)
@@ -1,288 +0,0 @@
-package com.android.email.provider;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.List;
-
-import android.content.ContentProvider;
-import android.content.ContentValues;
-import android.content.Context;
-import android.database.Cursor;
-import android.database.MatrixCursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.net.Uri;
-import android.os.ParcelFileDescriptor;
-import android.provider.OpenableColumns;
-import android.util.Config;
-import android.util.Log;
-
-import com.android.email.Account;
-import com.android.email.Email;
-import com.android.email.Utility;
-import com.android.email.mail.internet.MimeUtility;
-
-/*
- * A simple ContentProvider that allows file access to Email's attachments.
- */
-public class AttachmentProvider extends ContentProvider {
-    public static final Uri CONTENT_URI = Uri.parse( "content://com.fsck.k9.attachmentprovider");
-
-    private static final String FORMAT_RAW = "RAW";
-    private static final String FORMAT_THUMBNAIL = "THUMBNAIL";
-
-    public static class AttachmentProviderColumns {
-        public static final String _ID = "_id";
-        public static final String DATA = "_data";
-        public static final String DISPLAY_NAME = "_display_name";
-        public static final String SIZE = "_size";
-    }
-
-    public static Uri getAttachmentUri(Account account, long id) {
-        return CONTENT_URI.buildUpon()
-                .appendPath(account.getUuid() + ".db")
-                .appendPath(Long.toString(id))
-                .appendPath(FORMAT_RAW)
-                .build();
-    }
-
-    public static Uri getAttachmentThumbnailUri(Account account, long id, int width, int height) {
-        return CONTENT_URI.buildUpon()
-                .appendPath(account.getUuid() + ".db")
-                .appendPath(Long.toString(id))
-                .appendPath(FORMAT_THUMBNAIL)
-                .appendPath(Integer.toString(width))
-                .appendPath(Integer.toString(height))
-                .build();
-    }
-
-    public static Uri getAttachmentUri(String db, long id) {
-        return CONTENT_URI.buildUpon()
-                .appendPath(db)
-                .appendPath(Long.toString(id))
-                .appendPath(FORMAT_RAW)
-                .build();
-    }
-
-    @Override
-    public boolean onCreate() {
-        /*
-         * We use the cache dir as a temporary directory (since Android doesn't give us one) so
-         * on startup we'll clean up any .tmp files from the last run.
-         */
-        File[] files = getContext().getCacheDir().listFiles();
-        for (File file : files) {
-            if (file.getName().endsWith(".tmp")) {
-                file.delete();
-            }
-        }
-        return true;
-    }
-    
-    public static void clear(Context lContext) {
-      /*
-       * We use the cache dir as a temporary directory (since Android doesn't give us one) so
-       * on startup we'll clean up any .tmp files from the last run.
-       */
-      File[] files = lContext.getCacheDir().listFiles();
-      for (File file : files) {
-        try {
-          Log.d(Email.LOG_TAG, "Deleting file " + file.getCanonicalPath());
-        }
-        catch (IOException ioe) {}   // No need to log failure to log
-         file.delete();
-      }
-  }
-
-    @Override
-    public String getType(Uri uri) {
-        List<String> segments = uri.getPathSegments();
-        String dbName = segments.get(0);
-        String id = segments.get(1);
-        String format = segments.get(2);
-        if (FORMAT_THUMBNAIL.equals(format)) {
-            return "image/png";
-        }
-        else {
-            String path = getContext().getDatabasePath(dbName).getAbsolutePath();
-            SQLiteDatabase db = null;
-            Cursor cursor = null;
-            try {
-                db = SQLiteDatabase.openDatabase(path, null, 0);
-                cursor = db.query(
-                        "attachments",
-                        new String[] { "mime_type" },
-                        "id = ?",
-                        new String[] { id },
-                        null,
-                        null,
-                        null);
-                cursor.moveToFirst();
-                String type = cursor.getString(0);
-                cursor.close();
-                db.close();
-                return type;
-
-            }
-            finally {
-                if (cursor != null) {
-                    cursor.close();
-                }
-                if (db != null) {
-                    db.close();
-                }
-
-            }
-        }
-    }
-
-    @Override
-    public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {
-        List<String> segments = uri.getPathSegments();
-        String dbName = segments.get(0);
-        String id = segments.get(1);
-        String format = segments.get(2);
-        if (FORMAT_THUMBNAIL.equals(format)) {
-            int width = Integer.parseInt(segments.get(3));
-            int height = Integer.parseInt(segments.get(4));
-            String filename = "thmb_" + dbName + "_" + id;
-            File dir = getContext().getCacheDir();
-            File file = new File(dir, filename);
-            if (!file.exists()) {
-                Uri attachmentUri = getAttachmentUri(dbName, Long.parseLong(id));
-                String type = getType(attachmentUri);
-                try {
-                    FileInputStream in = new FileInputStream(
-                            new File(getContext().getDatabasePath(dbName + "_att"), id));
-                    Bitmap thumbnail = createThumbnail(type, in);
-                    thumbnail = thumbnail.createScaledBitmap(thumbnail, width, height, true);
-                    FileOutputStream out = new FileOutputStream(file);
-                    thumbnail.compress(Bitmap.CompressFormat.PNG, 100, out);
-                    out.close();
-                    in.close();
-                }
-                catch (IOException ioe) {
-                    return null;
-                }
-            }
-            return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
-        }
-        else {
-            return ParcelFileDescriptor.open(
-                    new File(getContext().getDatabasePath(dbName + "_att"), id),
-                    ParcelFileDescriptor.MODE_READ_ONLY);
-        }
-    }
-
-    @Override
-    public int delete(Uri uri, String arg1, String[] arg2) {
-        return 0;
-    }
-
-    @Override
-    public Uri insert(Uri uri, ContentValues values) {
-        return null;
-    }
-
-    @Override
-    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
-            String sortOrder) {
-        if (projection == null) {
-            projection =
-                new String[] {
-                    AttachmentProviderColumns._ID,
-                    AttachmentProviderColumns.DATA,
-                    };
-        }
-
-        List<String> segments = uri.getPathSegments();
-        String dbName = segments.get(0);
-        String id = segments.get(1);
-        String format = segments.get(2);
-        String path = getContext().getDatabasePath(dbName).getAbsolutePath();
-        String name = null;
-        int size = -1;
-        SQLiteDatabase db = null;
-        Cursor cursor = null;
-        try {
-            db = SQLiteDatabase.openDatabase(path, null, 0);
-            cursor = db.query(
-                    "attachments",
-                    new String[] { "name", "size" },
-                    "id = ?",
-                    new String[] { id },
-                    null,
-                    null,
-                    null);
-            if (!cursor.moveToFirst()) {
-                return null;
-            }
-            name = cursor.getString(0);
-            size = cursor.getInt(1);
-        }
-        finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-            if (db != null) {
-                db.close();
-            }
-        }
-
-        MatrixCursor ret = new MatrixCursor(projection);
-        Object[] values = new Object[projection.length];
-        for (int i = 0, count = projection.length; i < count; i++) {
-            String column = projection[i];
-            if (AttachmentProviderColumns._ID.equals(column)) {
-                values[i] = id;
-            }
-            else if (AttachmentProviderColumns.DATA.equals(column)) {
-                values[i] = uri.toString();
-            }
-            else if (AttachmentProviderColumns.DISPLAY_NAME.equals(column)) {
-                values[i] = name;
-            }
-            else if (AttachmentProviderColumns.SIZE.equals(column)) {
-                values[i] = size;
-            }
-        }
-        ret.addRow(values);
-        return ret;
-    }
-
-    @Override
-    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
-        return 0;
-    }
-
-    private Bitmap createThumbnail(String type, InputStream data) {
-        if(MimeUtility.mimeTypeMatches(type, "image/*")) {
-            return createImageThumbnail(data);
-        }
-        return null;
-    }
-
-    private Bitmap createImageThumbnail(InputStream data) {
-        try {
-            Bitmap bitmap = BitmapFactory.decodeStream(data);
-            return bitmap;
-        }
-        catch (OutOfMemoryError oome) {
-            /*
-             * Improperly downloaded images, corrupt bitmaps and the like can commonly
-             * cause OOME due to invalid allocation sizes. We're happy with a null bitmap in
-             * that case. If the system is really out of memory we'll know about it soon
-             * enough.
-             */
-            return null;
-        }
-        catch (Exception e) {
-            return null;
-        }
-    }
-}
Index: src/com/android/email/mail/Transport.java
===================================================================
--- src/com/android/email/mail/Transport.java	(revision 718)
+++ src/com/android/email/mail/Transport.java	(working copy)
@@ -1,28 +0,0 @@
-
-package com.android.email.mail;
-
-import com.android.email.mail.transport.SmtpTransport;
-import com.android.email.mail.transport.WebDavTransport;
-
-public abstract class Transport {
-    protected static final int SOCKET_CONNECT_TIMEOUT = 10000;
-
-    // RFC 1047
-    protected static final int SOCKET_READ_TIMEOUT = 300000;
-
-    public synchronized static Transport getInstance(String uri) throws MessagingException {
-        if (uri.startsWith("smtp")) {
-            return new SmtpTransport(uri);
-        } else if (uri.startsWith("webdav")) {
-                return new WebDavTransport(uri);
-        } else {
-            throw new MessagingException("Unable to locate an applicable Transport for " + uri);
-        }
-    }
-
-    public abstract void open() throws MessagingException;
-
-    public abstract void sendMessage(Message message) throws MessagingException;
-
-    public abstract void close() throws MessagingException;
-}
Index: .classpath
===================================================================
--- .classpath	(revision 0)
+++ .classpath	(revision 0)
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="lib" path="libs/commons-codec-1.3.jar"/>
+	<classpathentry kind="lib" path="libs/commons-logging-1.1.1.jar"/>
+	<classpathentry kind="lib" path="libs/bcprov-jdk15-143.jar"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
Index: src/com/android/email/mail/store/ImapStore.java
===================================================================
--- src/com/android/email/mail/store/ImapStore.java	(revision 718)
+++ src/com/android/email/mail/store/ImapStore.java	(working copy)
@@ -4,9 +4,11 @@
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.io.StringWriter;
 import java.io.UnsupportedEncodingException;
 import java.net.ConnectException;
 import java.net.InetSocketAddress;
@@ -28,11 +30,10 @@
 import java.util.LinkedHashSet;
 import java.util.LinkedList;
 import java.util.List;
-import java.util.UUID;
 
 import javax.net.ssl.SSLContext;
-import javax.net.ssl.TrustManager;
 import javax.net.ssl.SSLException;
+import javax.net.ssl.TrustManager;
 
 import android.util.Config;
 import android.util.Log;
@@ -41,6 +42,7 @@
 import com.android.email.PeekableInputStream;
 import com.android.email.Utility;
 import com.android.email.mail.AuthenticationFailedException;
+import com.android.email.mail.CertificateValidationException;
 import com.android.email.mail.FetchProfile;
 import com.android.email.mail.Flag;
 import com.android.email.mail.Folder;
@@ -49,7 +51,6 @@
 import com.android.email.mail.MessagingException;
 import com.android.email.mail.Part;
 import com.android.email.mail.Store;
-import com.android.email.mail.CertificateValidationException;
 import com.android.email.mail.Folder.FolderType;
 import com.android.email.mail.internet.MimeBodyPart;
 import com.android.email.mail.internet.MimeHeader;
@@ -58,8 +59,6 @@
 import com.android.email.mail.internet.MimeUtility;
 import com.android.email.mail.store.ImapResponseParser.ImapList;
 import com.android.email.mail.store.ImapResponseParser.ImapResponse;
-import com.android.email.mail.store.LocalStore.LocalFolder;
-import com.android.email.mail.store.LocalStore.LocalMessage;
 import com.android.email.mail.transport.CountingOutputStream;
 import com.android.email.mail.transport.EOLConvertingOutputStream;
 import com.beetstra.jutf7.CharsetProvider;
@@ -1063,18 +1062,44 @@
 
         }
 
+        public void appendMessages(Message[] messages) throws MessagingException {
+        	appendMessages(messages, false);
+        }
+        
         /**
          * Appends the given messages to the selected folder. This implementation also determines
          * the new UID of the given message on the IMAP server and sets the Message's UID to the
          * new server UID.
          */
-        public void appendMessages(Message[] messages) throws MessagingException {
+        public void appendMessages(Message[] messages, boolean determineUids) throws MessagingException {
             checkOpen();
             try {
                 for (Message message : messages) {
                     CountingOutputStream out = new CountingOutputStream();
                     EOLConvertingOutputStream eolOut = new EOLConvertingOutputStream(out);
                     message.writeTo(eolOut);
+                    
+ByteArrayOutputStream stream = new ByteArrayOutputStream() {
+
+	@Override
+	public synchronized void write(byte[] buffer, int offset, int len) {
+		// TODO Auto-generated method stub
+		for (int i = 0; i < len; i++) {
+			Log.d(Email.LOG_TAG, "Write byte: " + buffer[offset + i]);
+		}
+		super.write(buffer, offset, len);
+	}
+
+	@Override
+	public synchronized void write(int oneByte) {
+		Log.d(Email.LOG_TAG, "Write byte: " + oneByte);
+		super.write(oneByte);
+	}
+	
+};
+message.writeTo(stream);
+Log.d(Email.LOG_TAG, stream.toString("US-ASCII"));
+                    
                     eolOut.flush();
                     
                     mConnection.sendCommand(
@@ -1096,17 +1121,18 @@
                         while (response.more());
                     } while(response.mTag == null);
 
-                    String newUid = getUidFromMessageId(message);
-                    if (Config.LOGD)
-                    {
-                    	Log.d(Email.LOG_TAG, "Got UID " + newUid + " for message");
-                    }          
-                    
-                    if (newUid != null)
-                    {
-                    	message.setUid(newUid);
+                    if (determineUids) {
+	                    String newUid = getUidFromMessageId(message);
+	                    if (Config.LOGD)
+	                    {
+	                    	Log.d(Email.LOG_TAG, "Got UID " + newUid + " for message");
+	                    }          
+	                    
+	                    if (newUid != null)
+	                    {
+	                    	message.setUid(newUid);
+	                    }
                     }
-                    
                    
                 }
             }
Index: src/com/android/email/mail/transport/EOLConvertingOutputStream.java
===================================================================
--- src/com/android/email/mail/transport/EOLConvertingOutputStream.java	(revision 718)
+++ src/com/android/email/mail/transport/EOLConvertingOutputStream.java	(working copy)
@@ -13,6 +13,9 @@
 
     @Override
     public void write(int oneByte) throws IOException {
+    	if (oneByte == 0)
+    		return;
+    	
         if (oneByte == '\n') {
             if (lastChar != '\r') {
                 super.write('\r');
Index: src/com/android/email/activity/Welcome.java
===================================================================
--- src/com/android/email/activity/Welcome.java	(revision 718)
+++ src/com/android/email/activity/Welcome.java	(working copy)
@@ -1,29 +0,0 @@
-package com.android.email.activity;
-
-import com.android.email.Account;
-import com.android.email.Email;
-import com.android.email.Preferences;
-
-import com.android.email.K9Activity;
-import android.content.Intent;
-import android.os.Bundle;
-
-/**
- * The Welcome activity initializes the application and decides what Activity
- * the user should start with.
- * If no accounts are configured the user is taken to the Accounts Activity where they
- * can configure an account.
- * If a single account is configured the user is taken directly to the MessageList for
- * the INBOX of that account.
- * If more than one account is configuref the user is takaen to the Accounts Activity so they
- * can select an account.
- */
-public class Welcome extends K9Activity {
-    @Override
-    public void onCreate(Bundle icicle) {
-        super.onCreate(icicle);
-
-        Accounts.actionLaunch(this);
-        finish();
-    }
-}
Index: src/com/android/email/activity/Accounts.java
===================================================================
--- src/com/android/email/activity/Accounts.java	(revision 718)
+++ src/com/android/email/activity/Accounts.java	(working copy)
@@ -1,627 +0,0 @@
-
-package com.android.email.activity;
-
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-
-import android.app.AlertDialog;
-import android.app.Dialog;
-import com.android.email.K9ListActivity;
-import android.app.NotificationManager;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.PowerManager;
-import android.os.PowerManager.WakeLock;
-import android.view.ContextMenu;
-import android.view.KeyEvent;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.Window;
-import android.view.ContextMenu.ContextMenuInfo;
-import android.view.View.OnClickListener;
-import android.webkit.WebView;
-import android.widget.AdapterView;
-import android.widget.ArrayAdapter;
-import android.widget.LinearLayout;
-import android.widget.ListView;
-import android.widget.TextView;
-import android.widget.Toast;
-import android.widget.AdapterView.AdapterContextMenuInfo;
-import android.widget.AdapterView.OnItemClickListener;
-
-import com.android.email.Account;
-import com.android.email.Email;
-import com.android.email.MessagingController;
-import com.android.email.MessagingListener;
-import com.android.email.Preferences;
-import com.android.email.R;
-import com.android.email.activity.setup.Prefs;
-import com.android.email.activity.setup.AccountSettings;
-import com.android.email.activity.setup.AccountSetupBasics;
-import com.android.email.activity.setup.AccountSetupCheckSettings;
-import com.android.email.mail.Folder;
-import com.android.email.mail.MessagingException;
-import com.android.email.mail.Store;
-import com.android.email.mail.store.LocalStore;
-import com.android.email.mail.store.LocalStore.LocalFolder;
-
-public class Accounts extends K9ListActivity implements OnItemClickListener, OnClickListener {
-    private static final int DIALOG_REMOVE_ACCOUNT = 1;
-    private ConcurrentHashMap<String, Integer> unreadMessageCounts = new ConcurrentHashMap<String, Integer>();
-    
-    private ConcurrentHashMap<Account, String> pendingWork = new ConcurrentHashMap<Account, String>();
-    /**
-     * Key codes used to open a debug settings screen.
-     */
-    private static int[] secretKeyCodes = {
-            KeyEvent.KEYCODE_D, KeyEvent.KEYCODE_E, KeyEvent.KEYCODE_B, KeyEvent.KEYCODE_U,
-            KeyEvent.KEYCODE_G
-    };
-
-    private int mSecretKeyCodeIndex = 0;
-    private Account mSelectedContextAccount;
-    
-    private AccountsHandler mHandler = new AccountsHandler();
-    private AccountsAdapter mAdapter;
-    
-    private class AccountSizeChangedHolder {
-      Account account;
-      long oldSize;
-      long newSize;
-    }
-    
-    class AccountsHandler extends Handler
-    {
-      private static final int DATA_CHANGED = 1;
-      private static final int MSG_ACCOUNT_SIZE_CHANGED = 2;
-      private static final int MSG_WORKING_ACCOUNT = 3;
-      private static final int MSG_PROGRESS = 4;
-      private static final int MSG_FOLDER_SYNCING = 5;
-      private static final int MSG_DEFINITE_PROGRESS = 6;
-
-      public void handleMessage(android.os.Message msg)
-      {
-        switch (msg.what)
-        {
-          case DATA_CHANGED:
-            if (mAdapter != null)
-            {
-              mAdapter.notifyDataSetChanged();
-            }
-            break;
-          case MSG_WORKING_ACCOUNT:
-          {
-            Account account = (Account)msg.obj;
-            int res = msg.arg1;
-            String toastText = getString(res, account.getDescription());
-            
-            Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_SHORT);
-            toast.show();
-            break;
-          }
-          case MSG_ACCOUNT_SIZE_CHANGED:
-          {
-            AccountSizeChangedHolder holder = (AccountSizeChangedHolder)msg.obj;
-            Account account = holder.account;
-            Long oldSize = holder.oldSize;
-            Long newSize = holder.newSize;
-            String toastText = getString(R.string.account_size_changed, account.getDescription(), 
-                SizeFormatter.formatSize(getApplication(), oldSize), SizeFormatter.formatSize(getApplication(), newSize));;
-            
-            Toast toast = Toast.makeText(getApplication(), toastText, Toast.LENGTH_LONG);
-            toast.show();
-            break;
-          }
-          case MSG_FOLDER_SYNCING:
-          {
-            String folderName = (String) ((Object[]) msg.obj)[0];
-            String dispString;
-            dispString = getString(R.string.accounts_title);
-            if (folderName != null)
-            {
-              dispString += " (" + getString(R.string.status_loading)
-              + folderName + ")";
-            }
-            setTitle(dispString);
-            break;
-          }
-          case MSG_PROGRESS:
-            setProgressBarIndeterminateVisibility(msg.arg1 != 0);
-            //setProgressBarVisibility(msg.arg1 != 0);
-            break;          
-          case MSG_DEFINITE_PROGRESS:
-            getWindow().setFeatureInt(Window.FEATURE_PROGRESS, msg.arg1);
-              break;
-          default:
-            super.handleMessage(msg);
-        }
-      }
-      
-      public void dataChanged()
-      {
-              sendEmptyMessage(DATA_CHANGED);
-      }
-      
-      public void workingAccount(Account account, int res)
-      {
-              android.os.Message msg = new android.os.Message();
-              msg.what = MSG_WORKING_ACCOUNT;
-              msg.obj = account;
-              msg.arg1 = res;
-       
-              sendMessage(msg);
-      }
-      
-      public void accountSizeChanged(Account account, long oldSize, long newSize)
-      {
-              android.os.Message msg = new android.os.Message();
-              msg.what = MSG_ACCOUNT_SIZE_CHANGED;
-              AccountSizeChangedHolder holder = new AccountSizeChangedHolder();
-              holder.account = account;
-              holder.oldSize = oldSize;
-              holder.newSize = newSize;
-              msg.obj = holder;
-              sendMessage(msg);
-      }
-      
-      public void progress(boolean progress)
-      {
-              android.os.Message msg = new android.os.Message();
-              msg.what = MSG_PROGRESS;
-              msg.arg1 = progress ? 1 : 0;
-              sendMessage(msg);
-      }
-      public void progress(int progress)
-      {
-              android.os.Message msg = new android.os.Message();
-              msg.what = MSG_DEFINITE_PROGRESS;
-              msg.arg1 = progress ;
-              sendMessage(msg);
-      }
-      public void folderSyncing(String folder)
-      {
-              android.os.Message msg = new android.os.Message();
-        msg.what = MSG_FOLDER_SYNCING;
-        msg.obj = new String[]
-        { folder };
-              sendMessage(msg);
-          }
-
-    }
-    
-    MessagingListener mListener = new MessagingListener() {
-      @Override
-      public void accountStatusChanged(Account account, int unreadMessageCount)
-      {
-        unreadMessageCounts.put(account.getUuid(), unreadMessageCount);
-        mHandler.dataChanged();
-        pendingWork.remove(account);
-       
-
-        if (pendingWork.isEmpty())
-        {
-          mHandler.progress(Window.PROGRESS_END);
-        }
-        else {
-          int level = (Window.PROGRESS_END / mAdapter.getCount()) * (mAdapter.getCount() - pendingWork.size()) ;
-          mHandler.progress(level);
-        }
-      }
-      
-      @Override
-      public void accountSizeChanged(Account account, long oldSize, long newSize)
-      {
-
-       mHandler.accountSizeChanged(account, oldSize, newSize);
- 
-      }
-      
-      @Override
-      public void synchronizeMailboxFinished(
-          Account account,
-          String folder,
-          int totalMessagesInMailbox,
-          int numNewMessages) {
-        MessagingController.getInstance(getApplication()).getAccountUnreadCount(Accounts.this, account, mListener);
-
-        mHandler.progress(false);
-        mHandler.folderSyncing(null);
-      }
-      
-      @Override
-      public void synchronizeMailboxStarted(Account account, String folder)
-      {
-        mHandler.progress(true);
-        mHandler.folderSyncing(account.getDescription()
-            + getString(R.string.notification_bg_title_separator) + folder);
-      }
-
-            @Override
-      public void synchronizeMailboxFailed(Account account, String folder,
-          String message)
-      {
-            mHandler.progress(false);
-            mHandler.folderSyncing(null);
-       }
-
-    };
-
-    private static String UNREAD_MESSAGE_COUNTS = "unreadMessageCounts";
-    private static String SELECTED_CONTEXT_ACCOUNT = "selectedContextAccount";
-
-    private static final String EXTRA_STARTUP = "startup";
-
-
-    public static void actionLaunch(Context context) {
-        Intent intent = new Intent(context, Accounts.class);
-        intent.putExtra(EXTRA_STARTUP, true);
-        context.startActivity(intent);
-    }
-
-
-    @Override
-    public void onCreate(Bundle icicle) {
-        super.onCreate(icicle);
-
-        Account[] accounts = Preferences.getPreferences(this).getAccounts();
-        Intent intent = getIntent();
-        boolean startup = (boolean)intent.getBooleanExtra(EXTRA_STARTUP, false);
-        if (startup && accounts.length == 1) {
-            FolderList.actionHandleAccount(this, accounts[0], accounts[0].getAutoExpandFolderName());
-            finish();
-        }
-        else {
-            requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
-            requestWindowFeature(Window.FEATURE_PROGRESS);
-
-            setContentView(R.layout.accounts);
-            ListView listView = getListView();
-            listView.setOnItemClickListener(this);
-            listView.setItemsCanFocus(false);
-            listView.setEmptyView(findViewById(R.id.empty));
-            findViewById(R.id.add_new_account).setOnClickListener(this);
-            registerForContextMenu(listView);
-
-            if (icicle != null && icicle.containsKey(SELECTED_CONTEXT_ACCOUNT)) {
-                mSelectedContextAccount = (Account) icicle.getSerializable("selectedContextAccount");
-            }
-
-            if (icicle != null) {
-                Map<String, Integer> oldUnreadMessageCounts = (Map<String, Integer>)icicle.get(UNREAD_MESSAGE_COUNTS);
-                if (oldUnreadMessageCounts != null) {
-                    unreadMessageCounts.putAll(oldUnreadMessageCounts);
-                }
-            }
-        }
-    }
-
-    @Override
-    public void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        if (mSelectedContextAccount != null) {
-            outState.putSerializable(SELECTED_CONTEXT_ACCOUNT, mSelectedContextAccount);
-        }
-        outState.putSerializable(UNREAD_MESSAGE_COUNTS, unreadMessageCounts);
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-
-        refresh();
-        MessagingController.getInstance(getApplication()).addListener(mListener);
-    }
-    
-    @Override
-    public void onPause() {
-      super.onPause();
-      MessagingController.getInstance(getApplication()).removeListener(mListener);
-    }
-
-    private void refresh() {
-        Account[] accounts = Preferences.getPreferences(this).getAccounts();
-        mAdapter = new AccountsAdapter(accounts);
-        getListView().setAdapter(mAdapter);
-        if (accounts.length > 0) {
-          mHandler.progress(Window.PROGRESS_START);
-        }
-        
-        for (Account account : accounts) {
-          MessagingController.getInstance(getApplication()).getAccountUnreadCount(Accounts.this, account, mListener);
-          pendingWork.put(account, "true");
-        }
-        
-    }
-
-    private void onAddNewAccount() {
-        AccountSetupBasics.actionNewAccount(this);
-    }
-
-    private void onEditAccount(Account account) {
-        AccountSettings.actionSettings(this, account);
-    }
-
-    private void onEditPrefs() {
-        Prefs.actionPrefs(this);
-    }
-
-
-    private void onCheckMail(Account account) {
-        MessagingController.getInstance(getApplication()).checkMail(this, account, true, true, null);
-    }
-    
-    private void onClearCommands(Account account) {
-      MessagingController.getInstance(getApplication()).clearAllPending(account);
-    }
-  	
-    private void onEmptyTrash(Account account) {
-  		MessagingController.getInstance(getApplication()).emptyTrash(account, null);
-  	}
-
-
-    private void onCompose() {
-        Account defaultAccount = Preferences.getPreferences(this).getDefaultAccount();
-        if (defaultAccount != null) {
-            MessageCompose.actionCompose(this, defaultAccount);
-        }
-        else {
-            onAddNewAccount();
-        }
-    }
-
-    private void onOpenAccount(Account account) {
-      FolderList.actionHandleAccount(this, account, true);
-    }
-
-    public void onClick(View view) {
-        if (view.getId() == R.id.add_new_account) {
-            onAddNewAccount();
-        }
-    }
-
-    private void onDeleteAccount(Account account) {
-        mSelectedContextAccount = account;
-        showDialog(DIALOG_REMOVE_ACCOUNT);
-    }
-
-    @Override
-    public Dialog onCreateDialog(int id) {
-        switch (id) {
-            case DIALOG_REMOVE_ACCOUNT:
-                return createRemoveAccountDialog();
-        }
-        return super.onCreateDialog(id);
-    }
-
-    private Dialog createRemoveAccountDialog() {
-        return new AlertDialog.Builder(this)
-            .setTitle(R.string.account_delete_dlg_title)
-            .setMessage(getString(R.string.account_delete_dlg_instructions_fmt, mSelectedContextAccount.getDescription()))
-            .setPositiveButton(R.string.okay_action, new DialogInterface.OnClickListener() {
-                public void onClick(DialogInterface dialog, int whichButton) {
-                    dismissDialog(DIALOG_REMOVE_ACCOUNT);
-                    try {
-                        ((LocalStore)Store.getInstance( mSelectedContextAccount.getLocalStoreUri(), getApplication())).delete();
-                    } catch (Exception e) {
-                            // Ignore
-                    }
-                    mSelectedContextAccount.delete(Preferences.getPreferences(Accounts.this));
-                    Email.setServicesEnabled(Accounts.this);
-                    refresh();
-                }
-            })
-            .setNegativeButton(R.string.cancel_action, new DialogInterface.OnClickListener() {
-                public void onClick(DialogInterface dialog, int whichButton) {
-                    dismissDialog(DIALOG_REMOVE_ACCOUNT);
-                }
-            })
-            .create();
-    }
-
-    public boolean onContextItemSelected(MenuItem item) {
-        AdapterContextMenuInfo menuInfo = (AdapterContextMenuInfo)item.getMenuInfo();
-        Account account = (Account)getListView().getItemAtPosition(menuInfo.position);
-        switch (item.getItemId()) {
-            case R.id.edit_prefs:
-                onEditPrefs();
-                break;
-            case R.id.delete_account:
-                onDeleteAccount(account);
-                break;
-            case R.id.edit_account:
-                onEditAccount(account);
-                break;
-            case R.id.open:
-                onOpenAccount(account);
-                break;
-            case R.id.check_mail:
-              onCheckMail(account);
-              break;
-            case R.id.clear_pending:
-              onClearCommands(account);
-              break;
-            case R.id.empty_trash:
-              onEmptyTrash(account);
-              break;
-            case R.id.compact:
-              onCompact(account);
-              break;
-            case R.id.clear:
-              onClear(account);
-              break;
-        }
-        return true;
-    }
-    
-    private void onCompact(Account account) {
-      mHandler.workingAccount(account, R.string.compacting_account);
-      MessagingController.getInstance(getApplication()).compact(account, null);
-    }
-    
-    private void onClear(Account account) {
-      mHandler.workingAccount(account, R.string.clearing_account);
-      MessagingController.getInstance(getApplication()).clear(account, null);
-    }
-
-
-    public void onItemClick(AdapterView parent, View view, int position, long id) {
-        Account account = (Account)parent.getItemAtPosition(position);
-        onOpenAccount(account);
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        switch (item.getItemId()) {
-            case R.id.add_new_account:
-                onAddNewAccount();
-                break;
-            case R.id.edit_prefs:
-                onEditPrefs();
-                break;
-            case R.id.check_mail:
-                onCheckMail(null);
-                break;
-            case R.id.compose:
-                onCompose();
-                break;
-            case R.id.about:
-                onAbout();
-                break;
-            default:
-                return super.onOptionsItemSelected(item);
-        }
-        return true;
-    }
-
-    private void onAbout() {
-    	String appName = getString(R.string.app_name);
-    	WebView wv = new WebView(this);
-    	String html = "<h1>" + String.format(getString(R.string.about_title_fmt).toString(),
-        		"<a href=\"" + getString(R.string.app_webpage_url) + "\">" + appName + "</a>") + "</h1>" +
-    		"<p>" + appName + " " + 
-		String.format(getString(R.string.debug_version_fmt).toString(),
-				getVersionNumber()) + "</p>" +
-				"<p>" + String.format(getString(R.string.app_authors_fmt).toString(), 
-						getString(R.string.app_authors)) + "</p>" +
-				"<p>" + String.format(getString(R.string.app_revision_fmt).toString(), 
-						"<a href=\"" + getString(R.string.app_revision_url) + "\">" + 
-						getString(R.string.app_revision_url) + "</a></p>");
-    	wv.loadData(html, "text/html", "utf-8");
-    	new AlertDialog.Builder(this)
-        .setView(wv)
-        .setCancelable(true)
-        .setPositiveButton(R.string.okay_action, new DialogInterface.OnClickListener () {
-        	public void onClick(DialogInterface d, int c) {
-        		d.dismiss();
-        	}
-        })
-        .show();
-    }
-
-    /**
-     * Get current version number.
-     *
-     * @return String version
-     */
-    private String getVersionNumber() {
-            String version = "?";
-            try {
-                    PackageInfo pi = getPackageManager().getPackageInfo(getPackageName(), 0);
-                    version = pi.versionName;
-            } catch (PackageManager.NameNotFoundException e) {
-                    //Log.e(TAG, "Package name not found", e);
-            };
-            return version;
-    } 
-    
-	public boolean onItemLongClick(AdapterView<?> parent, View view, int position, long id) {
-        return true;
-    }
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        super.onCreateOptionsMenu(menu);
-        getMenuInflater().inflate(R.menu.accounts_option, menu);
-        return true;
-    }
-
-    @Override
-    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
-        super.onCreateContextMenu(menu, v, menuInfo);
-        menu.setHeaderTitle(R.string.accounts_context_menu_title);
-        getMenuInflater().inflate(R.menu.accounts_context, menu);
-    }
-
-    @Override
-    public boolean onKeyDown(int keyCode, KeyEvent event) {
-        if (event.getKeyCode() == secretKeyCodes[mSecretKeyCodeIndex]) {
-            mSecretKeyCodeIndex++;
-            if (mSecretKeyCodeIndex == secretKeyCodes.length) {
-                mSecretKeyCodeIndex = 0;
-                startActivity(new Intent(this, Debug.class));
-            }
-        } else {
-            mSecretKeyCodeIndex = 0;
-        }
-        return super.onKeyDown(keyCode, event);
-    }
-    
-
-    class AccountsAdapter extends ArrayAdapter<Account> {
-        public AccountsAdapter(Account[] accounts) {
-            super(Accounts.this, 0, accounts);
-        }
-        
-        @Override
-        public View getView(int position, View convertView, ViewGroup parent) {
-            Account account = getItem(position);
-            View view;
-            if (convertView != null) {
-                view = convertView;
-            }
-            else {
-                view = getLayoutInflater().inflate(R.layout.accounts_item, parent, false);
-            }
-            AccountViewHolder holder = (AccountViewHolder) view.getTag();
-            if (holder == null) {
-                holder = new AccountViewHolder();
-                holder.description = (TextView) view.findViewById(R.id.description);
-                holder.email = (TextView) view.findViewById(R.id.email);
-                holder.newMessageCount = (TextView) view.findViewById(R.id.new_message_count);
-                view.setTag(holder);
-            }
-            holder.description.setText(account.getDescription());
-            holder.email.setText(account.getEmail());
-            if (account.getEmail().equals(account.getDescription())) {
-                holder.email.setVisibility(View.GONE);
-            }
-
-            Integer unreadMessageCount = unreadMessageCounts.get(account.getUuid());
-            if (unreadMessageCount != null) {
-              holder.newMessageCount.setText(Integer.toString(unreadMessageCount));
-              holder.newMessageCount.setVisibility(unreadMessageCount > 0 ? View.VISIBLE : View.GONE);
-            }
-            else {
-              //holder.newMessageCount.setText("-");
-              holder.newMessageCount.setVisibility(View.GONE); 
-            }
-            
-            return view;
-        }
-
-        class AccountViewHolder {
-            public TextView description;
-            public TextView email;
-            public TextView newMessageCount;
-        }
-    }
-}
-
-
Index: src/com/android/email/activity/setup/SpinnerOption.java
===================================================================
--- src/com/android/email/activity/setup/SpinnerOption.java	(revision 718)
+++ src/com/android/email/activity/setup/SpinnerOption.java	(working copy)
@@ -1,33 +0,0 @@
-/**
- * 
- */
-
-package com.android.email.activity.setup;
-
-import android.widget.Spinner;
-
-public class SpinnerOption {
-    public Object value;
-
-    public String label;
-
-    public static void setSpinnerOptionValue(Spinner spinner, Object value) {
-        for (int i = 0, count = spinner.getCount(); i < count; i++) {
-            SpinnerOption so = (SpinnerOption)spinner.getItemAtPosition(i);
-            if (so.value.equals(value)) {
-                spinner.setSelection(i, true);
-                return;
-            }
-        }
-    }
-
-    public SpinnerOption(Object value, String label) {
-        this.value = value;
-        this.label = label;
-    }
-
-    @Override
-    public String toString() {
-        return label;
-    }
-}
Index: src/com/android/email/mail/store/Pop3Store.java
===================================================================
--- src/com/android/email/mail/store/Pop3Store.java	(revision 718)
+++ src/com/android/email/mail/store/Pop3Store.java	(working copy)
@@ -1,959 +0,0 @@
-
-package com.android.email.mail.store;
-
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.net.SocketAddress;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.security.GeneralSecurityException;
-import java.security.SecureRandom;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.SSLException;
-
-import android.util.Config;
-import android.util.Log;
-
-import com.android.email.Email;
-import com.android.email.Utility;
-import com.android.email.mail.AuthenticationFailedException;
-import com.android.email.mail.FetchProfile;
-import com.android.email.mail.Flag;
-import com.android.email.mail.Folder;
-import com.android.email.mail.Message;
-import com.android.email.mail.MessageRetrievalListener;
-import com.android.email.mail.MessagingException;
-import com.android.email.mail.Store;
-import com.android.email.mail.CertificateValidationException;
-import com.android.email.mail.Folder.OpenMode;
-import com.android.email.mail.internet.MimeMessage;
-
-public class Pop3Store extends Store {
-    public static final int CONNECTION_SECURITY_NONE = 0;
-    public static final int CONNECTION_SECURITY_TLS_OPTIONAL = 1;
-    public static final int CONNECTION_SECURITY_TLS_REQUIRED = 2;
-    public static final int CONNECTION_SECURITY_SSL_REQUIRED = 3;
-    public static final int CONNECTION_SECURITY_SSL_OPTIONAL = 4;
-
-    private static final Flag[] PERMANENT_FLAGS = { Flag.DELETED };
-
-    private String mHost;
-    private int mPort;
-    private String mUsername;
-    private String mPassword;
-    private int mConnectionSecurity;
-    private HashMap<String, Folder> mFolders = new HashMap<String, Folder>();
-    private Pop3Capabilities mCapabilities;
-
-//    /**
-//     * Detected latency, used for usage scaling.
-//     * Usage scaling occurs when it is neccesary to get information about
-//     * messages that could result in large data loads. This value allows
-//     * the code that loads this data to decide between using large downloads
-//     * (high latency) or multiple round trips (low latency) to accomplish
-//     * the same thing.
-//     * Default is Integer.MAX_VALUE implying massive latency so that the large
-//     * download method is used by default until latency data is collected.
-//     */
-//    private int mLatencyMs = Integer.MAX_VALUE;
-//
-//    /**
-//     * Detected throughput, used for usage scaling.
-//     * Usage scaling occurs when it is neccesary to get information about
-//     * messages that could result in large data loads. This value allows
-//     * the code that loads this data to decide between using large downloads
-//     * (high latency) or multiple round trips (low latency) to accomplish
-//     * the same thing.
-//     * Default is Integer.MAX_VALUE implying massive bandwidth so that the
-//     * large download method is used by default until latency data is
-//     * collected.
-//     */
-//    private int mThroughputKbS = Integer.MAX_VALUE;
-
-    /**
-     * pop3://user:password@server:port CONNECTION_SECURITY_NONE
-     * pop3+tls://user:password@server:port CONNECTION_SECURITY_TLS_OPTIONAL
-     * pop3+tls+://user:password@server:port CONNECTION_SECURITY_TLS_REQUIRED
-     * pop3+ssl+://user:password@server:port CONNECTION_SECURITY_SSL_REQUIRED
-     * pop3+ssl://user:password@server:port CONNECTION_SECURITY_SSL_OPTIONAL
-     *
-     * @param _uri
-     */
-    public Pop3Store(String _uri) throws MessagingException {
-        URI uri;
-        try {
-            uri = new URI(_uri);
-        } catch (URISyntaxException use) {
-            throw new MessagingException("Invalid Pop3Store URI", use);
-        }
-
-        String scheme = uri.getScheme();
-        if (scheme.equals("pop3")) {
-            mConnectionSecurity = CONNECTION_SECURITY_NONE;
-            mPort = 110;
-        } else if (scheme.equals("pop3+tls")) {
-            mConnectionSecurity = CONNECTION_SECURITY_TLS_OPTIONAL;
-            mPort = 110;
-        } else if (scheme.equals("pop3+tls+")) {
-            mConnectionSecurity = CONNECTION_SECURITY_TLS_REQUIRED;
-            mPort = 110;
-        } else if (scheme.equals("pop3+ssl+")) {
-            mConnectionSecurity = CONNECTION_SECURITY_SSL_REQUIRED;
-            mPort = 995;
-        } else if (scheme.equals("pop3+ssl")) {
-            mConnectionSecurity = CONNECTION_SECURITY_SSL_OPTIONAL;
-            mPort = 995;
-        } else {
-            throw new MessagingException("Unsupported protocol");
-        }
-
-        mHost = uri.getHost();
-
-        if (uri.getPort() != -1) {
-            mPort = uri.getPort();
-        }
-
-        if (uri.getUserInfo() != null) {
-            String[] userInfoParts = uri.getUserInfo().split(":", 2);
-            mUsername = userInfoParts[0];
-            if (userInfoParts.length > 1) {
-                mPassword = userInfoParts[1];
-            }
-        }
-    }
-
-    @Override
-    public Folder getFolder(String name) throws MessagingException {
-        Folder folder = mFolders.get(name);
-        if (folder == null) {
-            folder = new Pop3Folder(name);
-            mFolders.put(folder.getName(), folder);
-        }
-        return folder;
-    }
-
-    @Override
-    public Folder[] getPersonalNamespaces() throws MessagingException {
-        return new Folder[] {
-            getFolder("INBOX"),
-        };
-    }
-
-    @Override
-    public void checkSettings() throws MessagingException {
-        Pop3Folder folder = new Pop3Folder("INBOX");
-        folder.open(OpenMode.READ_WRITE);
-        if (!mCapabilities.uidl) {
-            /*
-             * Run an additional test to see if UIDL is supported on the server. If it's not we
-             * can't service this account.
-             */
-            
-            /*
-             * If the server doesn't support UIDL it will return a - response, which causes
-             * executeSimpleCommand to throw a MessagingException, exiting this method.
-             */
-            folder.executeSimpleCommand("UIDL");
-           
-        }
-        folder.close(false);
-    }
-
-    class Pop3Folder extends Folder {
-        private Socket mSocket;
-        private InputStream mIn;
-        private OutputStream mOut;
-        private HashMap<String, Pop3Message> mUidToMsgMap = new HashMap<String, Pop3Message>();
-        private HashMap<Integer, Pop3Message> mMsgNumToMsgMap = new HashMap<Integer, Pop3Message>();
-        private HashMap<String, Integer> mUidToMsgNumMap = new HashMap<String, Integer>();
-        private String mName;
-        private int mMessageCount;
-
-        public Pop3Folder(String name) {
-            this.mName = name;
-            if (mName.equalsIgnoreCase("INBOX")) {
-                mName = "INBOX";
-            }
-        }
-
-        @Override
-        public synchronized void open(OpenMode mode) throws MessagingException {
-            if (isOpen()) {
-                return;
-            }
-
-            if (!mName.equalsIgnoreCase("INBOX")) {
-                throw new MessagingException("Folder does not exist");
-            }
-
-            try {
-                SocketAddress socketAddress = new InetSocketAddress(mHost, mPort);
-                if (mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED ||
-                        mConnectionSecurity == CONNECTION_SECURITY_SSL_OPTIONAL) {
-                    SSLContext sslContext = SSLContext.getInstance("TLS");
-                    final boolean secure = mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED;
-                    sslContext.init(null, new TrustManager[] {
-                            TrustManagerFactory.get(mHost, secure)
-                    }, new SecureRandom());
-                    mSocket = sslContext.getSocketFactory().createSocket();
-                    mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
-                    mIn = new BufferedInputStream(mSocket.getInputStream(), 1024);
-                    mOut = new BufferedOutputStream(mSocket.getOutputStream(), 512);
-                } else {
-                    mSocket = new Socket();
-                    mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
-                    mIn = new BufferedInputStream(mSocket.getInputStream(), 1024);
-                    mOut = new BufferedOutputStream(mSocket.getOutputStream(), 512);
-                }
-
-                mSocket.setSoTimeout(Store.SOCKET_READ_TIMEOUT);
-                if (!isOpen())
-                {
-                  throw new MessagingException("Unable to connect socket");
-                }
-
-                // Eat the banner
-                executeSimpleCommand(null);
-
-                mCapabilities = getCapabilities();
-
-                if (mConnectionSecurity == CONNECTION_SECURITY_TLS_OPTIONAL
-                        || mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED) {
-                    if (mCapabilities.stls) {
-                        writeLine("STLS");
-
-                        SSLContext sslContext = SSLContext.getInstance("TLS");
-                        boolean secure = mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED;
-                        sslContext.init(null, new TrustManager[] {
-                                TrustManagerFactory.get(mHost, secure)
-                        }, new SecureRandom());
-                        mSocket = sslContext.getSocketFactory().createSocket(mSocket, mHost, mPort,
-                                true);
-                        mSocket.setSoTimeout(Store.SOCKET_READ_TIMEOUT);
-                        mIn = new BufferedInputStream(mSocket.getInputStream(), 1024);
-                        mOut = new BufferedOutputStream(mSocket.getOutputStream(), 512);
-                        if (!isOpen())
-                        {
-                          throw new MessagingException("Unable to connect socket");
-                        }
-                    } else if (mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED) {
-                        throw new MessagingException("TLS not supported but required");
-                    }
-                }
-
-                try {
-                    executeSimpleCommand("USER " + mUsername);
-                    executeSimpleCommand("PASS " + mPassword);
-                } catch (MessagingException me) {
-                    throw new AuthenticationFailedException(null, me);
-                }
-            } catch (SSLException e) {
-                throw new CertificateValidationException(e.getMessage(), e);
-            } catch (GeneralSecurityException gse) {
-                throw new MessagingException(
-                        "Unable to open connection to POP server due to security error.", gse);
-            } catch (IOException ioe) {
-                throw new MessagingException("Unable to open connection to POP server.", ioe);
-            }
-
-            String response = executeSimpleCommand("STAT");
-            String[] parts = response.split(" ");
-            mMessageCount = Integer.parseInt(parts[1]);
-            
-            mUidToMsgMap.clear();
-            mMsgNumToMsgMap.clear();
-            mUidToMsgNumMap.clear();
-        }
-
-        public boolean isOpen() {
-            return (mIn != null && mOut != null && mSocket != null 
-                && mSocket.isConnected() && !mSocket.isClosed());
-        }
-
-        @Override
-        public OpenMode getMode() throws MessagingException {
-            return OpenMode.READ_WRITE;
-        }
-
-        @Override
-        public void close(boolean expunge) {
-            try {
-                executeSimpleCommand("QUIT");
-            }
-            catch (Exception e) {
-                /*
-                 * QUIT may fail if the connection is already closed. We don't care. It's just
-                 * being friendly.
-                 */
-            }
-            
-            closeIO();
-        }
-        
-        private void closeIO() {
-            try {
-                mIn.close();
-            } catch (Exception e) {
-                /*
-                 * May fail if the connection is already closed.
-                 */
-            }
-            try {
-                mOut.close();
-            } catch (Exception e) {
-                /*
-                 * May fail if the connection is already closed.
-                 */
-            }
-            try {
-                mSocket.close();
-            } catch (Exception e) {
-                /*
-                 * May fail if the connection is already closed.
-                 */
-            }
-            mIn = null;
-            mOut = null;
-            mSocket = null;
-        }
-
-        @Override
-        public String getName() {
-            return mName;
-        }
-
-        @Override
-        public boolean create(FolderType type) throws MessagingException {
-            return false;
-        }
-
-        @Override
-        public boolean exists() throws MessagingException {
-            return mName.equalsIgnoreCase("INBOX");
-        }
-
-        @Override
-        public int getMessageCount() {
-            return mMessageCount;
-        }
-
-        @Override
-        public int getUnreadMessageCount() throws MessagingException {
-            return -1;
-        }
-
-        @Override
-        public Message getMessage(String uid) throws MessagingException {
-            Pop3Message message = mUidToMsgMap.get(uid);
-            if (message == null) {
-                message = new Pop3Message(uid, this);
-            }
-            return message;
-        }
-
-        @Override
-        public Message[] getMessages(int start, int end, MessageRetrievalListener listener)
-                throws MessagingException {
-            if (start < 1 || end < 1 || end < start) {
-                throw new MessagingException(String.format("Invalid message set %d %d",
-                        start, end));
-            }
-            try {
-                indexMsgNums(start, end);
-            } catch (IOException ioe) {
-                throw new MessagingException("getMessages", ioe);
-            }
-            ArrayList<Message> messages = new ArrayList<Message>();
-            int i = 0;
-            for (int msgNum = start; msgNum <= end; msgNum++) {
-                Pop3Message message = mMsgNumToMsgMap.get(msgNum);
-                if (listener != null) {
-                    listener.messageStarted(message.getUid(), i++, (end - start) + 1);
-                }
-                messages.add(message);
-                if (listener != null) {
-                    listener.messageFinished(message, i++, (end - start) + 1);
-                }
-            }
-            return messages.toArray(new Message[messages.size()]);
-        }
-
-        /**
-         * Ensures that the given message set (from start to end inclusive)
-         * has been queried so that uids are available in the local cache.
-         * @param start
-         * @param end
-         * @throws MessagingException
-         * @throws IOException
-         */
-        private void indexMsgNums(int start, int end)
-                throws MessagingException, IOException {
-            int unindexedMessageCount = 0;
-            for (int msgNum = start; msgNum <= end; msgNum++) {
-                if (mMsgNumToMsgMap.get(msgNum) == null) {
-                    unindexedMessageCount++;
-                }
-            }
-            if (unindexedMessageCount == 0) {
-                return;
-            }
-            if (unindexedMessageCount < 50 && mMessageCount > 5000) {
-                /*
-                 * In extreme cases we'll do a UIDL command per message instead of a bulk
-                 * download.
-                 */
-                for (int msgNum = start; msgNum <= end; msgNum++) {
-                    Pop3Message message = mMsgNumToMsgMap.get(msgNum);
-                    if (message == null) {
-                        String response = executeSimpleCommand("UIDL " + msgNum);
-                        int uidIndex = response.lastIndexOf(' ');
-                        String msgUid = response.substring(uidIndex + 1);
-                        message = new Pop3Message(msgUid, this);
-                        indexMessage(msgNum, message);
-                    }
-                }
-            }
-            else {
-                String response = executeSimpleCommand("UIDL");
-                while ((response = readLine()) != null) {
-                    if (response.equals(".")) {
-                        break;
-                    }
-                    String[] uidParts = response.split(" ");
-                    Integer msgNum = Integer.valueOf(uidParts[0]);
-                    String msgUid = uidParts[1];
-                    if (msgNum >= start && msgNum <= end) {
-                        Pop3Message message = mMsgNumToMsgMap.get(msgNum);
-                        if (message == null) {
-                            message = new Pop3Message(msgUid, this);
-                            indexMessage(msgNum, message);
-                        }
-                    }
-                }
-            }
-        }
-
-        private void indexUids(ArrayList<String> uids)
-                throws MessagingException, IOException {
-            HashSet<String> unindexedUids = new HashSet<String>();
-            for (String uid : uids) {
-                if (mUidToMsgMap.get(uid) == null) {
-                  if (Config.LOGD) {
-                    Log.d(Email.LOG_TAG, "Need to index UID " + uid);
-                  }
-                  unindexedUids.add(uid);
-                }
-            }
-            if (unindexedUids.size() == 0) {
-                return;
-            }
-            /*
-             * If we are missing uids in the cache the only sure way to
-             * get them is to do a full UIDL list. A possible optimization
-             * would be trying UIDL for the latest X messages and praying.
-             */
-            String response = executeSimpleCommand("UIDL");
-            while ((response = readLine()) != null) {
-              if (response.equals(".")) {
-                break;
-              }
-              String[] uidParts = response.split(" ");
-              Integer msgNum = Integer.valueOf(uidParts[0]);
-              String msgUid = uidParts[1];
-              if (unindexedUids.contains(msgUid)) {
-                if (Config.LOGD) {
-                  Log.d(Email.LOG_TAG, "Got msgNum " + msgNum + " for UID " + msgUid);
-                }
-
-                Pop3Message message = mUidToMsgMap.get(msgUid);
-                if (message == null) {
-                  message = new Pop3Message(msgUid, this);
-                }
-                indexMessage(msgNum, message);
-              }
-            }
-        }
-
-        private void indexMessage(int msgNum, Pop3Message message) {
-          if (Config.LOGD){
-            Log.d(Email.LOG_TAG, "Adding index for UID " + message.getUid() + " to msgNum " + msgNum);
-          }
-            mMsgNumToMsgMap.put(msgNum, message);
-            mUidToMsgMap.put(message.getUid(), message);
-            mUidToMsgNumMap.put(message.getUid(), msgNum);
-        }
-
-        @Override
-        public Message[] getMessages(MessageRetrievalListener listener) throws MessagingException {
-            throw new UnsupportedOperationException("Pop3: No getMessages");
-        }
-
-        @Override
-        public Message[] getMessages(String[] uids, MessageRetrievalListener listener)
-                throws MessagingException {
-            throw new UnsupportedOperationException("Pop3: No getMessages by uids");
-        }
-
-        /**
-         * Fetch the items contained in the FetchProfile into the given set of
-         * Messages in as efficient a manner as possible.
-         * @param messages
-         * @param fp
-         * @throws MessagingException
-         */
-        public void fetch(Message[] messages, FetchProfile fp, MessageRetrievalListener listener)
-                throws MessagingException {
-            if (messages == null || messages.length == 0) {
-                return;
-            }
-            ArrayList<String> uids = new ArrayList<String>();
-            for (Message message : messages) {
-                uids.add(message.getUid());
-            }
-            try {
-                indexUids(uids);
-            }
-            catch (IOException ioe) {
-                throw new MessagingException("fetch", ioe);
-            }
-            try {
-                if (fp.contains(FetchProfile.Item.ENVELOPE)) {
-                    /*
-                     * We pass the listener only if there are other things to do in the
-                     * FetchProfile. Since fetchEnvelop works in bulk and eveything else
-                     * works one at a time if we let fetchEnvelope send events the
-                     * event would get sent twice.
-                     */
-                    fetchEnvelope(messages, fp.size() == 1 ? listener : null);
-                }
-            }
-            catch (IOException ioe) {
-                throw new MessagingException("fetch", ioe);
-            }
-            for (int i = 0, count = messages.length; i < count; i++) {
-                Message message = messages[i];
-                if (!(message instanceof Pop3Message)) {
-                    throw new MessagingException("Pop3Store.fetch called with non-Pop3 Message");
-                }
-                Pop3Message pop3Message = (Pop3Message)message;
-                try {
-                    if (listener != null && !fp.contains(FetchProfile.Item.ENVELOPE)) {
-                        listener.messageStarted(pop3Message.getUid(), i, count);
-                    }
-                    if (fp.contains(FetchProfile.Item.BODY)) {
-                        fetchBody(pop3Message, -1);
-                    }
-                    else if (fp.contains(FetchProfile.Item.BODY_SANE)) {
-                        /*
-                         * To convert the suggested download size we take the size
-                         * divided by the maximum line size (76).
-                         */
-                        fetchBody(pop3Message,
-                                FETCH_BODY_SANE_SUGGESTED_SIZE / 76);
-                    }
-                    else if (fp.contains(FetchProfile.Item.STRUCTURE)) {
-                        /*
-                         * If the user is requesting STRUCTURE we are required to set the body
-                         * to null since we do not support the function.
-                         */
-                        pop3Message.setBody(null);
-                    }
-                    if (listener != null && !(fp.contains(FetchProfile.Item.ENVELOPE) && fp.size() == 1)) {
-                        listener.messageFinished(message, i, count);
-                    }
-                } catch (IOException ioe) {
-                    throw new MessagingException("Unable to fetch message", ioe);
-                }
-            }
-        }
-
-        private void fetchEnvelope(Message[] messages,
-                MessageRetrievalListener listener)  throws IOException, MessagingException {
-            int unsizedMessages = 0;
-            for (Message message : messages) {
-                if (message.getSize() == -1) {
-                    unsizedMessages++;
-                }
-            }
-            if (unsizedMessages == 0) {
-                return;
-            }
-            if (unsizedMessages < 50 && mMessageCount > 5000) {
-                /*
-                 * In extreme cases we'll do a command per message instead of a bulk request
-                 * to hopefully save some time and bandwidth.
-                 */
-                for (int i = 0, count = messages.length; i < count; i++) {
-                    Message message = messages[i];
-                    if (!(message instanceof Pop3Message)) {
-                        throw new MessagingException("Pop3Store.fetch called with non-Pop3 Message");
-                    }
-                    Pop3Message pop3Message = (Pop3Message)message;
-                    if (listener != null) {
-                        listener.messageStarted(pop3Message.getUid(), i, count);
-                    }
-                    String response = executeSimpleCommand(String.format("LIST %d",
-                            mUidToMsgNumMap.get(pop3Message.getUid())));
-                    String[] listParts = response.split(" ");
-                    int msgNum = Integer.parseInt(listParts[1]);
-                    int msgSize = Integer.parseInt(listParts[2]);
-                    pop3Message.setSize(msgSize);
-                    if (listener != null) {
-                        listener.messageFinished(pop3Message, i, count);
-                    }
-                }
-            }
-            else {
-                HashSet<String> msgUidIndex = new HashSet<String>();
-                for (Message message : messages) {
-                    msgUidIndex.add(message.getUid());
-                }
-                int i = 0, count = messages.length;
-                String response = executeSimpleCommand("LIST");
-                while ((response = readLine()) != null) {
-                    if (response.equals(".")) {
-                        break;
-                    }
-                    String[] listParts = response.split(" ");
-                    int msgNum = Integer.parseInt(listParts[0]);
-                    int msgSize = Integer.parseInt(listParts[1]);
-                    Pop3Message pop3Message = mMsgNumToMsgMap.get(msgNum);
-                    if (pop3Message != null && msgUidIndex.contains(pop3Message.getUid())) {
-                        if (listener != null) {
-                            listener.messageStarted(pop3Message.getUid(), i, count);
-                        }
-                        pop3Message.setSize(msgSize);
-                        if (listener != null) {
-                            listener.messageFinished(pop3Message, i, count);
-                        }
-                        i++;
-                    }
-                }
-            }
-        }
-
-        /**
-         * Fetches the body of the given message, limiting the stored data
-         * to the specified number of lines. If lines is -1 the entire message
-         * is fetched. This is implemented with RETR for lines = -1 or TOP
-         * for any other value. If the server does not support TOP it is
-         * emulated with RETR and extra lines are thrown away.
-         * @param message
-         * @param lines
-         */
-        private void fetchBody(Pop3Message message, int lines)
-                throws IOException, MessagingException {
-            String response = null;
-            if (lines == -1 || !mCapabilities.top) {
-                response = executeSimpleCommand(String.format("RETR %d",
-                        mUidToMsgNumMap.get(message.getUid())));
-            }
-            else {
-                response = executeSimpleCommand(String.format("TOP %d %d",
-                        mUidToMsgNumMap.get(message.getUid()),
-                        lines));
-            }
-            if (response != null)  {
-                try {
-                    message.parse(new Pop3ResponseInputStream(mIn));
-                    if (lines == -1 || !mCapabilities.top) {
-                        message.setFlag(Flag.X_DOWNLOADED_FULL, true);
-                    }
-                }
-                catch (MessagingException me) {
-                    /*
-                     * If we're only downloading headers it's possible
-                     * we'll get a broken MIME message which we're not
-                     * real worried about. If we've downloaded the body
-                     * and can't parse it we need to let the user know.
-                     */
-                    if (lines == -1) {
-                        throw me;
-                    }
-                }
-            }
-        }
-
-        @Override
-        public Flag[] getPermanentFlags() throws MessagingException {
-            return PERMANENT_FLAGS;
-        }
-
-        public void appendMessages(Message[] messages) throws MessagingException {
-        }
-
-        public void delete(boolean recurse) throws MessagingException {
-        }
-        
-        @Override
-        public String getUidFromMessageId(Message message) throws MessagingException
-        {
-        	return null;
-        }
- 
-        public Message[] expunge() throws MessagingException {
-            return null;
-        }
-
-        @Override
-        public void setFlags(Flag[] flags, boolean value)
-        throws MessagingException {
-        	Message[] messages = getMessages(null);
-        	setFlags(messages, flags, value);
-        }
-
-        public void setFlags(Message[] messages, Flag[] flags, boolean value)
-                throws MessagingException {
-            if (!value || !Utility.arrayContains(flags, Flag.DELETED)) {
-                /*
-                 * The only flagging we support is setting the Deleted flag.
-                 */
-                return;
-            }
-            ArrayList<String> uids = new ArrayList<String>();
-            try
-            {
-            	for (Message message : messages)
-            	{
-            		uids.add(message.getUid());
-            	}
-            	
-            	indexUids(uids);
-            }
-            catch (IOException ioe)
-            {
-            	throw new MessagingException("Could not get message number for uid " + uids, ioe);
-            }
-            for (Message message : messages) {
-              
-              Integer msgNum = mUidToMsgNumMap.get(message.getUid());
-              if (msgNum == null)
-              {
-                MessagingException me = new MessagingException("Could not delete message " + message.getUid()
-                    + " because no msgNum found; permanent error");
-                me.setPermanentFailure(true);
-                throw me;
-              }
-              executeSimpleCommand(String.format("DELE %s", msgNum));
-            }
-        }
-
-//        private boolean isRoundTripModeSuggested() {
-//            long roundTripMethodMs =
-//                (uncachedMessageCount * 2 * mLatencyMs);
-//            long bulkMethodMs =
-//                    (mMessageCount * 58) / (mThroughputKbS * 1024 / 8) * 1000;
-//        }
-
-        private String readLine() throws IOException {
-            StringBuffer sb = new StringBuffer();
-            int d = mIn.read();
-            if (d == -1) {
-                throw new IOException("End of stream reached while trying to read line.");
-            }
-            do {
-                if (((char)d) == '\r') {
-                    continue;
-                } else if (((char)d) == '\n') {
-                    break;
-                } else {
-                    sb.append((char)d);
-                }
-            } while ((d = mIn.read()) != -1);
-            String ret = sb.toString();
-            if (Config.LOGD) {
-                if (Email.DEBUG) {
-                    Log.d(Email.LOG_TAG, "<<< " + ret);
-                }
-            }
-            return ret;
-        }
-
-        private void writeLine(String s) throws IOException {
-            if (Config.LOGD) {
-                if (Email.DEBUG) {
-                    Log.d(Email.LOG_TAG, ">>> " + s);
-                }
-            }
-            mOut.write(s.getBytes());
-            mOut.write('\r');
-            mOut.write('\n');
-            mOut.flush();
-        }
-
-        private Pop3Capabilities getCapabilities() throws IOException, MessagingException {
-            Pop3Capabilities capabilities = new Pop3Capabilities();
-            try {
-                String response = executeSimpleCommand("CAPA");
-                while ((response = readLine()) != null) {
-                    if (response.equals(".")) {
-                        break;
-                    }
-                    if (response.equalsIgnoreCase("STLS")){
-                        capabilities.stls = true;
-                    }
-                    else if (response.equalsIgnoreCase("UIDL")) {
-                        capabilities.uidl = true;
-                    }
-                    else if (response.equalsIgnoreCase("PIPELINING")) {
-                        capabilities.pipelining = true;
-                    }
-                    else if (response.equalsIgnoreCase("USER")) {
-                        capabilities.user = true;
-                    }
-                    else if (response.equalsIgnoreCase("TOP")) {
-                        capabilities.top = true;
-                    }
-                }
-            }
-            catch (MessagingException me) {
-                /*
-                 * The server may not support the CAPA command, so we just eat this Exception
-                 * and allow the empty capabilities object to be returned.
-                 */
-            }
-            return capabilities;
-        }
-
-        private String executeSimpleCommand(String command) throws MessagingException {
-            try {
-                open(OpenMode.READ_WRITE);
-                if (Config.LOGV)
-                {
-                	Log.v(Email.LOG_TAG, "POP3: command '" + command + "'");
-                }
-                if (command != null) {
-                    writeLine(command);
-                }
-    
-                String response = readLine();
-                if (Config.LOGV)
-                {
-                	Log.v(Email.LOG_TAG, "POP3: response '" + command + "'");
-                }
-
-                if (response.length() > 1 && response.charAt(0) == '-') {
-                    throw new MessagingException(response);
-                }
-    
-                return response;
-            }
-            catch (MessagingException me)
-            {
-              throw me;
-            }
-            catch (Exception e) {
-                closeIO();
-                throw new MessagingException("Unable to execute POP3 command", e);
-            }
-        }
-
-        @Override
-        public boolean supportsFetchingFlags() {
-            return false;
-        }//isFlagSupported
-
-        @Override
-        public boolean equals(Object o) {
-            if (o instanceof Pop3Folder) {
-                return ((Pop3Folder) o).mName.equals(mName);
-            }
-            return super.equals(o);
-        }
-                
-    }//Pop3Folder
-
-    class Pop3Message extends MimeMessage {
-        public Pop3Message(String uid, Pop3Folder folder) throws MessagingException {
-            mUid = uid;
-            mFolder = folder;
-            mSize = -1;
-            mFlags.add(Flag.X_NO_SEEN_INFO);
-        }
-
-        public void setSize(int size) {
-            mSize = size;
-        }
-
-        protected void parse(InputStream in) throws IOException, MessagingException {
-            super.parse(in);
-        }
-
-        @Override
-        public void setFlag(Flag flag, boolean set) throws MessagingException {
-            super.setFlag(flag, set);
-            mFolder.setFlags(new Message[] { this }, new Flag[] { flag }, set);
-        }
-        
-        @Override
-        public void delete(String trashFolderName) throws MessagingException
-        {
-       // 	try
-       // 	{
-        	// 	Poor POP3 users, we can't copy the message to the Trash folder, but they still want a delete
-        		setFlag(Flag.DELETED, true);
-      //  	}
-//        	catch (MessagingException me)
-//        	{
-//        		Log.w(Email.LOG_TAG, "Could not delete non-existant message", me);
-//        	}
-        }
-    }
-
-    class Pop3Capabilities {
-        public boolean stls;
-        public boolean top;
-        public boolean user;
-        public boolean uidl;
-        public boolean pipelining;
-
-        public String toString() {
-            return String.format("STLS %b, TOP %b, USER %b, UIDL %b, PIPELINING %b",
-                    stls,
-                    top,
-                    user,
-                    uidl,
-                    pipelining);
-        }
-    }
-
-    class Pop3ResponseInputStream extends InputStream {
-        InputStream mIn;
-        boolean mStartOfLine = true;
-        boolean mFinished;
-
-        public Pop3ResponseInputStream(InputStream in) {
-            mIn = in;
-        }
-
-        @Override
-        public int read() throws IOException {
-            if (mFinished) {
-                return -1;
-            }
-            int d = mIn.read();
-            if (mStartOfLine && d == '.') {
-                d = mIn.read();
-                if (d == '\r') {
-                    mFinished = true;
-                    mIn.read();
-                    return -1;
-                }
-            }
-
-            mStartOfLine = (d == '\n');
-
-            return d;
-        }
-    }
-}
Index: src/com/android/email/Account.java
===================================================================
--- src/com/android/email/Account.java	(revision 718)
+++ src/com/android/email/Account.java	(working copy)
@@ -1,782 +0,0 @@
-
-package com.android.email;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.UUID;
-
-import com.android.email.mail.Address;
-import com.android.email.mail.Folder;
-import com.android.email.mail.MessagingException;
-import com.android.email.mail.Store;
-import com.android.email.mail.store.LocalStore;
-import com.android.email.mail.store.LocalStore.LocalFolder;
-
-import android.app.Application;
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.net.Uri;
-import android.util.Log;
-
-/**
- * Account stores all of the settings for a single account defined by the user. It is able to save
- * and delete itself given a Preferences to work with. Each account is defined by a UUID. 
- */
-public class Account implements Serializable {
-    public static final int DELETE_POLICY_NEVER = 0;
-    public static final int DELETE_POLICY_7DAYS = 1;
-    public static final int DELETE_POLICY_ON_DELETE = 2;
-    public static final int DELETE_POLICY_MARK_AS_READ = 3;
-    
-    private static final long serialVersionUID = 2975156672298625121L;
-
-    String mUuid;
-    String mStoreUri;
-    String mLocalStoreUri;
-    String mTransportUri;
-    String mDescription;
-    String mAlwaysBcc;
-    int mAutomaticCheckIntervalMinutes;
-    int mDisplayCount;
-    long mLastAutomaticCheckTime;
-    boolean mNotifyNewMail;
-    String mDraftsFolderName;
-    String mSentFolderName;
-    String mTrashFolderName;
-    String mOutboxFolderName;
-    String mAutoExpandFolderName;
-    FolderMode mFolderDisplayMode;
-    FolderMode mFolderSyncMode;
-    FolderMode mFolderTargetMode;
-    int mAccountNumber;
-    boolean mVibrate;
-    String mRingtoneUri;
-    boolean mNotifySync;
-    HideButtons mHideMessageViewButtons;
-    boolean mIsSignatureBeforeQuotedText;
-    List<Identity> identities;
-
-    public enum FolderMode {
-    	ALL, FIRST_CLASS, FIRST_AND_SECOND_CLASS, NOT_SECOND_CLASS;
-    }
-    
-    public enum HideButtons {
-      NEVER, ALWAYS, KEYBOARD_AVAILABLE;
-    }
-
-    /**
-     * <pre>
-     * 0 Never 
-     * 1 After 7 days 
-     * 2 When I delete from inbox
-     * </pre>
-     */
-    int mDeletePolicy;
-
-    public Account(Context context) {
-        // TODO Change local store path to something readable / recognizable
-        mUuid = UUID.randomUUID().toString();
-        mLocalStoreUri = "local://localhost/" + context.getDatabasePath(mUuid + ".db");
-        mAutomaticCheckIntervalMinutes = -1;
-        mDisplayCount = -1;
-        mAccountNumber = -1;
-        mNotifyNewMail = true;
-        mNotifySync = true;
-        mVibrate = false;
-        mFolderDisplayMode = FolderMode.NOT_SECOND_CLASS;
-        mFolderSyncMode = FolderMode.FIRST_CLASS;
-        mFolderTargetMode = FolderMode.NOT_SECOND_CLASS;
-        mHideMessageViewButtons = HideButtons.NEVER;
-        mRingtoneUri = "content://settings/system/notification_sound";
-        mIsSignatureBeforeQuotedText = false;
-        
-        identities = new ArrayList<Identity>();
-
-        Identity identity = new Identity();
-        identity.setSignature(context.getString(R.string.default_signature));
-        identity.setDescription(context.getString(R.string.default_identity_description));
-        identities.add(identity);
-    }
-
-    public class Identity implements Serializable
-    {
-      String mDescription;
-      String mName;
-      String mEmail;
-      String mSignature;
-      public String getName()
-      {
-        return mName;
-      }
-      public void setName(String name)
-      {
-        mName = name;
-      }
-      public String getEmail()
-      {
-        return mEmail;
-      }
-      public void setEmail(String email)
-      {
-        mEmail = email;
-      }
-      public String getSignature()
-      {
-        return mSignature;
-      }
-      public void setSignature(String signature)
-      {
-        mSignature = signature;
-      }
-      public String getDescription()
-      {
-        return mDescription;
-      }
-      public void setDescription(String description)
-      {
-        mDescription = description;
-      }
-      public String toString()
-      {
-        return "Account.Identity(description=" + mDescription + ", name=" + mName + ", email=" + mEmail + ", signature=" + mSignature; 
-      }
-    }
-
-    Account(Preferences preferences, String uuid) {
-        this.mUuid = uuid;
-        refresh(preferences);
-    }
-    
-    /**
-     * Refresh the account from the stored settings.
-     */
-    public void refresh(Preferences preferences) {
-        mStoreUri = Utility.base64Decode(preferences.getPreferences().getString(mUuid
-                + ".storeUri", null));
-        mLocalStoreUri = preferences.getPreferences().getString(mUuid + ".localStoreUri", null);
-        mTransportUri = Utility.base64Decode(preferences.getPreferences().getString(mUuid
-                + ".transportUri", null));
-        mDescription = preferences.getPreferences().getString(mUuid + ".description", null);
-        mAlwaysBcc = preferences.getPreferences().getString(mUuid + ".alwaysBcc", mAlwaysBcc);
-        mAutomaticCheckIntervalMinutes = preferences.getPreferences().getInt(mUuid
-                + ".automaticCheckIntervalMinutes", -1);
-        mDisplayCount = preferences.getPreferences().getInt(mUuid + ".displayCount", -1);
-        mLastAutomaticCheckTime = preferences.getPreferences().getLong(mUuid
-                + ".lastAutomaticCheckTime", 0);
-        mNotifyNewMail = preferences.getPreferences().getBoolean(mUuid + ".notifyNewMail", 
-                false);
-        mNotifySync = preferences.getPreferences().getBoolean(mUuid + ".notifyMailCheck", 
-																   false);
-        mDeletePolicy = preferences.getPreferences().getInt(mUuid + ".deletePolicy", 0);
-        mDraftsFolderName = preferences.getPreferences().getString(mUuid  + ".draftsFolderName", 
-                "Drafts");
-        mSentFolderName = preferences.getPreferences().getString(mUuid  + ".sentFolderName", 
-                "Sent");
-        mTrashFolderName = preferences.getPreferences().getString(mUuid  + ".trashFolderName", 
-                "Trash");
-        mOutboxFolderName = preferences.getPreferences().getString(mUuid  + ".outboxFolderName", 
-                "Outbox");
-
-        // Between r418 and r431 (version 0.103), folder names were set empty if the Incoming settings were
-        // opened for non-IMAP accounts.  0.103 was never a market release, so perhaps this code
-        // should be deleted sometime soon
-        if (mDraftsFolderName == null || mDraftsFolderName.equals(""))
-        {
-          mDraftsFolderName = "Drafts";
-        }
-        if (mSentFolderName == null || mSentFolderName.equals(""))
-        {
-          mSentFolderName = "Sent";
-        }
-        if (mTrashFolderName == null || mTrashFolderName.equals(""))
-        {
-          mTrashFolderName = "Trash";
-        }
-        if (mOutboxFolderName == null || mOutboxFolderName.equals(""))
-        {
-          mOutboxFolderName = "Outbox";
-        }
-        // End of 0.103 repair
-        
-        mAutoExpandFolderName = preferences.getPreferences().getString(mUuid  + ".autoExpandFolderName", 
-          "INBOX");
-        
-        mAccountNumber = preferences.getPreferences().getInt(mUuid + ".accountNumber", 0);
-        mVibrate = preferences.getPreferences().getBoolean(mUuid + ".vibrate", false);
-
-        try
-        {
-          mHideMessageViewButtons = HideButtons.valueOf(preferences.getPreferences().getString(mUuid + ".hideButtonsEnum", 
-              HideButtons.NEVER.name()));
-        }
-        catch (Exception e)
-        {
-          mHideMessageViewButtons = HideButtons.NEVER;
-        }
-
-        mRingtoneUri = preferences.getPreferences().getString(mUuid  + ".ringtone", 
-                "content://settings/system/notification_sound");
-        try
-        {
-        	mFolderDisplayMode = FolderMode.valueOf(preferences.getPreferences().getString(mUuid  + ".folderDisplayMode", 
-        			FolderMode.NOT_SECOND_CLASS.name()));
-        }
-        catch (Exception e)
-        {
-        	mFolderDisplayMode = FolderMode.NOT_SECOND_CLASS;
-        }
-
-        try
-        {
-        	mFolderSyncMode = FolderMode.valueOf(preferences.getPreferences().getString(mUuid  + ".folderSyncMode", 
-        			FolderMode.FIRST_CLASS.name()));
-        }
-        catch (Exception e)
-        {
-        	mFolderSyncMode = FolderMode.FIRST_CLASS;
-        }
-        
-        try
-        {
-          mFolderTargetMode = FolderMode.valueOf(preferences.getPreferences().getString(mUuid  + ".folderTargetMode", 
-              FolderMode.NOT_SECOND_CLASS.name()));
-        }
-        catch (Exception e)
-        {
-          mFolderTargetMode = FolderMode.NOT_SECOND_CLASS;
-        }
-
-        mIsSignatureBeforeQuotedText = preferences.getPreferences().getBoolean(mUuid  + ".signatureBeforeQuotedText", false);
-        identities = loadIdentities(preferences.getPreferences());
-    }
-
-    private List<Identity> loadIdentities(SharedPreferences prefs)
-    {
-      List<Identity> newIdentities = new ArrayList<Identity>();
-      int ident = 0;
-      boolean gotOne = false;
-      do
-      {
-        gotOne = false;
-        String name = prefs.getString(mUuid + ".name." + ident, null);
-        String email = prefs.getString(mUuid + ".email." + ident, null);
-        String signature = prefs.getString(mUuid + ".signature." + ident, null);
-        String description = prefs.getString(mUuid + ".description." + ident, null);
-        if (email != null)
-        {
-          Identity identity = new Identity();
-          identity.setName(name);
-          identity.setEmail(email);
-          identity.setSignature(signature);
-          identity.setDescription(description);
-          newIdentities.add(identity);
-          gotOne = true;
-        } 
-        ident++;
-      } while (gotOne);
-      
-      if (newIdentities.size() == 0)
-      {
-        String name = prefs.getString(mUuid + ".name", null);
-        String email = prefs.getString(mUuid + ".email", null);
-        String signature = prefs.getString(mUuid + ".signature", null);
-        Identity identity = new Identity();
-        identity.setName(name);
-        identity.setEmail(email);
-        identity.setSignature(signature);
-        identity.setDescription(email);
-        newIdentities.add(identity);
-      }
-      
-      return newIdentities;
-    }
-    
-    private void deleteIdentities(SharedPreferences prefs, SharedPreferences.Editor editor)
-    {
-      int ident = 0;
-      boolean gotOne = false;
-      do
-      {
-        gotOne = false;
-        String email = prefs.getString(mUuid + ".email." + ident, null);
-        if (email != null)
-        {
-          editor.remove(mUuid + ".name." + ident);
-          editor.remove(mUuid + ".email." + ident);
-          editor.remove(mUuid + ".signature." + ident);
-          editor.remove(mUuid + ".description." + ident);
-          gotOne = true;
-        }
-        ident++;
-      } while (gotOne);
-    }
-    
-    private void saveIdentities(SharedPreferences prefs, SharedPreferences.Editor editor)
-    {
-      deleteIdentities(prefs, editor);
-      int ident = 0;
-      
-      for (Identity identity : identities)
-      {
-        editor.putString(mUuid + ".name." + ident, identity.getName());
-        editor.putString(mUuid + ".email." + ident, identity.getEmail());
-        editor.putString(mUuid + ".signature." + ident, identity.getSignature());
-        editor.putString(mUuid + ".description." + ident, identity.getDescription());
-        ident++;
-      }
-    }
-    
-    public List<Identity> getIdentities()
-    {
-      return identities;
-    }
-    
-    public void setIdentities(List<Identity> newIdentities)
-    {
-      identities = newIdentities;
-    }
-
-    public String getUuid() {
-        return mUuid;
-    }
-
-    public String getStoreUri() {
-        return mStoreUri;
-    }
-
-    public void setStoreUri(String storeUri) {
-        this.mStoreUri = storeUri;
-    }
-
-    public String getTransportUri() {
-        return mTransportUri;
-    }
-
-    public void setTransportUri(String transportUri) {
-        this.mTransportUri = transportUri;
-    }
-
-    public String getDescription() {
-        return mDescription;
-    }
-
-    public void setDescription(String description) {
-        this.mDescription = description;
-    }
-
-    public String getName() {
-        return identities.get(0).getName();
-    }
-
-    public void setName(String name) {
-        identities.get(0).setName(name);
-    }
-
-    public String getSignature() {
-        return identities.get(0).getSignature();
-    }
-
-    public void setSignature(String signature) {
-        identities.get(0).setSignature(signature);
-    }
-
-    public String getEmail() {
-        return identities.get(0).getEmail();
-    }
-
-    public void setEmail(String email) {
-        identities.get(0).setEmail(email);
-    }
-
-    public String getAlwaysBcc() {
-        return mAlwaysBcc;
-    }
-
-    public void setAlwaysBcc(String alwaysBcc) {
-        this.mAlwaysBcc = alwaysBcc;
-    }
-
-    public Identity getIdentity(int i)
-    {
-      if (i < identities.size())
-      {
-        return identities.get(i);
-      }
-      return null;
-    }
-    
-    public boolean isVibrate() {
-        return mVibrate;
-    }
-
-    public void setVibrate(boolean vibrate) {
-        mVibrate = vibrate;
-    }
-
-    public String getRingtone() {
-        return mRingtoneUri;
-    }
-
-    public void setRingtone(String ringtoneUri) {
-        mRingtoneUri = ringtoneUri;
-    }
-
-    public void delete(Preferences preferences) {
-        String[] uuids = preferences.getPreferences().getString("accountUuids", "").split(",");
-        StringBuffer sb = new StringBuffer();
-        for (int i = 0, length = uuids.length; i < length; i++) {
-            if (!uuids[i].equals(mUuid)) {
-                if (sb.length() > 0) {
-                    sb.append(',');
-                }
-                sb.append(uuids[i]);
-            }
-        }
-        String accountUuids = sb.toString();
-        SharedPreferences.Editor editor = preferences.getPreferences().edit();
-        editor.putString("accountUuids", accountUuids);
-
-        editor.remove(mUuid + ".storeUri");
-        editor.remove(mUuid + ".localStoreUri");
-        editor.remove(mUuid + ".transportUri");
-        editor.remove(mUuid + ".description");
-        editor.remove(mUuid + ".name");
-        editor.remove(mUuid + ".email");
-        editor.remove(mUuid + ".alwaysBcc");
-        editor.remove(mUuid + ".automaticCheckIntervalMinutes");
-        editor.remove(mUuid + ".lastAutomaticCheckTime");
-        editor.remove(mUuid + ".notifyNewMail");
-        editor.remove(mUuid + ".deletePolicy");
-        editor.remove(mUuid + ".draftsFolderName");
-        editor.remove(mUuid + ".sentFolderName");
-        editor.remove(mUuid + ".trashFolderName");
-        editor.remove(mUuid + ".outboxFolderName");
-        editor.remove(mUuid + ".autoExpandFolderName");
-        editor.remove(mUuid + ".accountNumber");
-        editor.remove(mUuid + ".vibrate");
-        editor.remove(mUuid + ".ringtone");
-        editor.remove(mUuid + ".lastFullSync");
-        editor.remove(mUuid + ".folderDisplayMode");
-        editor.remove(mUuid + ".folderSyncMode");
-        editor.remove(mUuid + ".folderTargetMode");
-        editor.remove(mUuid + ".hideButtonsEnum");
-        editor.remove(mUuid + ".signatureBeforeQuotedText");
-        deleteIdentities(preferences.getPreferences(), editor);
-        editor.commit();
-    }
-
-    public void save(Preferences preferences) {
-      SharedPreferences.Editor editor = preferences.getPreferences().edit();
-
-        if (!preferences.getPreferences().getString("accountUuids", "").contains(mUuid)) {
-            /*
-             * When the account is first created we assign it a unique account number. The
-             * account number will be unique to that account for the lifetime of the account.
-             * So, we get all the existing account numbers, sort them ascending, loop through
-             * the list and check if the number is greater than 1 + the previous number. If so
-             * we use the previous number + 1 as the account number. This refills gaps.
-             * mAccountNumber starts as -1 on a newly created account. It must be -1 for this
-             * algorithm to work.
-             * 
-             * I bet there is a much smarter way to do this. Anyone like to suggest it?
-             */
-            Account[] accounts = preferences.getAccounts();
-            int[] accountNumbers = new int[accounts.length];
-            for (int i = 0; i < accounts.length; i++) {
-                accountNumbers[i] = accounts[i].getAccountNumber();
-            }
-            Arrays.sort(accountNumbers);
-            for (int accountNumber : accountNumbers) {
-                if (accountNumber > mAccountNumber + 1) {
-                    break;
-                }
-                mAccountNumber = accountNumber;
-            }
-            mAccountNumber++;
-            
-            String accountUuids = preferences.getPreferences().getString("accountUuids", "");
-            accountUuids += (accountUuids.length() != 0 ? "," : "") + mUuid;
-            editor.putString("accountUuids", accountUuids);
-        }
-
-        editor.putString(mUuid + ".storeUri", Utility.base64Encode(mStoreUri));
-        editor.putString(mUuid + ".localStoreUri", mLocalStoreUri);
-        editor.putString(mUuid + ".transportUri", Utility.base64Encode(mTransportUri));
-        editor.putString(mUuid + ".description", mDescription);
-        editor.putString(mUuid + ".alwaysBcc", mAlwaysBcc);
-        editor.putInt(mUuid + ".automaticCheckIntervalMinutes", mAutomaticCheckIntervalMinutes);
-        editor.putInt(mUuid + ".displayCount", mDisplayCount);
-        editor.putLong(mUuid + ".lastAutomaticCheckTime", mLastAutomaticCheckTime);
-        editor.putBoolean(mUuid + ".notifyNewMail", mNotifyNewMail);
-        editor.putBoolean(mUuid + ".notifyMailCheck", mNotifySync);
-        editor.putInt(mUuid + ".deletePolicy", mDeletePolicy);
-        editor.putString(mUuid + ".draftsFolderName", mDraftsFolderName);
-        editor.putString(mUuid + ".sentFolderName", mSentFolderName);
-        editor.putString(mUuid + ".trashFolderName", mTrashFolderName);
-        editor.putString(mUuid + ".outboxFolderName", mOutboxFolderName);
-        editor.putString(mUuid + ".autoExpandFolderName", mAutoExpandFolderName);
-        editor.putInt(mUuid + ".accountNumber", mAccountNumber);
-        editor.putBoolean(mUuid + ".vibrate", mVibrate);
-        editor.putString(mUuid + ".hideButtonsEnum", mHideMessageViewButtons.name());
-        editor.putString(mUuid + ".ringtone", mRingtoneUri);
-        editor.putString(mUuid + ".folderDisplayMode", mFolderDisplayMode.name());
-        editor.putString(mUuid + ".folderSyncMode", mFolderSyncMode.name());
-        editor.putString(mUuid + ".folderTargetMode", mFolderTargetMode.name());
-        editor.putBoolean(mUuid + ".signatureBeforeQuotedText", this.mIsSignatureBeforeQuotedText);
-       
-        saveIdentities(preferences.getPreferences(), editor);
-       
-        editor.commit();
-    }
-
-    public String toString() {
-        return mDescription;
-    }
-
-    public Uri getContentUri() {
-        return Uri.parse("content://accounts/" + getUuid());
-    }
-
-    public String getLocalStoreUri() {
-        return mLocalStoreUri;
-    }
-
-    public void setLocalStoreUri(String localStoreUri) {
-        this.mLocalStoreUri = localStoreUri;
-    }
-
-    /**
-     * Returns -1 for never.
-     */
-    public int getAutomaticCheckIntervalMinutes() {
-        return mAutomaticCheckIntervalMinutes;
-    }
-    
-    public int getUnreadMessageCount(Context context, Application application) throws MessagingException
-    {
-    	int unreadMessageCount = 0;
-      LocalStore localStore = (LocalStore) Store.getInstance(
-              getLocalStoreUri(),
-              application);
-    	Account.FolderMode aMode = getFolderDisplayMode();
-    	Preferences prefs = Preferences.getPreferences(context);
-      for (LocalFolder folder : localStore.getPersonalNamespaces())
-      {
-      	folder.refresh(prefs);
-       	Folder.FolderClass fMode = folder.getDisplayClass();
-        
-      	if (folder.getName().equals(getTrashFolderName()) == false &&
-      			folder.getName().equals(getDraftsFolderName()) == false &&
-      			folder.getName().equals(getOutboxFolderName()) == false &&
-      			folder.getName().equals(getSentFolderName()) == false &&
-      			folder.getName().equals(getErrorFolderName()) == false)
-      	{
-      		if (aMode == Account.FolderMode.FIRST_CLASS && 
-        			fMode != Folder.FolderClass.FIRST_CLASS)
-          {
-           	continue;
-          }
-      		if (aMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
-      				fMode != Folder.FolderClass.FIRST_CLASS &&
-      				fMode != Folder.FolderClass.SECOND_CLASS)
-      		{
-      			continue;
-      		}
-          if (aMode == Account.FolderMode.NOT_SECOND_CLASS &&
-              fMode == Folder.FolderClass.SECOND_CLASS)
-          {
-          	continue;
-        	}
-      		unreadMessageCount += folder.getUnreadMessageCount();
-      	}
-      }
-      
-      return unreadMessageCount;
-    	
-    }
-    
-    public boolean isAnIdentity(Address addr)
-    {
-        return findIdentity(addr) != null;
-    }
-    
-    public Identity findIdentity(Address addr)
-    {
-        for (Identity identity : identities)
-        {
-            String email = identity.getEmail();
-          if (email != null && email.equalsIgnoreCase(addr.getAddress()))
-          {
-              return identity;
-          }
-        }
-        return null;
-    }
-
-    public int getDisplayCount() {
-        if (mDisplayCount == -1) {
-            this.mDisplayCount = Email.DEFAULT_VISIBLE_LIMIT;
-        }
-        return mDisplayCount;
-    }
-
-    /**
-     * @param automaticCheckIntervalMinutes or -1 for never.
-     */
-    public void setAutomaticCheckIntervalMinutes(int automaticCheckIntervalMinutes) {
-        this.mAutomaticCheckIntervalMinutes = automaticCheckIntervalMinutes;
-    }
-
-    /**
-     * @param displayCount
-     */
-    public void setDisplayCount(int displayCount) {
-        if (displayCount != -1) {
-            this.mDisplayCount = displayCount;
-        } else {
-            this.mDisplayCount = Email.DEFAULT_VISIBLE_LIMIT;
-        }
-    }
-
-    public long getLastAutomaticCheckTime() {
-        return mLastAutomaticCheckTime;
-    }
-
-    public void setLastAutomaticCheckTime(long lastAutomaticCheckTime) {
-        this.mLastAutomaticCheckTime = lastAutomaticCheckTime;
-    }
-
-    public boolean isNotifyNewMail() {
-        return mNotifyNewMail;
-    }
-
-    public void setNotifyNewMail(boolean notifyNewMail) {
-        this.mNotifyNewMail = notifyNewMail;
-    }
-
-    public int getDeletePolicy() {
-        return mDeletePolicy;
-    }
-
-    public void setDeletePolicy(int deletePolicy) {
-        this.mDeletePolicy = deletePolicy;
-    }
-    
-    public String getDraftsFolderName() {
-        return mDraftsFolderName;
-    }
-
-    public void setDraftsFolderName(String draftsFolderName) {
-        mDraftsFolderName = draftsFolderName;
-    }
-
-    public String getSentFolderName() {
-        return mSentFolderName;
-    }
-    
-    public String getErrorFolderName()
-    {
-    	return Email.ERROR_FOLDER_NAME;
-    }
-
-    public void setSentFolderName(String sentFolderName) {
-        mSentFolderName = sentFolderName;
-    }
-
-    public String getTrashFolderName() {
-        return mTrashFolderName;
-    }
-
-    public void setTrashFolderName(String trashFolderName) {
-        mTrashFolderName = trashFolderName;
-    }
-    
-    public String getOutboxFolderName() {
-        return mOutboxFolderName;
-    }
-
-    public void setOutboxFolderName(String outboxFolderName) {
-        mOutboxFolderName = outboxFolderName;
-    }
-    
-    public String getAutoExpandFolderName() {
-      return mAutoExpandFolderName;
-    }
-
-  public void setAutoExpandFolderName(String autoExpandFolderName) {
-      mAutoExpandFolderName = autoExpandFolderName;
-  }
-    
-    public int getAccountNumber() {
-        return mAccountNumber;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (o instanceof Account) {
-            return ((Account)o).mUuid.equals(mUuid);
-        }
-        return super.equals(o);
-    }
-
-		public FolderMode getFolderDisplayMode()
-		{
-			return mFolderDisplayMode;
-		}
-
-		public void setFolderDisplayMode(FolderMode displayMode)
-		{
-			mFolderDisplayMode = displayMode;
-		}
-		
-		public FolderMode getFolderSyncMode()
-		{
-			return mFolderSyncMode;
-		}
-
-		public void setFolderSyncMode(FolderMode syncMode)
-		{
-			mFolderSyncMode = syncMode;
-		}
-
-    public boolean isShowOngoing()
-    {
-      return mNotifySync;
-    }
-
-    public void setShowOngoing(boolean showOngoing)
-    {
-      this.mNotifySync = showOngoing;
-    }
-
-    public HideButtons getHideMessageViewButtons()
-    {
-      return mHideMessageViewButtons;
-    }
-
-    public void setHideMessageViewButtons(HideButtons hideMessageViewButtons)
-    {
-      mHideMessageViewButtons = hideMessageViewButtons;
-    }
-
-    public FolderMode getFolderTargetMode()
-    {
-      return mFolderTargetMode;
-    }
-
-    public void setFolderTargetMode(FolderMode folderTargetMode)
-    {
-      mFolderTargetMode = folderTargetMode;
-    }
-
-    public boolean isSignatureBeforeQuotedText() {
-        return mIsSignatureBeforeQuotedText;
-    }
-
-    public void setSignatureBeforeQuotedText(boolean mIsSignatureBeforeQuotedText) {
-        this.mIsSignatureBeforeQuotedText = mIsSignatureBeforeQuotedText;
-    }
-
-}
Index: src/com/android/email/K9PreferenceActivity.java
===================================================================
--- src/com/android/email/K9PreferenceActivity.java	(revision 718)
+++ src/com/android/email/K9PreferenceActivity.java	(working copy)
@@ -1,18 +0,0 @@
-package com.android.email;
-
-import com.android.email.Preferences;
-
-import android.preference.PreferenceActivity;
-import android.os.Bundle;
-
-
-
-public class K9PreferenceActivity extends PreferenceActivity {
-    @Override
-    public void onCreate(Bundle icicle) {
-        setTheme(Preferences.getPreferences(this).getTheme());
-        super.onCreate(icicle);
-    }
-
-
-}
Index: src/com/android/email/MessagingController.java
===================================================================
--- src/com/android/email/MessagingController.java	(revision 718)
+++ src/com/android/email/MessagingController.java	(working copy)
@@ -1,3023 +0,0 @@
-
-package com.android.email;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.PrintStream;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.CopyOnWriteArraySet;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import android.app.Application;
-import android.app.Notification;
-import android.app.NotificationManager;
-import android.app.PendingIntent;
-import android.content.Context;
-import android.content.Intent;
-import android.os.PowerManager;
-import android.os.Process;
-import android.os.PowerManager.WakeLock;
-import android.util.Config;
-import android.util.Log;
-
-import com.android.email.activity.FolderList;
-import com.android.email.mail.Address;
-import com.android.email.mail.FetchProfile;
-import com.android.email.mail.Flag;
-import com.android.email.mail.Folder;
-import com.android.email.mail.Message;
-import com.android.email.mail.MessageRetrievalListener;
-import com.android.email.mail.MessagingException;
-import com.android.email.mail.Part;
-import com.android.email.mail.Store;
-import com.android.email.mail.Transport;
-import com.android.email.mail.Folder.FolderType;
-import com.android.email.mail.Folder.OpenMode;
-import com.android.email.mail.internet.MimeMessage;
-import com.android.email.mail.internet.MimeUtility;
-import com.android.email.mail.internet.TextBody;
-import com.android.email.mail.store.LocalStore;
-import com.android.email.mail.store.LocalStore.LocalFolder;
-import com.android.email.mail.store.LocalStore.LocalMessage;
-import com.android.email.mail.store.LocalStore.PendingCommand;
-
-/**
- * Starts a long running (application) Thread that will run through commands
- * that require remote mailbox access. This class is used to serialize and
- * prioritize these commands. Each method that will submit a command requires a
- * MessagingListener instance to be provided. It is expected that that listener
- * has also been added as a registered listener using addListener(). When a
- * command is to be executed, if the listener that was provided with the command
- * is no longer registered the command is skipped. The design idea for the above
- * is that when an Activity starts it registers as a listener. When it is paused
- * it removes itself. Thus, any commands that that activity submitted are
- * removed from the queue once the activity is no longer active.
- */
-public class MessagingController implements Runnable {
-    /**
-     * The maximum message size that we'll consider to be "small". A small message is downloaded
-     * in full immediately instead of in pieces. Anything over this size will be downloaded in
-     * pieces with attachments being left off completely and downloaded on demand.
-     *
-     *
-     * 25k for a "small" message was picked by educated trial and error.
-     * http://answers.google.com/answers/threadview?id=312463 claims that the
-     * average size of an email is 59k, which I feel is too large for our
-     * blind download. The following tests were performed on a download of
-     * 25 random messages.
-     * <pre>
-     * 5k - 61 seconds,
-     * 25k - 51 seconds,
-     * 55k - 53 seconds,
-     * </pre>
-     * So 25k gives good performance and a reasonable data footprint. Sounds good to me.
-     */
-    private static final int MAX_SMALL_MESSAGE_SIZE = Store.FETCH_BODY_SANE_SUGGESTED_SIZE;
-
-    private static final String PENDING_COMMAND_MOVE_OR_COPY = "com.android.email.MessagingController.moveOrCopy";
-    private static final String PENDING_COMMAND_EMPTY_TRASH = "com.android.email.MessagingController.emptyTrash";
-    private static final String PENDING_COMMAND_SET_FLAG = "com.android.email.MessagingController.setFlag";
-    private static final String PENDING_COMMAND_APPEND = "com.android.email.MessagingController.append";
-    private static final String PENDING_COMMAND_MARK_ALL_AS_READ = "com.android.email.MessagingController.markAllAsRead";
-    private static final String PENDING_COMMAND_CLEAR_ALL_PENDING = "com.android.email.MessagingController.clearAllPending";
-
-
-    private static MessagingController inst = null;
-    private BlockingQueue<Command> mCommands = new LinkedBlockingQueue<Command>();
-    private BlockingQueue<Command> backCommands = new LinkedBlockingQueue<Command>();
-
-    private Thread mThread;
-    //private Set<MessagingListener> mListeners = Collections.synchronizedSet(new HashSet<MessagingListener>());
-    private Set<MessagingListener> mListeners = new CopyOnWriteArraySet<MessagingListener>();
-    
-    private HashMap<SORT_TYPE, Boolean> sortAscending = new HashMap<SORT_TYPE, Boolean>();
-    
-    private ConcurrentHashMap<String, AtomicInteger> sendCount = new ConcurrentHashMap<String, AtomicInteger>();
-  
-    public enum SORT_TYPE { 
-      SORT_DATE(R.string.sort_earliest_first, R.string.sort_latest_first, false),
-      SORT_SUBJECT(R.string.sort_subject_alpha, R.string.sort_subject_re_alpha, true), 
-      SORT_SENDER(R.string.sort_sender_alpha, R.string.sort_sender_re_alpha, true), 
-      SORT_UNREAD(R.string.sort_unread_first, R.string.sort_unread_last, true),
-      SORT_FLAGGED(R.string.sort_flagged_first, R.string.sort_flagged_last, true), 
-      SORT_ATTACHMENT(R.string.sort_attach_first, R.string.sort_unattached_first, true);
-      
-      private int ascendingToast;
-      private int descendingToast;
-      private boolean defaultAscending;
-      
-      SORT_TYPE(int ascending, int descending, boolean ndefaultAscending) {
-        ascendingToast = ascending;
-        descendingToast = descending;
-        defaultAscending = ndefaultAscending;
-      }
-      
-      public int getToast(boolean ascending) {
-        if (ascending) {
-          return ascendingToast;
-        }
-        else {
-          return descendingToast;
-        }
-      }
-      public boolean isDefaultAscending() {
-        return defaultAscending;
-      }
-    };
-    private SORT_TYPE sortType = SORT_TYPE.SORT_DATE;
-    
-    private MessagingListener checkMailListener = null;
-    
-    private boolean mBusy;
-    private Application mApplication;
-    
-    // Key is accountUuid:folderName:messageUid   ,   value is unimportant
-    private ConcurrentHashMap<String, String> deletedUids = new ConcurrentHashMap<String, String>();
-    
-    // Key is accountUuid:folderName   ,  value is a long of the highest message UID ever emptied from Trash
-    private ConcurrentHashMap<String, Long> expungedUid = new ConcurrentHashMap<String, Long>();
-
-    
-    private String createMessageKey(Account account, String folder, Message message) {
-      return createMessageKey(account, folder, message.getUid());
-    }
-    
-    private String createMessageKey(Account account, String folder, String uid) {
-      return account.getUuid() + ":" + folder + ":" + uid;
-    }
-    
-    private String createFolderKey(Account account, String folder) {
-      return account.getUuid() + ":" + folder;
-    }
-    
-    private void suppressMessage(Account account, String folder, Message message) {
-      
-      if (account == null || folder == null || message == null) {
-        return;
-      }
-      String messKey = createMessageKey(account, folder, message);
-     // Log.d(Email.LOG_TAG, "Suppressing message with key " + messKey);
-      deletedUids.put(messKey, "true");
-    }
-    
-    private void unsuppressMessage(Account account, String folder, Message message) {
-      if (account == null || folder == null || message == null) {
-        return;
-      }
-      unsuppressMessage(account, folder, message.getUid());
-    }
-    
-    private void unsuppressMessage(Account account, String folder, String uid) {
-      if (account == null || folder == null || uid == null) {
-        return;
-      }
-      String messKey = createMessageKey(account, folder, uid);
-      //Log.d(Email.LOG_TAG, "Unsuppressing message with key " + messKey);
-      deletedUids.remove(messKey);
-    }
-    
-    
-    private boolean isMessageSuppressed(Account account, String folder, Message message) {
-      if (account == null || folder == null || message == null) {
-        return false;
-      }
-      String messKey = createMessageKey(account, folder, message);
-      //Log.d(Email.LOG_TAG, "Checking suppression of message with key " + messKey);
-      if (deletedUids.containsKey(messKey)) {
-        //Log.d(Email.LOG_TAG, "Message with key " + messKey + " is suppressed");
-        return true;
-      }
-      Long expungedUidL = expungedUid.get(createFolderKey(account, folder));
-      if (expungedUidL != null) {
-        long expungedUid = expungedUidL;
-        String messageUidS = message.getUid();
-        try {
-          long messageUid = Long.parseLong(messageUidS);
-          if (messageUid <= expungedUid) {
-            return false;
-          }
-        }
-        catch (NumberFormatException nfe) {
-          // Nothing to do
-        }
-      }
-      return false;
-    }
-    
-    
-    
-    
-    private MessagingController(Application application) {
-        mApplication = application;
-        mThread = new Thread(this);
-        mThread.start();
-    }
-    
-    public void log(String logmess) {
-      Log.d(Email.LOG_TAG, logmess);
-      if (Email.logFile != null) {
-        FileOutputStream fos = null;
-        try {
-          File logFile = new File(Email.logFile);
-          fos = new FileOutputStream(logFile, true);
-          PrintStream ps = new PrintStream(fos);
-          ps.println(new Date() + ":" + Email.LOG_TAG + ":" + logmess);
-          ps.flush();
-          ps.close();
-          fos.flush();
-          fos.close();
-        }
-        catch (Exception e) {
-          Log.e(Email.LOG_TAG, "Unable to log message '" + logmess + "'", e);
-        }
-        finally {
-          if (fos != null) {
-            try {
-              fos.close();
-            }
-            catch (Exception e) {
-              
-            }
-          }
-        }
-      }
-    }
-
-    /**
-     * Gets or creates the singleton instance of MessagingController. Application is used to
-     * provide a Context to classes that need it.
-     * @param application
-     * @return
-     */
-    public synchronized static MessagingController getInstance(Application application) {
-        if (inst == null) {
-            inst = new MessagingController(application);
-        }
-        return inst;
-    }
-
-    public boolean isBusy() {
-        return mBusy;
-    }
-
-    public void run() {
-        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
-        while (true) {
-          String commandDescription = null;
-            try {
-                Command command = mCommands.poll();
-                if (command == null) {
-                	 command = backCommands.poll();
-                }
-                if (command == null) {
-                	command = mCommands.poll(1, TimeUnit.SECONDS);
-                }
-                
-                if (command != null) {
-                  commandDescription = command.description;
-                  Log.d(Email.LOG_TAG, "Running background command '" + command.description + "'");
-                  mBusy = true;
-                  command.runnable.run();
-                  Log.d(Email.LOG_TAG, "Background command '" + command.description + "' completed");
-                  for (MessagingListener l : getListeners()) {
-                      l.controllerCommandCompleted(mCommands.size() > 0);
-                  }
-                  if (command.listener != null && !mListeners.contains(command.listener)) {
-                    command.listener.controllerCommandCompleted(mCommands.size() > 0);
-                  }
-	            }
-            }
-            catch (Exception e) {
-                Log.e(Email.LOG_TAG, "Error running command '" + commandDescription + "'", e);
-            }
-            mBusy = false;
-        }
-    }
-
-    private void put(String description, MessagingListener listener, Runnable runnable) {
-        try {
-            Command command = new Command();
-            command.listener = listener;
-            command.runnable = runnable;
-            command.description = description;
-            mCommands.put(command);
-        }
-        catch (InterruptedException ie) {
-            throw new Error(ie);
-        }
-    }
-    
-    private void putBackground(String description, MessagingListener listener, Runnable runnable) {
-      try {
-          Command command = new Command();
-          command.listener = listener;
-          command.runnable = runnable;
-          command.description = description;
-          backCommands.put(command);
-      }
-      catch (InterruptedException ie) {
-          throw new Error(ie);
-      }
-    }
-
-
-    public void addListener(MessagingListener listener) {
-        mListeners.add(listener);
-    }
-
-    public void removeListener(MessagingListener listener) {
-        mListeners.remove(listener);
-    }
-    
-    public Set<MessagingListener> getListeners() {
-    	return mListeners;
-    }
-
-    /**
-     * Lists folders that are available locally and remotely. This method calls
-     * listFoldersCallback for local folders before it returns, and then for
-     * remote folders at some later point. If there are no local folders
-     * includeRemote is forced by this method. This method should be called from
-     * a Thread as it may take several seconds to list the local folders. 
-     * TODO this needs to cache the remote folder list
-     *
-     * @param account
-     * @param includeRemote
-     * @param listener
-     * @throws MessagingException
-     */
-    public void listFolders( final Account account, boolean refreshRemote, MessagingListener listener) {
-        for (MessagingListener l : getListeners()) {
-            l.listFoldersStarted(account);
-        }
-        if (listener != null) {
-          listener.listFoldersStarted(account);
-        }
-        try {
-            Store localStore = Store.getInstance(account.getLocalStoreUri(), mApplication);
-            Folder[] localFolders = localStore.getPersonalNamespaces();
-
-            if ( refreshRemote || localFolders == null || localFolders.length == 0) {
-                doRefreshRemote(account, listener);
-                return;
-            }
-            for (MessagingListener l : getListeners()) {
-                l.listFolders(account, localFolders);
-            }
-            if (listener != null) {
-              listener.listFolders(account, localFolders);
-            }
-        }
-        catch (Exception e) {
-            for (MessagingListener l : getListeners()) {
-                l.listFoldersFailed(account, e.getMessage());
-            }
-            if (listener != null) {
-              listener.listFoldersFailed(account, e.getMessage());
-            }
-            addErrorMessage(account, e);
-            return;
-        }
-        for (MessagingListener l : getListeners()) {
-                l.listFoldersFinished(account);
-        }
-        if (listener != null) {
-          listener.listFoldersFinished(account);
-        }
-       
-    }
-
-    private void doRefreshRemote (final Account account, MessagingListener listener) {
-            put("doRefreshRemote", listener, new Runnable() {
-                public void run() {
-                    try {
-                        Store store = Store.getInstance(account.getStoreUri(), mApplication);
-
-                        Folder[] remoteFolders = store.getPersonalNamespaces();
-
-                        LocalStore localStore = (LocalStore)Store.getInstance( account.getLocalStoreUri(), mApplication);
-                        HashSet<String> remoteFolderNames = new HashSet<String>();
-                        for (int i = 0, count = remoteFolders.length; i < count; i++) {
-                            LocalFolder localFolder = localStore.getFolder(remoteFolders[i].getName());
-                            if (!localFolder.exists()) {
-                                localFolder.create(FolderType.HOLDS_MESSAGES, account.getDisplayCount());
-                            }
-                            remoteFolderNames.add(remoteFolders[i].getName());
-                        }
-
-                        Folder[] localFolders = localStore.getPersonalNamespaces();
-
-                        /*
-                         * Clear out any folders that are no longer on the remote store.
-                         */
-                        for (Folder localFolder : localFolders) {
-                            String localFolderName = localFolder.getName();
-                            if (localFolderName.equalsIgnoreCase(Email.INBOX) ||
-                                    localFolderName.equals(account.getTrashFolderName()) ||
-                                    localFolderName.equals(account.getOutboxFolderName()) ||
-                                    localFolderName.equals(account.getDraftsFolderName()) ||
-                                    localFolderName.equals(account.getSentFolderName()) ||
-                                    localFolderName.equals(account.getErrorFolderName())) {
-                                continue;
-                            }
-                            if (!remoteFolderNames.contains(localFolder.getName())) {
-                                localFolder.delete(false);
-                            }
-                        }
-
-                        localFolders = localStore.getPersonalNamespaces();
-
-                        for (MessagingListener l : getListeners()) {
-                            l.listFolders(account, localFolders);
-                        }
-                        for (MessagingListener l : getListeners()) {
-                            l.listFoldersFinished(account);
-                        }
-                    }
-                    catch (Exception e) {
-                        for (MessagingListener l : getListeners()) {
-                            l.listFoldersFailed(account, "");
-                        }
-                        addErrorMessage(account, e);
-                    }
-                }
-            });
-    }
-
-
-
-    /**
-     * List the local message store for the given folder. This work is done
-     * synchronously.
-     *
-     * @param account
-     * @param folder
-     * @param listener
-     * @throws MessagingException
-     */
-    public void listLocalMessages(final Account account, final String folder, MessagingListener listener) {
-        for (MessagingListener l : getListeners()) {
-            l.listLocalMessagesStarted(account, folder);
-        }
-
-        try {
-            Store localStore = Store.getInstance(account.getLocalStoreUri(), mApplication);
-            Folder localFolder = localStore.getFolder(folder);
-            localFolder.open(OpenMode.READ_WRITE);
-            Message[] localMessages = localFolder.getMessages(
-                    new MessageRetrievalListener() {
-                  public void messageStarted(String message, int number, int ofTotal) {}
-                  public void messageFinished(Message message, int number, int ofTotal) {
-	              
-		                if (!message.isSet(Flag.DELETED) && isMessageSuppressed(account, folder, message) == false) {
-		                    //messages.add(message);
-		                    for (MessagingListener l : getListeners()) {
-		                        l.listLocalMessagesAddMessage(account, folder, message);
-		                    }
-		                } else {
-		                    for (MessagingListener l : getListeners()) {
-		                        l.listLocalMessagesRemoveMessage(account, folder, message);
-		                    }
-		
-		                } 
-                        }
-                    } 
-                    );
-            ArrayList<Message> messages = new ArrayList<Message>();
-            //for (Message message : localMessages) { } 
-            //for (MessagingListener l : getListeners()) {
-            //    l.listLocalMessages(account, folder, messages.toArray(new Message[0]));
-            //}
-            for (MessagingListener l : getListeners()) {
-                l.listLocalMessagesFinished(account, folder);
-            }
-        }
-        catch (Exception e) {
-            for (MessagingListener l : getListeners()) {
-                l.listLocalMessagesFailed(account, folder, e.getMessage());
-            }
-            addErrorMessage(account, e);
-        }
-    }
-
-    public void loadMoreMessages(Account account, String folder, MessagingListener listener) {
-        try {
-            LocalStore localStore = (LocalStore) Store.getInstance( account.getLocalStoreUri(), mApplication);
-            LocalFolder localFolder = (LocalFolder) localStore.getFolder(folder);
-            localFolder.setVisibleLimit(localFolder.getVisibleLimit() + account.getDisplayCount());
-            synchronizeMailbox(account, folder, listener);
-        }
-        catch (MessagingException me) {
-          addErrorMessage(account, me);
-
-            throw new RuntimeException("Unable to set visible limit on folder", me);
-        }
-    }
-
-    public void resetVisibleLimits(Account[] accounts) {
-        for (Account account : accounts) {
-            try {
-                LocalStore localStore =
-                    (LocalStore) Store.getInstance(account.getLocalStoreUri(), mApplication);
-                localStore.resetVisibleLimits(account.getDisplayCount());
-            }
-            catch (MessagingException e) {
-              addErrorMessage(account, e);
-
-                Log.e(Email.LOG_TAG, "Unable to reset visible limits", e);
-            }
-        }
-    }
-
-    /**
-     * Start background synchronization of the specified folder.
-     * @param account
-     * @param folder
-     * @param listener
-     */
-    public void synchronizeMailbox(final Account account, final String folder, MessagingListener listener) {
-        put("synchronizeMailbox", listener, new Runnable() {
-            public void run() {
-                synchronizeMailboxSynchronous(account, folder);
-            }
-        });
-    }
-
-    /**
-     * Start foreground synchronization of the specified folder. This is generally only called
-     * by synchronizeMailbox.
-     * @param account
-     * @param folder
-     *
-     * TODO Break this method up into smaller chunks.
-     */
-    public void synchronizeMailboxSynchronous(final Account account, final String folder) {
-        /*
-         * We don't ever sync the Outbox.
-         */
-        if (folder.equals(account.getOutboxFolderName())) {
-            return;
-        }
-    	if (account.getErrorFolderName().equals(folder)){
-            return;
-        }
-        String debugLine = "Synchronizing folder " + account.getDescription() + ":" + folder;
-        if (Config.LOGV) {
-            Log.v(Email.LOG_TAG, debugLine);
-        }
-        log(debugLine);
-
-        for (MessagingListener l : getListeners()) {
-            l.synchronizeMailboxStarted(account, folder);
-        }
-        LocalFolder tLocalFolder = null;
-        Exception commandException = null;
-        try {
-            if (Config.LOGV) {
-                Log.v(Email.LOG_TAG, "SYNC: About to process pending commands for folder " +
-                    account.getDescription() + ":" + folder);
-            }
-       		try {
-                processPendingCommandsSynchronous(account);
-       		}
-       		catch (Exception e) {
-                addErrorMessage(account, e);
-
-                Log.e(Email.LOG_TAG, "Failure processing command, but allow message sync attempt", e);
-                commandException = e;
-            }
-
-            /*
-             * Get the message list from the local store and create an index of
-             * the uids within the list.
-             */
-            if (Config.LOGV) {
-                Log.v(Email.LOG_TAG, "SYNC: About to get local folder " + folder);
-            }
-            final LocalStore localStore = (LocalStore) Store.getInstance(account.getLocalStoreUri(), mApplication);
-            tLocalFolder = (LocalFolder) localStore.getFolder(folder);
-            final LocalFolder localFolder = tLocalFolder;
-            localFolder.open(OpenMode.READ_WRITE);
-            Message[] localMessages = localFolder.getMessages(null);
-            HashMap<String, Message> localUidMap = new HashMap<String, Message>();
-            for (Message message : localMessages) {
-                localUidMap.put(message.getUid(), message);
-            }
-
-            if (Config.LOGV) {
-                Log.v(Email.LOG_TAG, "SYNC: About to get remote store for " + folder);
-            }
-
-            Store remoteStore = Store.getInstance(account.getStoreUri(), mApplication);
-            if (Config.LOGV) {
-                Log.v(Email.LOG_TAG, "SYNC: About to get remote folder " + folder);
-            }
-
-            Folder remoteFolder = remoteStore.getFolder(folder);
-
-            /*
-             * If the folder is a "special" folder we need to see if it exists
-             * on the remote server. It if does not exist we'll try to create it. If we
-             * can't create we'll abort. This will happen on every single Pop3 folder as
-             * designed and on Imap folders during error conditions. This allows us
-             * to treat Pop3 and Imap the same in this code.
-             */
-            if (folder.equals(account.getTrashFolderName()) ||
-                folder.equals(account.getSentFolderName()) ||
-                folder.equals(account.getDraftsFolderName())) {
-                if (!remoteFolder.exists()) {
-                    if (!remoteFolder.create(FolderType.HOLDS_MESSAGES)) {
-                        for (MessagingListener l : getListeners()) {
-                            l.synchronizeMailboxFinished(account, folder, 0, 0);
-                        }
-                        Log.i(Email.LOG_TAG, "Done synchronizing folder " + folder);
-                        return;
-                    }
-                }
-            }
-
-            /*
-             * Synchronization process:
-            Open the folder
-            Upload any local messages that are marked as PENDING_UPLOAD (Drafts, Sent, Trash)
-            Get the message count
-            Get the list of the newest Email.DEFAULT_VISIBLE_LIMIT messages
-            getMessages(messageCount - Email.DEFAULT_VISIBLE_LIMIT, messageCount)
-            See if we have each message locally, if not fetch it's flags and envelope
-            Get and update the unread count for the folder
-            Update the remote flags of any messages we have locally with an internal date
-            newer than the remote message.
-            Get the current flags for any messages we have locally but did not just download
-            Update local flags
-            For any message we have locally but not remotely, delete the local message to keep
-            cache clean.
-            Download larger parts of any new messages.
-            (Optional) Download small attachments in the background.
-             */
-
-            /*
-             * Open the remote folder. This pre-loads certain metadata like message count.
-             */
-            if (Config.LOGV) {
-                Log.v(Email.LOG_TAG, "SYNC: About to open remote folder " + folder);
-            }
-            remoteFolder.open(OpenMode.READ_WRITE);
-
-
-            /*
-             * Get the remote message count.
-             */
-            int remoteMessageCount = remoteFolder.getMessageCount();
-
-            int visibleLimit = localFolder.getVisibleLimit();
-
-            Message[] remoteMessageArray = new Message[0];
-            final ArrayList<Message> remoteMessages = new ArrayList<Message>();
-            final ArrayList<Message> unsyncedMessages = new ArrayList<Message>();
-            HashMap<String, Message> remoteUidMap = new HashMap<String, Message>();
-
-            if (Config.LOGV) {
-                Log.v(Email.LOG_TAG, "SYNC: Remote message count for folder " + folder + " is " +
-                    remoteMessageCount);
-            }
-
-            if (remoteMessageCount > 0) {
-                /*
-                 * Message numbers start at 1.
-                 */
-                int remoteStart = Math.max(0, remoteMessageCount - visibleLimit) + 1;
-                int remoteEnd = remoteMessageCount;
-
-                if (Config.LOGV) {
-            			Log.v(Email.LOG_TAG, "SYNC: About to get messages " + remoteStart + " through " + remoteEnd + " for folder " + folder);
-                }
-
-                remoteMessageArray = remoteFolder.getMessages(remoteStart, remoteEnd, null);
-                for (Message thisMess : remoteMessageArray) {
-                    remoteMessages.add(thisMess);
-                    remoteUidMap.put(thisMess.getUid(), thisMess);
-                }
-                if (Config.LOGV) {
-                    Log.v(Email.LOG_TAG, "SYNC: Got " + remoteUidMap.size() + " messages for folder " + folder);
-                }
-                remoteMessageArray = null;
-
-                /*
-                 * Get a list of the messages that are in the remote list but not on the
-                 * local store, or messages that are in the local store but failed to download
-                 * on the last sync. These are the new messages that we will download.
-                 */
-                Iterator<Message> iter = remoteMessages.iterator();
-                while (iter.hasNext()) {
-                    Message message = iter.next();
-                    Message localMessage = localUidMap.get(message.getUid());
-                    if (localMessage == null ||
-                        (!localMessage.isSet(Flag.DELETED) &&
-                        !localMessage.isSet(Flag.X_DOWNLOADED_FULL) &&
-                        !localMessage.isSet(Flag.X_DOWNLOADED_PARTIAL))) {
-                        unsyncedMessages.add(message);
-                        iter.remove();
-                    }
-                }
-            }
-            else if (remoteMessageCount < 0) {
-                throw new Exception("Message count " + remoteMessageCount + " for folder " + folder);
-            }
-
-            /*
-             * A list of messages that were downloaded and which did not have the Seen flag set.
-             * This will serve to indicate the true "new" message count that will be reported to
-             * the user via notification.
-             */
-            final ArrayList<Message> newMessages = new ArrayList<Message>();
-
-            /*
-             * Fetch the flags and envelope only of the new messages. This is intended to get us
-             * critical data as fast as possible, and then we'll fill in the details.
-             */
-            if (unsyncedMessages.size() > 0) {
-
-                /*
-                 * Reverse the order of the messages. Depending on the server this may get us
-                 * fetch results for newest to oldest. If not, no harm done.
-                 */
-                Collections.reverse(unsyncedMessages);
-
-                FetchProfile fp = new FetchProfile();
-                if (remoteFolder.supportsFetchingFlags()) {
-                    fp.add(FetchProfile.Item.FLAGS);
-                }
-                fp.add(FetchProfile.Item.ENVELOPE);
-
-                if (Config.LOGV) {
-                    Log.v(Email.LOG_TAG, "SYNC: About to sync unsynced messages for folder " + folder);
-                }
-
-                remoteFolder.fetch(unsyncedMessages.toArray(new Message[0]), fp,
-                    new MessageRetrievalListener() {
-                        public void messageFinished(Message message, int number, int ofTotal) {
-                            try {
-                                if (!message.isSet(Flag.SEEN)) {
-                                    newMessages.add(message);
-                                }
-
-                                // Store the new message locally
-                                    localFolder.appendMessages(new Message[] {
-                                        message
-                                    });
-
-                                // And include it in the view
-                                if (message.getSubject() != null &&
-                                    message.getFrom() != null) {
-                                    /*
-                                     * We check to make sure that we got something worth
-                                     * showing (subject and from) because some protocols
-                                     * (POP) may not be able to give us headers for
-                                     * ENVELOPE, only size.
-                                     */
-                                      if (isMessageSuppressed(account, folder, message) == false) {
-                                    Log.i(Email.LOG_TAG, "place 2 About to notify listeners that we got a new message "+ account + folder + message.getUid());
-                                        for (MessagingListener l : getListeners()) {
-                                            l.synchronizeMailboxNewMessage(account, folder, localFolder.getMessage(message.getUid()));
-                                        }
-                                    }
-                                }
-
-                            }
-                            catch (Exception e) {
-                                Log.e(Email.LOG_TAG, "Error while storing downloaded message.", e);
-                                addErrorMessage(account, e);
-
-                            }
-                        }
-
-                        public void messageStarted(String uid, int number, int ofTotal) {
-                        }
-                    });
-                if (Config.LOGV) {
-                    Log.v(Email.LOG_TAG, "SYNC: Synced unsynced messages for folder " + folder);
-                }
-
-            }
-
-            /*
-             * Refresh the flags for any messages in the local store that we didn't just
-             * download.
-             */
-            if (remoteFolder.supportsFetchingFlags()) {
-
-                if (Config.LOGV) {
-                    Log.v(Email.LOG_TAG, "SYNC: About to sync remote messages for folder " + folder);
-                }
-
-                FetchProfile fp = new FetchProfile();
-                fp.add(FetchProfile.Item.FLAGS);
-                remoteFolder.fetch(remoteMessages.toArray(new Message[0]), fp, null);
-                for (Message remoteMessage : remoteMessages) {
-                    boolean messageChanged = false;
-                    Message localMessage = localFolder.getMessage(remoteMessage.getUid());
-                    if (localMessage == null || localMessage.isSet(Flag.DELETED)) {
-                        continue;
-                    }
-                  for (Flag flag : new Flag[] { Flag.SEEN, Flag.FLAGGED, Flag.ANSWERED } ) {
-                        if (remoteMessage.isSet(flag) != localMessage.isSet(flag)) {
-                            localMessage.setFlag(flag, remoteMessage.isSet(flag));
-                            messageChanged = true;
-                        }
-                    }
-                  if (messageChanged && isMessageSuppressed(account, folder, localMessage) == false) {
-                        for (MessagingListener l : getListeners()) {
-                            l.synchronizeMailboxNewMessage(account, folder, localMessage);
-                        }
-                    }
-                }
-            }
-            if (Config.LOGV) {
-                Log.v(Email.LOG_TAG, "SYNC: Synced remote messages for folder " + folder);
-            }
-
-
-            /*
-             * Get and store the unread message count.
-             */
-            int remoteUnreadMessageCount = remoteFolder.getUnreadMessageCount();
-            if (remoteUnreadMessageCount == -1) {
-                localFolder.setUnreadMessageCount(localFolder.getUnreadMessageCount() + newMessages.size());
-            }
-            else {
-                localFolder.setUnreadMessageCount(remoteUnreadMessageCount);
-            }
-
-            /*
-             * Remove any messages that are in the local store but no longer on the remote store.
-             */
-            for (Message localMessage : localMessages) {
-                if (remoteUidMap.get(localMessage.getUid()) == null && !localMessage.isSet(Flag.DELETED)) {
-                    localMessage.setFlag(Flag.X_DESTROYED, true);
-                    //		    Log.d(Email.LOG_TAG, "Destroying message " + localMessage.getUid() + " which isn't in the most recent group on server");
-                    for (MessagingListener l : getListeners()) {
-                        l.synchronizeMailboxRemovedMessage(account, folder, localMessage);
-                    }
-                }
-            }
-            localMessages = null;
-
-            /*
-             * Now we download the actual content of messages.
-             */
-            ArrayList<Message> largeMessages = new ArrayList<Message>();
-            ArrayList<Message> smallMessages = new ArrayList<Message>();
-            for (Message message : unsyncedMessages) {
-                if (message.getSize() > (MAX_SMALL_MESSAGE_SIZE)) {
-                    largeMessages.add(message);
-                } else {
-                    smallMessages.add(message);
-                }
-            }
-
-            if (Config.LOGV) {
-                Log.v(Email.LOG_TAG, "SYNC: Have "
-                    + largeMessages.size() + " large messages and "
-                    + smallMessages.size() + " small messages out of "
-                    + unsyncedMessages.size() + " un synced messages "
-                    + " to fetch for folder " + folder);
-            }
-            unsyncedMessages.clear();
-
-
-            /*
-             * Grab the content of the small messages first. This is going to
-             * be very fast and at very worst will be a single up of a few bytes and a single
-             * download of 625k.
-             */
-            FetchProfile fp = new FetchProfile();
-            fp.add(FetchProfile.Item.BODY);
-            if (Config.LOGV) {
-                Log.v(Email.LOG_TAG, "SYNC: Fetching small messages for folder " + folder);
-            }
-
-            remoteFolder.fetch(smallMessages.toArray(new Message[smallMessages.size()]),
-                fp, new MessageRetrievalListener() {
-                public void messageFinished(Message message, int number, int ofTotal) {
-                    try {
-                        // Store the updated message locally
-                        localFolder.appendMessages(new Message[] { message });
-
-                        Message localMessage = localFolder.getMessage(message.getUid());
-
-                        // Set a flag indicating this message has now be fully downloaded
-                        localMessage.setFlag(Flag.X_DOWNLOADED_FULL, true);
-                        if (isMessageSuppressed(account, folder, localMessage) == false)
-                        {
-                            // Update the listener with what we've found
-                            for (MessagingListener l : getListeners()) {
-                                l.synchronizeMailboxNewMessage( account, folder, localMessage);
-                            }
-                        }
-                    }
-                    catch (MessagingException me) {
-                        addErrorMessage(account, me);
-
-                        Log.e(Email.LOG_TAG, "SYNC: fetch small messages", me);
-                    }
-                }
-
-                public void messageStarted(String uid, int number, int ofTotal) {
-                }
-            });
-            if (Config.LOGV) {
-                Log.v(Email.LOG_TAG, "SYNC: Done fetching small messages for folder " + folder);
-            }
-            smallMessages = null;
-
-            /*
-             * Now do the large messages that require more round trips.
-             */
-            fp.clear();
-            fp.add(FetchProfile.Item.STRUCTURE);
-            if (Config.LOGV) {
-                Log.v(Email.LOG_TAG, "SYNC: Fetching large messages for folder " + folder);
-            }
-
-            remoteFolder.fetch(largeMessages.toArray(new Message[largeMessages.size()]), fp, null);
-            for (Message message : largeMessages) {
-                if (message.getBody() == null) {
-                    /*
-                     * The provider was unable to get the structure of the message, so
-                     * we'll download a reasonable portion of the messge and mark it as
-                     * incomplete so the entire thing can be downloaded later if the user
-                     * wishes to download it.
-                     */
-                    fp.clear();
-                    fp.add(FetchProfile.Item.BODY_SANE);
-                    /*
-                     *  TODO a good optimization here would be to make sure that all Stores set
-                     *  the proper size after this fetch and compare the before and after size. If
-                     *  they equal we can mark this SYNCHRONIZED instead of PARTIALLY_SYNCHRONIZED
-                     */
-
-                    remoteFolder.fetch(new Message[] { message }, fp, null);
-                    // Store the updated message locally
-                    localFolder.appendMessages(new Message[] { message });
-
-                    Message localMessage = localFolder.getMessage(message.getUid());
-
-                    /*
-                     * Mark the message as fully downloaded if the message size is smaller than
-                     * the FETCH_BODY_SANE_SUGGESTED_SIZE, otherwise mark as only a partial
-                     * download.  This will prevent the system from downloading the same message 
-                     * twice.
-                     */
-                    if (message.getSize() < Store.FETCH_BODY_SANE_SUGGESTED_SIZE) {
-                        localMessage.setFlag(Flag.X_DOWNLOADED_FULL, true);
-                    } else {
-                        // Set a flag indicating that the message has been partially downloaded and
-                        // is ready for view.
-                        localMessage.setFlag(Flag.X_DOWNLOADED_PARTIAL, true);
-                    }
-                } else {
-                    /*
-                     * We have a structure to deal with, from which
-                     * we can pull down the parts we want to actually store.
-                     * Build a list of parts we are interested in. Text parts will be downloaded
-                     * right now, attachments will be left for later.
-                     */
-
-                    ArrayList<Part> viewables = new ArrayList<Part>();
-                    ArrayList<Part> attachments = new ArrayList<Part>();
-                    MimeUtility.collectParts(message, viewables, attachments);
-
-                    /*
-                     * Now download the parts we're interested in storing.
-                     */
-                    for (Part part : viewables) {
-                        fp.clear();
-                        fp.add(part);
-                        // TODO what happens if the network connection dies? We've got partial
-                        // messages with incorrect status stored.
-                        remoteFolder.fetch(new Message[] { message }, fp, null);
-                    }
-                    // Store the updated message locally
-                    localFolder.appendMessages(new Message[] { message });
-
-                    Message localMessage = localFolder.getMessage(message.getUid());
-
-                    // Set a flag indicating this message has been fully downloaded and can be
-                    // viewed.
-                    localMessage.setFlag(Flag.X_DOWNLOADED_PARTIAL, true);
-                }
-
-                if (isMessageSuppressed(account, folder, message) == false) {
-                    Log.i(Email.LOG_TAG, "About to notify listeners that we got a new message "+ account + folder + message.getUid());
-                    // Update the listener with what we've found
-                    for (MessagingListener l : getListeners()) {
-                        l.synchronizeMailboxNewMessage( account, folder, localFolder.getMessage(message.getUid()));
-                    }
-                }
-            }//for large messsages
-            if (Config.LOGV) {
-                Log.v(Email.LOG_TAG, "SYNC: Done fetching large messages for folder " + folder);
-            }
-            largeMessages = null;
-
-
-            /*
-             * Notify listeners that we're finally done.
-             */
-
-            localFolder.setLastChecked(System.currentTimeMillis());
-            localFolder.setStatus(null);
-
-            remoteFolder.close(false);
-            localFolder.close(false);
-            if (Config.LOGD) {
-            	log( "Done synchronizing folder " +
-                    account.getDescription() + ":" + folder + " @ " + new Date() +
-                    " with " + newMessages.size() + " new messages");
-            }
-
-            for (MessagingListener l : getListeners()) {
-                l.synchronizeMailboxFinished( account, folder, remoteMessageCount, newMessages.size());
-            }
-
-           if (commandException != null) {
-                String rootMessage = getRootCauseMessage(commandException);
-                localFolder.setStatus(rootMessage);
-                for (MessagingListener l : getListeners()) {
-                    l.synchronizeMailboxFailed( account, folder, rootMessage);
-                }
-            }
-
-
-        }
-        catch (Exception e) {
-            Log.e(Email.LOG_TAG, "synchronizeMailbox", e);
-            // If we don't set the last checked, it can try too often during
-            // failure conditions
-            String rootMessage = getRootCauseMessage(e);
-	        	if (tLocalFolder != null)
-	        	{
-	        		try
-	        		{
-                    tLocalFolder.setStatus(rootMessage);
-                    tLocalFolder.setLastChecked(System.currentTimeMillis());
-                    tLocalFolder.close(false);
-	        		}
-	        		catch (MessagingException me)
-	        		{
-                    Log.e(Email.LOG_TAG, "Could not set last checked on folder " + account.getDescription() + ":" +
-                        tLocalFolder.getName(), e);
-                }
-            }
-
-            for (MessagingListener l : getListeners()) {
-                l.synchronizeMailboxFailed(
-                    account,
-                    folder,
-                    rootMessage);
-            }
-            addErrorMessage(account, e);
-            log("Failed synchronizing folder " +
-                account.getDescription() + ":" + folder + " @ " + new Date());
-
-        }
-
-    }
-    
-    private String getRootCauseMessage(Throwable t)
-    {
-    	Throwable rootCause = t;
-    	Throwable nextCause = rootCause;
-    	do
-    	{
-    		nextCause = rootCause.getCause();
-    		if (nextCause != null)
-    		{
-    			rootCause = nextCause;
-    		}
-    	} while (nextCause != null);
-      return rootCause.getMessage();
-    }
-
-    private void queuePendingCommand(Account account, PendingCommand command) {
-        try {
-            LocalStore localStore = (LocalStore) Store.getInstance(
-                    account.getLocalStoreUri(),
-                    mApplication);
-            localStore.addPendingCommand(command);
-        }
-        catch (Exception e) {
-          addErrorMessage(account, e);
-
-            throw new RuntimeException("Unable to enqueue pending command", e);
-        }
-    }
-
-    private void processPendingCommands(final Account account) {
-        put("processPendingCommands", null, new Runnable() {
-            public void run() {
-                try {
-                    processPendingCommandsSynchronous(account);
-                }
-                catch (MessagingException me) {
-                    if (Config.LOGV) {
-                        Log.v(Email.LOG_TAG, "processPendingCommands", me);
-                    }
-                    addErrorMessage(account, me);
-
-                    /*
-                     * Ignore any exceptions from the commands. Commands will be processed
-                     * on the next round.
-                     */
-                }
-            }
-        });
-    }
-
-    private void processPendingCommandsSynchronous(Account account) throws MessagingException {
-        LocalStore localStore = (LocalStore) Store.getInstance(
-                account.getLocalStoreUri(),
-                mApplication);
-        ArrayList<PendingCommand> commands = localStore.getPendingCommands();
-        PendingCommand processingCommand = null;
-        try
-        {
-	        for (PendingCommand command : commands) {
-	        	processingCommand = command;
-	        	Log.d(Email.LOG_TAG, "Processing pending command '" + command + "'");
-	            /*
-	             * We specifically do not catch any exceptions here. If a command fails it is
-	             * most likely due to a server or IO error and it must be retried before any
-	             * other command processes. This maintains the order of the commands.
-	             */
-	        	try
-	        	{
-	            if (PENDING_COMMAND_APPEND.equals(command.command)) {
-	                processPendingAppend(command, account);
-	            }
-	            else if (PENDING_COMMAND_SET_FLAG.equals(command.command)) {
-	                processPendingSetFlag(command, account);
-	            }
-	            else if (PENDING_COMMAND_MARK_ALL_AS_READ.equals(command.command)) {
-                processPendingMarkAllAsRead(command, account);
-	            }
-	            else if (PENDING_COMMAND_MOVE_OR_COPY.equals(command.command)) {
-	                processPendingMoveOrCopy(command, account);
-	            }
-	            else if (PENDING_COMMAND_EMPTY_TRASH.equals(command.command)) {
-                processPendingEmptyTrash(command, account);
-	            }
-	            localStore.removePendingCommand(command);
-	            Log.d(Email.LOG_TAG, "Done processing pending command '" + command + "'");
-	        	}
-	        	catch (MessagingException me)
-	        	{
-	        	  if (me.isPermanentFailure())
-	            {
-	        	    Log.e(Email.LOG_TAG, "Failure of command '" + command + "' was permanent, removing command from queue");
-	              localStore.removePendingCommand(processingCommand);
-	            }
-  	        	else
-  	        	{
-  	        	  throw me;
-  	        	}
-	        	}
-	        }
-        }
-        catch (MessagingException me)
-        {
-          addErrorMessage(account, me);
-        	Log.e(Email.LOG_TAG, "Could not process command '" + processingCommand + "'", me);
-        	throw me;
-        }
-    }
-
-    /**
-     * Process a pending append message command. This command uploads a local message to the
-     * server, first checking to be sure that the server message is not newer than
-     * the local message. Once the local message is successfully processed it is deleted so
-     * that the server message will be synchronized down without an additional copy being
-     * created.
-     * TODO update the local message UID instead of deleteing it
-     *
-     * @param command arguments = (String folder, String uid)
-     * @param account
-     * @throws MessagingException
-     */
-    private void processPendingAppend(PendingCommand command, Account account)
-            throws MessagingException {
-    	
-    	
-        String folder = command.arguments[0];
-        String uid = command.arguments[1];
-
-        if (account.getErrorFolderName().equals(folder))
-    		{
-    			return;
-    		}
-
-        LocalStore localStore = (LocalStore) Store.getInstance(
-                account.getLocalStoreUri(),
-                mApplication);
-        LocalFolder localFolder = (LocalFolder) localStore.getFolder(folder);
-        LocalMessage localMessage = (LocalMessage) localFolder.getMessage(uid);
-
-        if (localMessage == null) {
-            return;
-        }
-        
-        Store remoteStore = Store.getInstance(account.getStoreUri(), mApplication);
-        Folder remoteFolder = remoteStore.getFolder(folder);
-        if (!remoteFolder.exists()) {
-            if (!remoteFolder.create(FolderType.HOLDS_MESSAGES)) {
-                return;
-            }
-        }
-        remoteFolder.open(OpenMode.READ_WRITE);
-        if (remoteFolder.getMode() != OpenMode.READ_WRITE) {
-            return;
-        }
-
-        Message remoteMessage = null;
-        if (!localMessage.getUid().startsWith(Email.LOCAL_UID_PREFIX)) {
-            remoteMessage = remoteFolder.getMessage(localMessage.getUid());
-        }
-
-        if (remoteMessage == null) {
-        		if (localMessage.isSet(Flag.X_REMOTE_COPY_STARTED))
-        		{
-         			Log.w(Email.LOG_TAG, "Local message with uid " + localMessage.getUid() + 
-          				" has flag " + Flag.X_REMOTE_COPY_STARTED + " already set, checking for remote message with " +
-          				" same message id");
-        			String rUid = remoteFolder.getUidFromMessageId(localMessage);
-        			if (rUid != null)
-        			{
-	        			Log.w(Email.LOG_TAG, "Local message has flag " + Flag.X_REMOTE_COPY_STARTED + " already set, and there is a remote message with " +
-	          				" uid " + rUid + ", assuming message was already copied and aborting this copy");
-	        			
-	        			String oldUid = localMessage.getUid();
-	        			localMessage.setUid(rUid);
-	        			localFolder.changeUid(localMessage);
-	        			for (MessagingListener l : getListeners()) {
-	                l.messageUidChanged(account, folder, oldUid, localMessage.getUid());
-	        			}
-	        			return;
-        			}
-        			else
-        			{
-        				Log.w(Email.LOG_TAG, "No remote message with message-id found, proceeding with append");
-        			}
-        		}
-
-            /*
-             * If the message does not exist remotely we just upload it and then
-             * update our local copy with the new uid.
-             */
-            FetchProfile fp = new FetchProfile();
-            fp.add(FetchProfile.Item.BODY);
-            localFolder.fetch(new Message[] { localMessage }, fp, null);
-            String oldUid = localMessage.getUid();
-            localMessage.setFlag(Flag.X_REMOTE_COPY_STARTED, true);
-            remoteFolder.appendMessages(new Message[] { localMessage });
-             
-            localFolder.changeUid(localMessage);
-            for (MessagingListener l : getListeners()) {
-                l.messageUidChanged(account, folder, oldUid, localMessage.getUid());
-            }
-        }
-        else {
-            /*
-             * If the remote message exists we need to determine which copy to keep.
-             */
-            /*
-             * See if the remote message is newer than ours.
-             */
-            FetchProfile fp = new FetchProfile();
-            fp.add(FetchProfile.Item.ENVELOPE);
-            remoteFolder.fetch(new Message[] { remoteMessage }, fp, null);
-            Date localDate = localMessage.getInternalDate();
-            Date remoteDate = remoteMessage.getInternalDate();
-            if (remoteDate.compareTo(localDate) > 0) {
-                /*
-                 * If the remote message is newer than ours we'll just
-                 * delete ours and move on. A sync will get the server message
-                 * if we need to be able to see it.
-                 */
-                localMessage.setFlag(Flag.DELETED, true);
-            }
-            else {
-                /*
-                 * Otherwise we'll upload our message and then delete the remote message.
-                 */
-                fp.clear();
-                fp = new FetchProfile();
-                fp.add(FetchProfile.Item.BODY);
-                localFolder.fetch(new Message[] { localMessage }, fp, null);
-                String oldUid = localMessage.getUid();
-
-                localMessage.setFlag(Flag.X_REMOTE_COPY_STARTED, true);
-
-                remoteFolder.appendMessages(new Message[] { localMessage });
-                localFolder.changeUid(localMessage);
-                for (MessagingListener l : getListeners()) {
-                    l.messageUidChanged(account, folder, oldUid, localMessage.getUid());
-                }
-                remoteMessage.setFlag(Flag.DELETED, true);
-                remoteFolder.expunge();
-            }
-        }
-    }
-
-    /**
-     * Process a pending trash message command.
-     *
-     * @param command arguments = (String folder, String uid)
-     * @param account
-     * @throws MessagingException
-     */
-    private void processPendingMoveOrCopy(PendingCommand command, Account account)
-            throws MessagingException {
-        String srcFolder = command.arguments[0];
-        String uid = command.arguments[1];
-        String destFolder = command.arguments[2];
-        String isCopyS = command.arguments[3];
-        
-        boolean isCopy = false;
-        if (isCopyS != null)
-        {
-          isCopy = Boolean.parseBoolean(isCopyS);
-        }
-
-        if (account.getErrorFolderName().equals(srcFolder))
-    		{
-    			return;
-    		}
-
-        Store remoteStore = Store.getInstance(account.getStoreUri(), mApplication);
-        Folder remoteSrcFolder = remoteStore.getFolder(srcFolder);
-        Folder remoteDestFolder = remoteStore.getFolder(destFolder);
-        
-        if (!remoteSrcFolder.exists()) {
-        	Log.w(Email.LOG_TAG, "processingPendingMoveOrCopy: remoteFolder " + srcFolder + " does not exist");
-            return;
-        }
-        remoteSrcFolder.open(OpenMode.READ_WRITE);
-        if (remoteSrcFolder.getMode() != OpenMode.READ_WRITE) {
-         	Log.w(Email.LOG_TAG, "processingPendingMoveOrCopy: could not open remoteSrcFolder " + srcFolder + " read/write");
-            return;
-        }
- 
-        Message remoteMessage = null;
-        if (!uid.startsWith(Email.LOCAL_UID_PREFIX)) {
-       // Why bother with this, perhaps just pass the UID to the store to save a roundtrip?  And check for error returns, of course
-       // Same applies for deletion
-            remoteMessage = remoteSrcFolder.getMessage(uid);      
-        }
-        if (remoteMessage == null) {
-            Log.w(Email.LOG_TAG, "processingPendingMoveOrCopy: remoteMessage " + uid + " does not exist");
-            return;
-        }
-        
-        if (Config.LOGD)
-        {
-          Log.d(Email.LOG_TAG, "processingPendingMoveOrCopy: source folder = " + srcFolder 
-              + ", uid = " + uid + ", destination folder = " + destFolder + ", isCopy = " + isCopy);
-        }
-        if (isCopy == false && destFolder.equals(account.getTrashFolderName()))
-        {
-          Log.d(Email.LOG_TAG, "processingPendingMoveOrCopy doing special case for deleting message");
-          remoteMessage.delete(account.getTrashFolderName());
-          remoteSrcFolder.close(true);
-          return;
-        }
-
-        remoteDestFolder.open(OpenMode.READ_WRITE);
-        if (remoteDestFolder.getMode() != OpenMode.READ_WRITE) {
-          Log.w(Email.LOG_TAG, "processingPendingMoveOrCopy: could not open remoteDestFolder " + srcFolder + " read/write");
-            return;
-        }
-        
-        if (isCopy) {
-          remoteSrcFolder.copyMessages(new Message[] { remoteMessage }, remoteDestFolder);
-        }
-        else {
-          remoteSrcFolder.moveMessages(new Message[] { remoteMessage }, remoteDestFolder);
-        }
-        remoteSrcFolder.close(true);
-        remoteDestFolder.close(true);
-        
- 
-    }
-
-    /**
-     * Processes a pending mark read or unread command.
-     *
-     * @param command arguments = (String folder, String uid, boolean read)
-     * @param account
-     */
-    private void processPendingSetFlag(PendingCommand command, Account account)
-            throws MessagingException {
-        String folder = command.arguments[0];
-        String uid = command.arguments[1];
-        
-        if (account.getErrorFolderName().equals(folder))
-    		{
-    			return;
-    		}
-        
-        boolean newState = Boolean.parseBoolean(command.arguments[2]);
-        
-        Flag flag = Flag.valueOf(command.arguments[3]);
-
-        Store remoteStore = Store.getInstance(account.getStoreUri(), mApplication);
-        Folder remoteFolder = remoteStore.getFolder(folder);
-        if (!remoteFolder.exists()) {
-            return;
-        }
-        remoteFolder.open(OpenMode.READ_WRITE);
-        if (remoteFolder.getMode() != OpenMode.READ_WRITE) {
-            return;
-        }
-        Message remoteMessage = null;
-        if (!uid.startsWith(Email.LOCAL_UID_PREFIX)) {
-            remoteMessage = remoteFolder.getMessage(uid);
-        }
-        if (remoteMessage == null) {
-            return;
-        }
-        remoteMessage.setFlag(flag, newState);
-    }
-    
-    private void processPendingMarkAllAsRead(PendingCommand command, Account account) throws MessagingException {
-        String folder = command.arguments[0];
-
-        Store localStore = Store.getInstance(account.getLocalStoreUri(), mApplication);
-        LocalFolder localFolder = (LocalFolder) localStore.getFolder(folder);
-        localFolder.open(OpenMode.READ_WRITE);
-        Message[] messages = localFolder.getMessages(null);
-        for (Message message : messages) {
-            if (message.isSet(Flag.SEEN) == false) {
-                message.setFlag(Flag.SEEN, true);
-                for (MessagingListener l : getListeners()) {
-                    l.listLocalMessagesUpdateMessage(account, folder, message);
-                }
-            }
-        }
-        localFolder.setUnreadMessageCount(0);
-        for (MessagingListener l : getListeners()) {
-            l.folderStatusChanged(account, folder);
-        }
-        try {
-            if (account.getErrorFolderName().equals(folder)) {
-                return;
-            }
-
-            Store remoteStore = Store.getInstance(account.getStoreUri(), mApplication);
-            Folder remoteFolder = remoteStore.getFolder(folder);
-
-            if (!remoteFolder.exists()) {
-                return;
-            }
-            remoteFolder.open(OpenMode.READ_WRITE);
-            if (remoteFolder.getMode() != OpenMode.READ_WRITE) {
-                return;
-            }
-
-            remoteFolder.setFlags(new Flag[]{Flag.SEEN}, true);
-            remoteFolder.close(false);
-        }
-        catch (UnsupportedOperationException uoe) {
-            Log.w(Email.LOG_TAG, "Could not mark all server-side as read because store doesn't support operation", uoe);
-        }
-        finally {
-            localFolder.close(false);
-        }
-    }
-
-    static long uidfill = 0;
-    static AtomicBoolean loopCatch = new AtomicBoolean();
-    public void addErrorMessage(Account account, Throwable t)
-    {
-      if (Email.ENABLE_ERROR_FOLDER == false)
-      {
-        return;
-      }
-    	if (loopCatch.compareAndSet(false, true) == false)
-    	{
-    		return;
-    	}
-    	try
-    	{
-	    	if (t == null)
-	    	{
-	    		return;
-	    	}
-
-	    	String rootCauseMessage = getRootCauseMessage(t);
-	    	log("Error" + "'" + rootCauseMessage + "'");
-	    	
-    		Store localStore = Store.getInstance(account.getLocalStoreUri(), mApplication);
-    		LocalFolder localFolder = (LocalFolder)localStore.getFolder(account.getErrorFolderName());
-    		Message[] messages = new Message[1];
-    		Message message = new MimeMessage();
-    		ByteArrayOutputStream baos = new ByteArrayOutputStream();
-    		PrintStream ps = new PrintStream(baos);
-    		t.printStackTrace(ps);
-    		ps.close();
-    		message.setBody(new TextBody(baos.toString()));
-    		message.setFlag(Flag.X_DOWNLOADED_FULL, true);
-    		message.setSubject(rootCauseMessage);
-    		
-    		long nowTime = System.currentTimeMillis();
-    		Date nowDate = new Date(nowTime);
-    		message.setInternalDate(nowDate);
-    		message.setSentDate(nowDate);
-    		message.setFrom(new Address(account.getEmail(), "K9mail internal"));
-    		messages[0] = message;
-    		
-    		localFolder.appendMessages(messages);
-    		
-    		localFolder.deleteMessagesOlderThan(nowTime - (15 * 60 * 1000));
-    		
-    	}
-    	catch (Throwable it)
-    	{
-    			Log.e(Email.LOG_TAG, "Could not save error message to " + account.getErrorFolderName(), it);
-    	}
-    	finally
-    	{
-    		loopCatch.set(false);
-    	}
-    }
-    
-    public void addErrorMessage(Account account, String subject, String body)
-    {
-      if (Email.ENABLE_ERROR_FOLDER == false)
-      {
-        return;
-      }
-      if (loopCatch.compareAndSet(false, true) == false)
-      {
-        return;
-      }
-      try
-      {
-        if (body == null || body.length() < 1)
-        {
-          return;
-        }
-        
-        Store localStore = Store.getInstance(account.getLocalStoreUri(), mApplication);
-        LocalFolder localFolder = (LocalFolder)localStore.getFolder(account.getErrorFolderName());
-        Message[] messages = new Message[1];
-        Message message = new MimeMessage();
-        
-
-        message.setBody(new TextBody(body));
-        message.setFlag(Flag.X_DOWNLOADED_FULL, true);
-        message.setSubject(subject);
-        
-        long nowTime = System.currentTimeMillis();
-        Date nowDate = new Date(nowTime);
-        message.setInternalDate(nowDate);
-        message.setSentDate(nowDate);
-        message.setFrom(new Address(account.getEmail(), "K9mail internal"));
-        messages[0] = message;
-        
-        localFolder.appendMessages(messages);
-        
-        localFolder.deleteMessagesOlderThan(nowTime - (15 * 60 * 1000));
-        
-      }
-      catch (Throwable it)
-      {
-          Log.e(Email.LOG_TAG, "Could not save error message to " + account.getErrorFolderName(), it);
-      }
-      finally
-      {
-        loopCatch.set(false);
-      }
-    }
-    
-    
-    
-    public void markAllMessagesRead(final Account account, final String folder)
-    {
-    	Log.v(Email.LOG_TAG, "Marking all messages in " + account.getDescription() + ":" + folder + " as read");
-      List<String> args = new ArrayList<String>();
-      args.add(folder);
-      PendingCommand command = new PendingCommand();
-      command.command = PENDING_COMMAND_MARK_ALL_AS_READ;
-      command.arguments = args.toArray(new String[0]);
-      queuePendingCommand(account, command);
-      processPendingCommands(account);
-    }
-    
-
-    
-    
-    
-    /**
-     * Mark the message with the given account, folder and uid either Seen or not Seen.
-     * @param account
-     * @param folder
-     * @param uid
-     * @param seen
-     */
-    public void markMessageRead(
-            final Account account,
-            final String folder,
-            final String uid,
-            final boolean seen) {
-      setMessageFlag(account, folder, uid, Flag.SEEN, seen);
-    }
-    
-    /**
-     * Mark the message with the given account, folder and uid either Seen or not Seen.
-     * @param account
-     * @param folder
-     * @param uid
-     * @param seen
-     */
-    public void markMessageRead(
-            final Account account,
-            final Folder folder,
-            final Message message,
-            final boolean seen) {
-      setMessageFlag(account, folder, message, Flag.SEEN, seen);
-    }
-    
-    public void setMessageFlag(
-        final Account account,
-        final String folder,
-        final String uid,
-        final Flag flag,
-        final boolean newState) {
-      // TODO: put this into the background, but right now that causes odd behavior
-      // because the MessageList doesn't have its own cache of the flag states
-        try {
-            Store localStore = Store.getInstance(account.getLocalStoreUri(), mApplication);
-            Folder localFolder = localStore.getFolder(folder);
-            localFolder.open(OpenMode.READ_WRITE);
-
-            Message message = localFolder.getMessage(uid);
-
-            setMessageFlag(account, localFolder, message, flag, newState);
-
-            localFolder.close(false);
-        }
-        catch (MessagingException me) {
-          addErrorMessage(account, me);
-
-            throw new RuntimeException(me);
-        }
-    }
-
-    public void setMessageFlag(
-        final Account account,
-        final Folder folder,
-        final Message message,
-        final Flag flag,
-        final boolean newState) {
-      // TODO: put this into the background, but right now that causes odd behavior
-      // because the FolderMessageList doesn't have its own cache of the flag states
-        try {
-            String uid = message.getUid();
-            String folderName = folder.getName();
-            
-            message.setFlag(flag, newState);
-
-            // Allows for re-allowing sending of messages that could not be sent
-            if (flag == Flag.FLAGGED && newState == false
-                && uid != null
-                && account.getOutboxFolderName().equals(folderName))
-            {
-              sendCount.remove(uid);
-            }
-
-            for (MessagingListener l : getListeners()) {
-              l.folderStatusChanged(account, folderName);
-          }
-
-            if (account.getErrorFolderName().equals(folderName))
-        		{
-        			return;
-        		}
-
-            PendingCommand command = new PendingCommand();
-            command.command = PENDING_COMMAND_SET_FLAG;
-            command.arguments = new String[] { folderName, uid, Boolean.toString(newState), flag.toString() };
-            queuePendingCommand(account, command);
-            processPendingCommands(account);
-        }
-        catch (MessagingException me) {
-          addErrorMessage(account, me);
-
-            throw new RuntimeException(me);
-        }
-    }//setMesssageFlag
-
-    public void clearAllPending(final Account account) 
-    {
-    	try
-    	{
-    		Log.w(Email.LOG_TAG, "Clearing pending commands!");
-    		LocalStore localStore = (LocalStore)Store.getInstance(account.getLocalStoreUri(), mApplication);
-    		localStore.removePendingCommands();
-    	}
-    	catch (MessagingException me)
-    	{
-    			Log.e(Email.LOG_TAG, "Unable to clear pending command", me);
-    			addErrorMessage(account, me);
-    	}
-    }
-
-    private void loadMessageForViewRemote(final Account account, final String folder,
-            final String uid, MessagingListener listener) {
-        put("loadMessageForViewRemote", listener, new Runnable() {
-            public void run() {
-                Folder remoteFolder = null;
-                LocalFolder localFolder = null;
-                try {
-                    Store localStore = Store.getInstance(account.getLocalStoreUri(), mApplication);
-                    localFolder = (LocalFolder) localStore.getFolder(folder);
-                    localFolder.open(OpenMode.READ_WRITE);
-
-                    Message message = localFolder.getMessage(uid);
-
-                    if (message.isSet(Flag.X_DOWNLOADED_FULL)) {
-                        /*
-                         * If the message has been synchronized since we were called we'll
-                         * just hand it back cause it's ready to go.
-                         */
-                        FetchProfile fp = new FetchProfile();
-                        fp.add(FetchProfile.Item.ENVELOPE);
-                        fp.add(FetchProfile.Item.BODY);
-                        localFolder.fetch(new Message[] { message }, fp, null);
-                    }
-                    else {
-                        /*
-                         * At this point the message is not available, so we need to download it
-                         * fully if possible.
-                         */
-
-                        Store remoteStore = Store.getInstance(account.getStoreUri(), mApplication);
-                        remoteFolder = remoteStore.getFolder(folder);
-                        remoteFolder.open(OpenMode.READ_WRITE);
-
-                        // Get the remote message and fully download it
-                        Message remoteMessage = remoteFolder.getMessage(uid);
-                        FetchProfile fp = new FetchProfile();
-                        fp.add(FetchProfile.Item.BODY);
-                        remoteFolder.fetch(new Message[] { remoteMessage }, fp, null);
-
-                        // Store the message locally and load the stored message into memory
-                        localFolder.appendMessages(new Message[] { remoteMessage });
-                        message = localFolder.getMessage(uid);
-                        localFolder.fetch(new Message[] { message }, fp, null);
-
-                        // Mark that this message is now fully synched
-                        message.setFlag(Flag.X_DOWNLOADED_FULL, true);
-                    }
-
-                    // This is a view message request, so mark it read
-                    if (!message.isSet(Flag.SEEN)) {
-                        markMessageRead(account, localFolder, message, true);
-                    }
-
-                    for (MessagingListener l : getListeners()) {
-                        l.loadMessageForViewBodyAvailable(account, folder, uid, message);
-                    }
-                    for (MessagingListener l : getListeners()) {
-                        l.loadMessageForViewFinished(account, folder, uid, message);
-                    }
-                }
-                catch (Exception e) {
-                    for (MessagingListener l : getListeners()) {
-                        l.loadMessageForViewFailed(account, folder, uid, e.getMessage());
-                    }
-                    addErrorMessage(account, e);
-
-                }
-                finally {
-                    if (remoteFolder!=null) {
-                        try {
-                            remoteFolder.close(false);
-                        }
-                        catch (MessagingException e) {
-                            Log.w(Email.LOG_TAG, null, e);
-                        }
-                    }
-
-                    if (localFolder!=null) {
-                        try {
-                            localFolder.close(false);
-                        }
-                        catch (MessagingException e) {
-                            Log.w(Email.LOG_TAG, null, e);
-                        }
-                    }
-                }//finally
-            }//run
-        });
-    }
-
-    public void loadMessageForView(final Account account, final String folder, final String uid,
-            MessagingListener listener) {
-        for (MessagingListener l : getListeners()) {
-            l.loadMessageForViewStarted(account, folder, uid);
-        }
-        try {
-            Store localStore = Store.getInstance(account.getLocalStoreUri(), mApplication);
-            LocalFolder localFolder = (LocalFolder) localStore.getFolder(folder);
-            localFolder.open(OpenMode.READ_WRITE);
-
-            Message message = localFolder.getMessage(uid);
-                        
-            for (MessagingListener l : getListeners()) {
-                l.loadMessageForViewHeadersAvailable(account, folder, uid, message);
-            }
-            
-            if (!message.isSet(Flag.X_DOWNLOADED_FULL)) {
-                loadMessageForViewRemote(account, folder, uid, listener);
-                localFolder.close(false);
-                return;
-            }
-
-            FetchProfile fp = new FetchProfile();
-            fp.add(FetchProfile.Item.ENVELOPE);
-            fp.add(FetchProfile.Item.BODY);
-            localFolder.fetch(new Message[] {
-                message
-            }, fp, null);
-
-            if (!message.isSet(Flag.SEEN)) {
-              markMessageRead(account, localFolder, message, true);
-            }
-
-            for (MessagingListener l : getListeners()) {
-                l.loadMessageForViewBodyAvailable(account, folder, uid, message);
-            }
-            if (listener != null)
-            {
-            	listener.loadMessageForViewBodyAvailable(account, folder, uid, message);
-            }
-
-            for (MessagingListener l : getListeners()) {
-                l.loadMessageForViewFinished(account, folder, uid, message);
-            }
-            if (listener != null)
-            {
-            	listener.loadMessageForViewFinished(account, folder, uid, message);
-            }
-            localFolder.close(false);
-        }
-        catch (Exception e) {
-            for (MessagingListener l : getListeners()) {
-                l.loadMessageForViewFailed(account, folder, uid, e.getMessage());
-            }
-            addErrorMessage(account, e);
-
-        }
-    }
-
-    public void loadMessageForViewSynchronous(final Account account, final String folder, final String uid,
-        MessagingListener listener) {
-
-        for (MessagingListener l : getListeners()) {
-            l.loadMessageForViewStarted(account, folder, uid);
-        }
-
-        LocalFolder localFolder = null;
-        Folder remoteFolder = null;
-        try {
-            Store localStore = Store.getInstance(account.getLocalStoreUri(), mApplication);
-            localFolder = (LocalFolder) localStore.getFolder(folder);
-            localFolder.open(OpenMode.READ_WRITE);
-
-            Message message = localFolder.getMessage(uid);
-
-            for (MessagingListener l : getListeners()) {
-                l.loadMessageForViewHeadersAvailable(account, folder, uid, message);
-            }
-
-            if (!message.isSet(Flag.X_DOWNLOADED_FULL)) {
-                Store remoteStore = Store.getInstance(account.getStoreUri(), mApplication);
-                remoteFolder = remoteStore.getFolder(folder);
-                remoteFolder.open(OpenMode.READ_WRITE);
-
-                // Get the remote message and fully download it
-                Message remoteMessage = remoteFolder.getMessage(uid);
-                FetchProfile fp = new FetchProfile();
-                fp.add(FetchProfile.Item.BODY);
-                remoteFolder.fetch(new Message[]{remoteMessage}, fp, null);
-
-                // Store the message locally and load the stored message into memory
-                localFolder.appendMessages(new Message[]{remoteMessage});
-                message = localFolder.getMessage(uid);
-                localFolder.fetch(new Message[]{message}, fp, null);
-
-                // Mark that this message is now fully synched
-                message.setFlag(Flag.X_DOWNLOADED_FULL, true);
-            }
-            else {
-                FetchProfile fp = new FetchProfile();
-                fp.add(FetchProfile.Item.ENVELOPE);
-                fp.add(FetchProfile.Item.BODY);
-                localFolder.fetch(new Message[]{
-                        message
-                    }, fp, null);
-            }
-
-            if (!message.isSet(Flag.SEEN)) {
-                markMessageRead(account, localFolder, message, true);
-            }
-
-            for (MessagingListener l : getListeners()) {
-                l.loadMessageForViewBodyAvailable(account, folder, uid, message);
-            }
-            if (listener != null) {
-                listener.loadMessageForViewBodyAvailable(account, folder, uid, message);
-            }
-
-            for (MessagingListener l : getListeners()) {
-                l.loadMessageForViewFinished(account, folder, uid, message);
-            }
-            if (listener != null) {
-                listener.loadMessageForViewFinished(account, folder, uid, message);
-            }
-        }
-        catch (Exception e) {
-            for (MessagingListener l : getListeners()) {
-                l.loadMessageForViewFailed(account, folder, uid, e.getMessage());
-            }
-            addErrorMessage(account, e);
-        }
-        finally {
-            if (localFolder!=null) {
-                try {
-                    localFolder.close(false);
-                }
-                catch (MessagingException e) {
-                    Log.w(Email.LOG_TAG, null, e);
-                }
-            }
-
-            if (remoteFolder!=null) {
-                try {
-                    remoteFolder.close(false);
-                }
-                catch (MessagingException e) {
-                    Log.w(Email.LOG_TAG, null, e);
-                }
-            }
-        }
-    }//loadMessageForViewSynchronous
-
-    /**
-     * Attempts to load the attachment specified by part from the given account and message.
-     * @param account
-     * @param message
-     * @param part
-     * @param listener
-     */
-    public void loadAttachment(
-            final Account account,
-            final Message message,
-            final Part part,
-            final Object tag,
-            MessagingListener listener) {
-        /*
-         * Check if the attachment has already been downloaded. If it has there's no reason to
-         * download it, so we just tell the listener that it's ready to go.
-         */
-        try {
-            if (part.getBody() != null) {
-                for (MessagingListener l : getListeners()) {
-                    l.loadAttachmentStarted(account, message, part, tag, false);
-                }
-
-                for (MessagingListener l : getListeners()) {
-                    l.loadAttachmentFinished(account, message, part, tag);
-                }
-                return;
-            }
-        }
-        catch (MessagingException me) {
-            /*
-             * If the header isn't there the attachment isn't downloaded yet, so just continue
-             * on.
-             */
-        }
-
-        for (MessagingListener l : getListeners()) {
-            l.loadAttachmentStarted(account, message, part, tag, true);
-        }
-
-        put("loadAttachment", listener, new Runnable() {
-            public void run() {
-                try {
-                    LocalStore localStore =
-                        (LocalStore) Store.getInstance(account.getLocalStoreUri(), mApplication);
-                    /*
-                     * We clear out any attachments already cached in the entire store and then
-                     * we update the passed in message to reflect that there are no cached
-                     * attachments. This is in support of limiting the account to having one
-                     * attachment downloaded at a time.
-                     */
-                    localStore.pruneCachedAttachments();
-                    ArrayList<Part> viewables = new ArrayList<Part>();
-                    ArrayList<Part> attachments = new ArrayList<Part>();
-                    MimeUtility.collectParts(message, viewables, attachments);
-                    for (Part attachment : attachments) {
-                        attachment.setBody(null);
-                    }
-                    Store remoteStore = Store.getInstance(account.getStoreUri(), mApplication);
-                    LocalFolder localFolder =
-                        (LocalFolder) localStore.getFolder(message.getFolder().getName());
-                    Folder remoteFolder = remoteStore.getFolder(message.getFolder().getName());
-                    remoteFolder.open(OpenMode.READ_WRITE);
-
-                    FetchProfile fp = new FetchProfile();
-                    fp.add(part);
-                    remoteFolder.fetch(new Message[] { message }, fp, null);
-                    localFolder.updateMessage((LocalMessage)message);
-                    localFolder.close(false);
-                    for (MessagingListener l : getListeners()) {
-                        l.loadAttachmentFinished(account, message, part, tag);
-                    }
-                }
-                catch (MessagingException me) {
-                    if (Config.LOGV) {
-                        Log.v(Email.LOG_TAG, "", me);
-                    }
-                    for (MessagingListener l : getListeners()) {
-                        l.loadAttachmentFailed(account, message, part, tag, me.getMessage());
-                    }
-                    addErrorMessage(account, me);
-
-                }
-            }
-        });
-    }
-
-    /**
-     * Stores the given message in the Outbox and starts a sendPendingMessages command to
-     * attempt to send the message.
-     * @param account
-     * @param message
-     * @param listener
-     */
-    public void sendMessage(final Account account,
-            final Message message,
-            MessagingListener listener) {
-        try {
-            Store localStore = Store.getInstance(account.getLocalStoreUri(), mApplication);
-            LocalFolder localFolder =
-                (LocalFolder) localStore.getFolder(account.getOutboxFolderName());
-            localFolder.open(OpenMode.READ_WRITE);
-            localFolder.appendMessages(new Message[] {
-                message
-            });
-            Message localMessage = localFolder.getMessage(message.getUid());
-            localMessage.setFlag(Flag.X_DOWNLOADED_FULL, true);
-            localFolder.close(false);
-            sendPendingMessages(account, null);
-        }
-        catch (Exception e) {
-            for (MessagingListener l : getListeners()) {
-                // TODO general failed
-            }
-            addErrorMessage(account, e);
-
-        }
-    }
-
-    /**
-     * Attempt to send any messages that are sitting in the Outbox.
-     * @param account
-     * @param listener
-     */
-    public void sendPendingMessages(final Account account,
-            MessagingListener listener) {
-        put("sendPendingMessages", listener, new Runnable() {
-            public void run() {
-                sendPendingMessagesSynchronous(account);
-            }
-        });
-    }
-
-    /**
-     * Attempt to send any messages that are sitting in the Outbox.
-     * @param account
-     * @param listener
-     */
-    public void sendPendingMessagesSynchronous(final Account account) {
-        try {
-            Store localStore = Store.getInstance(
-                    account.getLocalStoreUri(),
-                    mApplication);
-            Folder localFolder = localStore.getFolder(
-                    account.getOutboxFolderName());
-            if (!localFolder.exists()) {
-                return;
-            }
-            for (MessagingListener l : getListeners()) {
-              l.sendPendingMessagesStarted(account);
-            }
-            localFolder.open(OpenMode.READ_WRITE);
-
-            Message[] localMessages = localFolder.getMessages(null);
-            boolean anyFlagged = false;
-            /*
-             * The profile we will use to pull all of the content
-             * for a given local message into memory for sending.
-             */
-            FetchProfile fp = new FetchProfile();
-            fp.add(FetchProfile.Item.ENVELOPE);
-            fp.add(FetchProfile.Item.BODY);
-
-            LocalFolder localSentFolder =
-                (LocalFolder) localStore.getFolder(
-                        account.getSentFolderName());
-            Log.i(Email.LOG_TAG, "Scanning folder '" + account.getOutboxFolderName() + "' (" + ((LocalFolder)localFolder).getId() + ") for messages to send");
-            Transport transport = Transport.getInstance(account.getTransportUri());
-            for (Message message : localMessages) {
-              if (message.isSet(Flag.DELETED)) {
-                message.setFlag(Flag.X_DESTROYED, true);
-                continue;
-              }
-              if (message.isSet(Flag.FLAGGED)) {
-                Log.i(Email.LOG_TAG, "Skipping sending FLAGGED message " + message.getUid());
-                continue;
-              }
-                try {
-                  AtomicInteger count = new AtomicInteger(0);
-                  AtomicInteger oldCount = sendCount.putIfAbsent(message.getUid(), count);
-                  if (oldCount != null)
-                  {
-                    count = oldCount;
-                  }
-                  Log.i(Email.LOG_TAG, "Send count for message " + message.getUid() + " is " + count.get());
-                  if (count.incrementAndGet() > Email.MAX_SEND_ATTEMPTS)
-                  {
-                    Log.e(Email.LOG_TAG, "Send count for message " + message.getUid() + " has exceeded maximum attempt threshold, flagging");
-                    message.setFlag(Flag.FLAGGED, true);
-                    anyFlagged = true;
-                    continue;
-                  }
-                  
-                    localFolder.fetch(new Message[] { message }, fp, null);
-                    try {
-                        message.setFlag(Flag.X_SEND_IN_PROGRESS, true);
-                        Log.i(Email.LOG_TAG, "Sending message with UID " + message.getUid());
-                        transport.sendMessage(message);
-                        message.setFlag(Flag.X_SEND_IN_PROGRESS, false);
-                        message.setFlag(Flag.SEEN, true);
-
-                        Log.i(Email.LOG_TAG, "Moving sent message to folder '" + account.getSentFolderName() + "' (" + localSentFolder.getId() + ") ");
-                        localFolder.moveMessages(
-                                new Message[] { message },
-                                localSentFolder);
-                        Log.i(Email.LOG_TAG, "Moved sent message to folder '" + account.getSentFolderName() + "' (" + localSentFolder.getId() + ") ");
-                       
-                        PendingCommand command = new PendingCommand();
-                        command.command = PENDING_COMMAND_APPEND;
-                        command.arguments =
-                            new String[] {
-                                localSentFolder.getName(),
-                                message.getUid() };
-                        queuePendingCommand(account, command);
-                        processPendingCommands(account);
-                    }
-                    catch (Exception e) {
-                      if (e instanceof MessagingException)
-                      {
-                        MessagingException me = (MessagingException)e;
-                        if (me.isPermanentFailure() == false)
-                        {
-                          // Decrement the counter if the message could not possibly have been sent
-                          int newVal = count.decrementAndGet();
-                          Log.i(Email.LOG_TAG, "Decremented send count for message " + message.getUid() + " to " + newVal 
-                              + "; no possible send");
-                        }
-                      }
-                        message.setFlag(Flag.X_SEND_FAILED, true);
-                        Log.e(Email.LOG_TAG, "Failed to send message", e);
-                        for (MessagingListener l : getListeners()) {
-                          l.synchronizeMailboxFailed(
-                                  account,
-                                  localFolder.getName(),
-                                  getRootCauseMessage(e));
-                        }
-                        addErrorMessage(account, e);
-
-                    }
-                }
-                catch (Exception e) {
-                	Log.e(Email.LOG_TAG, "Failed to fetch message for sending", e);
-                	for (MessagingListener l : getListeners()) {
-                    l.synchronizeMailboxFailed(
-                            account,
-                            localFolder.getName(),
-                            getRootCauseMessage(e));
-                  }
-                  addErrorMessage(account, e);
-
-                    /*
-                     * We ignore this exception because a future refresh will retry this
-                     * message.
-                     */
-                }
-            }
-            localFolder.expunge();
-            if (localFolder.getMessageCount() == 0) {
-                localFolder.delete(false);
-            }
-            for (MessagingListener l : getListeners()) {
-                l.sendPendingMessagesCompleted(account);
-            }
-            if (anyFlagged)
-            {
-              addErrorMessage(account, mApplication.getString(R.string.send_failure_subject), 
-                  mApplication.getString(R.string.send_failure_body_fmt, Email.ERROR_FOLDER_NAME));
-              
-              NotificationManager notifMgr =
-                (NotificationManager)mApplication.getSystemService(Context.NOTIFICATION_SERVICE);
-              
-              Notification notif = new Notification(R.drawable.stat_notify_email_generic,
-                  mApplication.getString(R.string.send_failure_subject), System.currentTimeMillis());
-             
-              // JRV XXX TODO - do we want to notify MessageList too? 
-              Intent i = FolderList.actionHandleAccountIntent(mApplication, account, account.getErrorFolderName());
-
-              PendingIntent pi = PendingIntent.getActivity(mApplication, 0, i, 0);
-
-              notif.setLatestEventInfo(mApplication, mApplication.getString(R.string.send_failure_subject),
-                  mApplication.getString(R.string.send_failure_body_abbrev, Email.ERROR_FOLDER_NAME), pi);
-              
-              notif.flags |= Notification.FLAG_SHOW_LIGHTS;
-              notif.ledARGB = Email.NOTIFICATION_LED_SENDING_FAILURE_COLOR;
-              notif.ledOnMS = Email.NOTIFICATION_LED_FAST_ON_TIME;
-              notif.ledOffMS = Email.NOTIFICATION_LED_FAST_OFF_TIME;
-              notifMgr.notify(-1000 - account.getAccountNumber(), notif);
-            }
-        }
-        catch (Exception e) {
-            for (MessagingListener l : getListeners()) {
-                l.sendPendingMessagesFailed(account);
-            }
-            addErrorMessage(account, e);
-
-        }
-    }
-    
-    public void getAccountUnreadCount(final Context context, final Account account, 
-        final MessagingListener l)
-    {
-      Runnable unreadRunnable = new Runnable() {
-        public void run() {
-      
-          int unreadMessageCount = 0;
-          try {
-            unreadMessageCount = account.getUnreadMessageCount(context, mApplication);
-          }
-          catch (MessagingException me) {
-              Log.e(Email.LOG_TAG, "Count not get unread count for account " + account.getDescription(),
-                  me);
-          }
-          l.accountStatusChanged(account, unreadMessageCount);
-        }
-      };
-      
-      
-      putBackground("getAccountUnread:" + account.getDescription(), l, unreadRunnable);
-    }
-    
-    public boolean moveMessage(final Account account, final String srcFolder, final Message message, final String destFolder,
-        final MessagingListener listener)
-    {
-      if (!message.getUid().startsWith(Email.LOCAL_UID_PREFIX)) { 
-        put("moveMessage", null, new Runnable() {
-          public void run() {
-            moveOrCopyMessageSynchronous(account, srcFolder, message, destFolder, false, listener);
-          }
-        });
-        return true;
-      }
-      else
-      {
-        return false;
-      }
-    }
-    
-    public boolean isMoveCapable(Message message) {
-      if (!message.getUid().startsWith(Email.LOCAL_UID_PREFIX)) { 
-        return true;
-      }
-      else {
-        return false;
-      }
-    }
-    public boolean isCopyCapable(Message message) {
-      return isMoveCapable(message);
-    }
-    
-    public boolean isMoveCapable(final Account account)
-    {
-      try {
-        Store localStore = Store.getInstance(account.getLocalStoreUri(), mApplication);
-        Store remoteStore = Store.getInstance(account.getStoreUri(), mApplication);
-        return localStore.isMoveCapable() && remoteStore.isMoveCapable();
-      }
-      catch (MessagingException me)
-      {
-
-        Log.e(Email.LOG_TAG, "Exception while ascertaining move capability", me);
-        return false;
-       }
-    }
-    public boolean isCopyCapable(final Account account)
-    {
-      try {
-        Store localStore = Store.getInstance(account.getLocalStoreUri(), mApplication);
-        Store remoteStore = Store.getInstance(account.getStoreUri(), mApplication);
-        return localStore.isCopyCapable() && remoteStore.isCopyCapable();
-      }
-      catch (MessagingException me)
-      {
-        Log.e(Email.LOG_TAG, "Exception while ascertaining copy capability", me);
-        return false;
-       }
-    }
-    
-    public boolean copyMessage(final Account account, final String srcFolder, final Message message, final String destFolder,
-        final MessagingListener listener)
-    {
-      if (!message.getUid().startsWith(Email.LOCAL_UID_PREFIX)) { 
-        put("copyMessage", null, new Runnable() {
-          public void run() {
-            moveOrCopyMessageSynchronous(account, srcFolder, message, destFolder, true, listener);
-          }
-        });
-        return true;
-      }
-      else
-      {
-        return false;
-      }
-    }
-    
-    private void moveOrCopyMessageSynchronous(final Account account, final String srcFolder, final Message message, 
-        final String destFolder, final boolean isCopy, MessagingListener listener)
-    {
-      try {
-        Store localStore = Store.getInstance(account.getLocalStoreUri(), mApplication);
-        Store remoteStore = Store.getInstance(account.getStoreUri(), mApplication);
-        if (isCopy == false && (remoteStore.isMoveCapable() == false || localStore.isMoveCapable() == false)) {
-          return;
-        }
-        if (isCopy == true && (remoteStore.isCopyCapable() == false || localStore.isCopyCapable() == false)) {
-          return;
-        }
-        
-        Folder localSrcFolder = localStore.getFolder(srcFolder);
-        Folder localDestFolder = localStore.getFolder(destFolder);
-        Message lMessage = localSrcFolder.getMessage(message.getUid());
-        String origUid = message.getUid();
-        if (lMessage != null)
-        {
-          if (Config.LOGD)
-          {
-            Log.d(Email.LOG_TAG, "moveOrCopyMessageSynchronous: source folder = " + srcFolder
-                + ", uid = " + origUid + ", destination folder = " + destFolder + ", isCopy = " + isCopy);
-          }
-          if (isCopy) {
-            FetchProfile fp = new FetchProfile();
-            fp.add(FetchProfile.Item.ENVELOPE);
-            fp.add(FetchProfile.Item.BODY);
-            localSrcFolder.fetch(new Message[] { message }, fp, null);
-            localSrcFolder.copyMessages(new Message[] { message }, localDestFolder);
-          }
-          else {
-            localSrcFolder.moveMessages(new Message[] { message }, localDestFolder);
-            for (MessagingListener l : getListeners()) {
-              l.messageUidChanged(account, srcFolder, origUid, message.getUid());
-            }
-            unsuppressMessage(account, srcFolder, origUid);
-          }
-        }
-        PendingCommand command = new PendingCommand();
-        command.command = PENDING_COMMAND_MOVE_OR_COPY;
-        command.arguments = new String[] { srcFolder, origUid, destFolder, Boolean.toString(isCopy) };
-        queuePendingCommand(account, command);
-        processPendingCommands(account);
-      }
-      catch (MessagingException me) {
-        addErrorMessage(account, me);
-
-          throw new RuntimeException("Error moving message", me);
-      }
-    }
-    
-    public void deleteMessage(final Account account, final String folder, final Message message,
-            final MessagingListener listener) {
-      suppressMessage(account, folder, message);
-      
-      put("deleteMessage", null, new Runnable() {
-        public void run() {
-          deleteMessageSynchronous(account, folder, message, listener);
-        }
-      });
-    }
-  
-    private void deleteMessageSynchronous(final Account account, final String folder, final Message message,
-        MessagingListener listener) {
-      
-        try {
-            Store localStore = Store.getInstance(account.getLocalStoreUri(), mApplication);
-            Folder localFolder = localStore.getFolder(folder);
-            Message lMessage = localFolder.getMessage(message.getUid());
-            String origUid = message.getUid();
-            if (lMessage != null)
-            {
-              if (folder.equals(account.getTrashFolderName()))
-              {
-                if (Config.LOGD)
-                {
-                  Log.d(Email.LOG_TAG, "Deleting message in trash folder, not copying");
-                }
-                lMessage.setFlag(Flag.DELETED, true);
-              }
-              else
-              {
-                Folder localTrashFolder = localStore.getFolder(account.getTrashFolderName());
-                if (localTrashFolder.exists() == false)
-                {
-                  localTrashFolder.create(Folder.FolderType.HOLDS_MESSAGES);
-                }
-                if (localTrashFolder.exists() == true)
-                {
-                  if (Config.LOGD)
-                  {
-                    Log.d(Email.LOG_TAG, "Deleting message in normal folder, moving");
-                  }
-                  
-                  localFolder.moveMessages(new Message[] { message }, localTrashFolder);
-
-                }
-              }
-            }
-            localFolder.close(false);
-            unsuppressMessage(account, folder, message);
-            if (listener != null) {
-              listener.messageDeleted(account, folder, message);
-            }
-            for (MessagingListener l : getListeners()) {
-              l.folderStatusChanged(account, account.getTrashFolderName());
-          }
-            
-            if (Config.LOGD)
-          	{
-            	Log.d(Email.LOG_TAG, "Delete policy for account " + account.getDescription() + " is " + account.getDeletePolicy());
-          	}
-            if (folder.equals(account.getOutboxFolderName()))
-            {
-              // If the message was in the Outbox, then it has been copied to local Trash, and has
-              // to be copied to remote trash
-              PendingCommand command = new PendingCommand();
-              command.command = PENDING_COMMAND_APPEND;
-              command.arguments =
-                  new String[] {
-                      account.getTrashFolderName(),
-                      message.getUid() };
-              queuePendingCommand(account, command);
-              processPendingCommands(account);
-            }
-            else if  (folder.equals(account.getTrashFolderName()) && account.getDeletePolicy() == Account.DELETE_POLICY_ON_DELETE)
-            {
-              PendingCommand command = new PendingCommand();
-              command.command = PENDING_COMMAND_SET_FLAG;
-              command.arguments = new String[] { folder, origUid, Boolean.toString(true), Flag.DELETED.toString() };
-              queuePendingCommand(account, command);
-              processPendingCommands(account);
-            }
-            else if (account.getDeletePolicy() == Account.DELETE_POLICY_ON_DELETE) {
-                PendingCommand command = new PendingCommand();
-                command.command = PENDING_COMMAND_MOVE_OR_COPY;
-                command.arguments = new String[] { folder, origUid, account.getTrashFolderName(), "false" };
-                queuePendingCommand(account, command);
-                processPendingCommands(account);
-            }
-            else if (account.getDeletePolicy() == Account.DELETE_POLICY_MARK_AS_READ)
-            {
-              PendingCommand command = new PendingCommand();
-              command.command = PENDING_COMMAND_SET_FLAG;
-              command.arguments = new String[] { folder, origUid, Boolean.toString(true), Flag.SEEN.toString() };
-              queuePendingCommand(account, command);
-              processPendingCommands(account);
-            }
-            else
-            {
-            	if (Config.LOGD)
-            	{
-            		Log.d(Email.LOG_TAG, "Delete policy " + account.getDeletePolicy() + " prevents delete from server");
-            	}
-            }
-        }
-        catch (MessagingException me) {
-          addErrorMessage(account, me);
-
-            throw new RuntimeException("Error deleting message from local store.", me);
-        }
-    }
-    
-    private void processPendingEmptyTrash(PendingCommand command, Account account) throws MessagingException {
-      Store remoteStore = Store.getInstance(account.getStoreUri(), mApplication);
-      
-      Folder remoteFolder = remoteStore.getFolder(account.getTrashFolderName());
-      if (remoteFolder.exists())
-      {
-        remoteFolder.open(OpenMode.READ_WRITE);
-        remoteFolder.setFlags(new Flag [] { Flag.DELETED }, true);
-        remoteFolder.close(true);
-      }
-    }
-
-    public void emptyTrash(final Account account, MessagingListener listener) {
-        put("emptyTrash", listener, new Runnable() {
-            public void run() {
-                try {
-                    Store localStore = Store.getInstance(account.getLocalStoreUri(), mApplication);
-                    Folder localFolder = localStore.getFolder(account.getTrashFolderName());
-                    localFolder.open(OpenMode.READ_WRITE);
-                    localFolder.setFlags(new Flag[] { Flag.DELETED }, true);
-                    localFolder.close(true);
-                    
-                    for (MessagingListener l : getListeners()) {
-                      l.emptyTrashCompleted(account);
-                    }
-                    List<String> args = new ArrayList<String>();
-                    PendingCommand command = new PendingCommand();
-                    command.command = PENDING_COMMAND_EMPTY_TRASH;
-                    command.arguments = args.toArray(new String[0]);
-                    queuePendingCommand(account, command);
-                    processPendingCommands(account);
-                }
-                catch (Exception e) {
-                    Log.e(Email.LOG_TAG, "emptyTrash failed", e);
-                    
-                    addErrorMessage(account, e);
-                }
-            }
-        });
-    }
-
-  	public void sendAlternate(final Context context, Account account, Message message)
-  	{
-  			if (Config.LOGD)
-  			{
-  				Log.d(Email.LOG_TAG, "About to load message " + account.getDescription() + ":" + message.getFolder().getName()
-  						+ ":" + message.getUid() + " for sendAlternate");
-  			}
-   			loadMessageForView(account, message.getFolder().getName(), 
-  					message.getUid(), new MessagingListener()
-  			{
-  				@Override
-  				public void loadMessageForViewBodyAvailable(Account account, String folder, String uid,
-              Message message)
-  				{
-  					if (Config.LOGD)
-  					{
-  						Log.d(Email.LOG_TAG, "Got message " + account.getDescription() + ":" + folder
-  								+ ":" + message.getUid() + " for sendAlternate");
-  					}
-
-  					try
-  					{
-  						Intent msg=new Intent(Intent.ACTION_SEND);  
-  					  String quotedText = null;
-  						Part part = MimeUtility.findFirstPartByMimeType(message,
-  			       			"text/plain");
-  					  if (part == null) {
-  				        part = MimeUtility.findFirstPartByMimeType(message, "text/html");
-  				    }
-  						if (part != null) {
-  						   quotedText = MimeUtility.getTextFromPart(part);
-  						}
-  						if (quotedText != null)
-  						{
-  							msg.putExtra(Intent.EXTRA_TEXT, quotedText);
-  						}
-  					  msg.putExtra(Intent.EXTRA_SUBJECT, "Fwd: " + message.getSubject());  
-  					  msg.setType("text/plain");  
-  					  context.startActivity(Intent.createChooser(msg, context.getString(R.string.send_alternate_chooser_title)));  
-  					}
-  					catch (MessagingException me)
-  					{
-  						Log.e(Email.LOG_TAG, "Unable to send email through alternate program", me);
-  					}
-  				}
-  			});
-  	   
-  	}
-   
-    /**
-     * Checks mail for one or multiple accounts. If account is null all accounts
-     * are checked.
-     *
-     * @param context
-     * @param account
-     * @param listener
-     */
-    public void checkMail(final Context context, final Account account, 
-            final boolean ignoreLastCheckedTime,
-            final boolean useManualWakeLock,
-            final MessagingListener listener) {
-        
-      WakeLock twakeLock = null;
-      if (useManualWakeLock) {
-        PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
-        twakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "Email");
-        twakeLock.setReferenceCounted(false);
-        twakeLock.acquire(Email.MANUAL_WAKE_LOCK_TIMEOUT);
-      }
-      final WakeLock wakeLock = twakeLock;
-      
-        for (MessagingListener l : getListeners()) {
-            l.checkMailStarted(context, account);
-        }
-        put("checkMail", listener, new Runnable() {
-            public void run() {
-
-                final NotificationManager notifMgr = (NotificationManager)context
-                  .getSystemService(Context.NOTIFICATION_SERVICE);
-            	  try
-            	  {
-	              	Log.i(Email.LOG_TAG, "Starting mail check");
-          				Preferences prefs = Preferences.getPreferences(context);
-
-	                Account[] accounts;
-	                if (account != null) {
-	                    accounts = new Account[] {
-	                        account
-	                    };
-	                } else {
-	                    accounts = prefs.getAccounts();
-	                }
-
-	                for (final Account account : accounts) {
-	                  	final long accountInterval = account.getAutomaticCheckIntervalMinutes() * 60 * 1000;
-	                  	if (ignoreLastCheckedTime == false && accountInterval <= 0)
-	                  	{
-		                  	if (Config.LOGV || true)
-		                  	{
-		                  		Log.v(Email.LOG_TAG, "Skipping synchronizing account " + account.getDescription());
-		                  	}
-
-	                  		continue;
-	                  	}
-
-	                  	if (Config.LOGV || true)
-	                  	{
-	                  		Log.v(Email.LOG_TAG, "Synchronizing account " + account.getDescription());
-	                  	}
-                    	putBackground("sendPending " + account.getDescription(), null, new Runnable() {
-                        public void run() {
-                          if (account.isShowOngoing()) {
-                            Notification notif = new Notification(R.drawable.ic_menu_refresh, 
-                                context.getString(R.string.notification_bg_send_ticker, account.getDescription()), System.currentTimeMillis());                         
-                            // JRV XXX TODO - do we want to notify MessageList too? 
-                            Intent intent = FolderList.actionHandleAccountIntent(context, account, Email.INBOX);
-                            PendingIntent pi = PendingIntent.getActivity(context, 0, intent, 0);
-                              notif.setLatestEventInfo(context, context.getString(R.string.notification_bg_send_title), 
-                                  account.getDescription() , pi);
-                              notif.flags = Notification.FLAG_ONGOING_EVENT;
-                              
-                              if (Email.NOTIFICATION_LED_WHILE_SYNCING) {
-                                notif.flags |= Notification.FLAG_SHOW_LIGHTS;
-                                notif.ledARGB = Email.NOTIFICATION_LED_DIM_COLOR;
-                                notif.ledOnMS = Email.NOTIFICATION_LED_FAST_ON_TIME;
-                                notif.ledOffMS = Email.NOTIFICATION_LED_FAST_OFF_TIME;
-                              }
-                              
-                              notifMgr.notify(Email.FETCHING_EMAIL_NOTIFICATION_ID, notif);
-                          }
-                          try
-                          {
-                            sendPendingMessagesSynchronous(account);
-                          }
-                        	finally {
-                        	  if (account.isShowOngoing()) {
-                        	    notifMgr.cancel(Email.FETCHING_EMAIL_NOTIFICATION_ID);
-                        	  }
-                          }
-                        }
-                    	}
-                    	);
-	                    try
-	                    {
-	                    	Account.FolderMode aDisplayMode = account.getFolderDisplayMode();
-	                    	Account.FolderMode aSyncMode = account.getFolderSyncMode();
-
-		                    Store localStore = Store.getInstance(account.getLocalStoreUri(), mApplication);
-		                    for (final Folder folder : localStore.getPersonalNamespaces())
-		                    {
-		                    	
-		                    	folder.open(Folder.OpenMode.READ_WRITE);
-		                    	folder.refresh(prefs);
-		                    	
-		                    	Folder.FolderClass fDisplayMode = folder.getDisplayClass();
-		                    	Folder.FolderClass fSyncMode = folder.getSyncClass();
-
-		                    	if ((aDisplayMode == Account.FolderMode.FIRST_CLASS && 
-		                    					fDisplayMode != Folder.FolderClass.FIRST_CLASS) 
-		                    			|| (aDisplayMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
-		                      					fDisplayMode != Folder.FolderClass.FIRST_CLASS &&
-		                      					fDisplayMode != Folder.FolderClass.SECOND_CLASS) 
-		                      		|| (aDisplayMode == Account.FolderMode.NOT_SECOND_CLASS &&
-		                      					fDisplayMode == Folder.FolderClass.SECOND_CLASS))
-		                      {
-		                    		// Never sync a folder that isn't displayed
-			                    	if (Config.LOGV) {
-			                    		Log.v(Email.LOG_TAG, "Not syncing folder " + folder.getName() + 
-			                    				" which is in display mode " + fDisplayMode + " while account is in display mode " + aDisplayMode);
-			                    	}
-
-		                       	continue;
-		                      }
-
-		                    	if ((aSyncMode == Account.FolderMode.FIRST_CLASS && 
-		                    			fSyncMode != Folder.FolderClass.FIRST_CLASS)
-		                    			|| (aSyncMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
-		                      					fSyncMode != Folder.FolderClass.FIRST_CLASS &&
-		                      					fSyncMode != Folder.FolderClass.SECOND_CLASS) 
-		                    			|| (aSyncMode == Account.FolderMode.NOT_SECOND_CLASS &&
-		                    					fSyncMode == Folder.FolderClass.SECOND_CLASS))
-		                      {
-		                    		// Do not sync folders in the wrong class
-			                    	if (Config.LOGV) {
-			                    		Log.v(Email.LOG_TAG, "Not syncing folder " + folder.getName() + 
-			                    				" which is in sync mode " + fSyncMode + " while account is in sync mode " + aSyncMode);
-			                    	}
-
-		                       	continue;
-		                      }
-	                    	
-		                    	
-	
-		                    	if (Config.LOGV) {
-		                    		Log.v(Email.LOG_TAG, "Folder " + folder.getName() + " was last synced @ " +
-		                    				new Date(folder.getLastChecked()));
-		                    	}
-		                    	
-		                    	if (ignoreLastCheckedTime == false && folder.getLastChecked() > 
-		                    		(System.currentTimeMillis() - accountInterval))
-		                    	{
-			                    		if (Config.LOGV) {
-			                    			Log.v(Email.LOG_TAG, "Not syncing folder " + folder.getName()
-			                    					+ ", previously synced @ " + new Date(folder.getLastChecked())
-			                    							+ " which would be too recent for the account period");
-			                    		}					
-
-		                    			continue;
-		                    	}
-		                    	putBackground("sync" + folder.getName(), null, new Runnable() {
-		                        public void run() {
-				                    	try {
-				                    		// In case multiple Commands get enqueued, don't run more than
-				                    		// once
-				                    		final LocalStore localStore =
-				                          (LocalStore) Store.getInstance(account.getLocalStoreUri(), mApplication);
-				                    		LocalFolder tLocalFolder = (LocalFolder) localStore.getFolder(folder.getName());
-				                    		tLocalFolder.open(Folder.OpenMode.READ_WRITE);
-				                    						                    		
-				                    		if (ignoreLastCheckedTime == false && tLocalFolder.getLastChecked() > 
-				                    			    (System.currentTimeMillis() - accountInterval))
-				                    		{
-				                    			if (Config.LOGV) {
-					                    			Log.v(Email.LOG_TAG, "Not running Command for folder " + folder.getName()
-					                    					+ ", previously synced @ " + new Date(folder.getLastChecked())
-					                    							+ " which would be too recent for the account period");
-				                    			}
-				                    			return;
-				                    		}
-				                    		if (account.isShowOngoing()) {
-  				                    		Notification notif = new Notification(R.drawable.ic_menu_refresh, 
-  				                    		    context.getString(R.string.notification_bg_sync_ticker, account.getDescription(), folder.getName()), 
-  				                    		    System.currentTimeMillis());                         
-                                      // JRV XXX TODO - do we want to notify MessageList too? 
-  			                          Intent intent = FolderList.actionHandleAccountIntent(context, account, Email.INBOX);
-  			                          PendingIntent pi = PendingIntent.getActivity(context, 0, intent, 0);
-  			                            notif.setLatestEventInfo(context, context.getString(R.string.notification_bg_sync_title), account.getDescription()
-  			                                + context.getString(R.string.notification_bg_title_separator) + folder.getName(), pi);
-  			                            notif.flags = Notification.FLAG_ONGOING_EVENT;
-  			                            if (Email.NOTIFICATION_LED_WHILE_SYNCING) {
-    			                            notif.flags |= Notification.FLAG_SHOW_LIGHTS;
-    			                            notif.ledARGB = Email.NOTIFICATION_LED_DIM_COLOR;
-    			                            notif.ledOnMS = Email.NOTIFICATION_LED_FAST_ON_TIME;
-    			                            notif.ledOffMS = Email.NOTIFICATION_LED_FAST_OFF_TIME;
-  			                            }
-  
-  			                            notifMgr.notify(Email.FETCHING_EMAIL_NOTIFICATION_ID, notif);
-				                    		}
-			                          try
-			                          {
-			                            synchronizeMailboxSynchronous(account, folder.getName());
-			                          }
-				                    	  
-		                            finally {
-		                              if (account.isShowOngoing()) {
-		                                notifMgr.cancel(Email.FETCHING_EMAIL_NOTIFICATION_ID);
-		                              }
-		                            }
-				                    	}
-				                    	catch (Exception e)
-				                    	{
-				                    		
-				                    		Log.e(Email.LOG_TAG, "Exception while processing folder " + 
-				                    				account.getDescription() + ":" + folder.getName(), e);
-				                    		addErrorMessage(account, e);
-				                    	}
-		                        }
-		                    	}
-		                    	);
-		                    } 
-	                    }
-	                    catch (MessagingException e) {
-	                      Log.e(Email.LOG_TAG, "Unable to synchronize account " + account.getName(), e);
-	                      addErrorMessage(account, e);
-	                    }
-	                }
-            	  }
-            	  catch (Exception e)
-            	  {
-            	  	 Log.e(Email.LOG_TAG, "Unable to synchronize mail", e);
-            	  	 addErrorMessage(account, e);
-            	  }
-              	putBackground("finalize sync", null, new Runnable() {
-                  public void run() {
-
-		            	  Log.i(Email.LOG_TAG, "Finished mail sync");
-		            	  if (wakeLock != null)
-		            	  {
-		            	      wakeLock.release();
-		            	  }
-		                for (MessagingListener l : getListeners()) {
-		                    l.checkMailFinished(context, account);
-		                }
-		                
-                  }
-              	}
-              	);
-            }
-        });
-    }
-    
-    public void compact(final Account account, final MessagingListener ml)
-    {
-      putBackground("compact:" + account.getDescription(), ml, new Runnable() 
-      {
-        public void run()
-        {
-          try
-          {
-            LocalStore localStore = (LocalStore)Store.getInstance(account.getLocalStoreUri(), mApplication);
-            long oldSize = localStore.getSize();
-            localStore.compact();
-            long newSize = localStore.getSize();
-            if (ml != null)
-            {
-              ml.accountSizeChanged(account, oldSize, newSize);
-            }
-            for (MessagingListener l : getListeners()) {
-              l.accountSizeChanged(account, oldSize, newSize);
-              l.accountReset(account);
-            }
-          }
-          catch (Exception e)
-          {
-            Log.e(Email.LOG_TAG, "Failed to compact account " + account.getDescription(), e);
-          }
-        }
-      });
-    }
-
-    public void clear(final Account account, final MessagingListener ml)
-    {
-      putBackground("clear:" + account.getDescription(), ml, new Runnable() 
-      {
-        public void run()
-        {
-          try
-          {
-            LocalStore localStore = (LocalStore)Store.getInstance(account.getLocalStoreUri(), mApplication);
-            long oldSize = localStore.getSize();
-            localStore.clear();
-            localStore.resetVisibleLimits(account.getDisplayCount());
-            long newSize = localStore.getSize();
-            if (ml != null)
-            {
-              ml.accountSizeChanged(account, oldSize, newSize);
-            }
-            for (MessagingListener l : getListeners()) {
-              l.accountSizeChanged(account, oldSize, newSize);
-              l.accountReset(account);
-            }
-          }
-          catch (Exception e)
-          {
-            Log.e(Email.LOG_TAG, "Failed to compact account " + account.getDescription(), e);
-          }
-        }
-      });
-    }
-    public void saveDraft(final Account account, final Message message) {
-        try {
-            Store localStore = Store.getInstance(account.getLocalStoreUri(), mApplication);
-            LocalFolder localFolder =
-                (LocalFolder) localStore.getFolder(account.getDraftsFolderName());
-            localFolder.open(OpenMode.READ_WRITE);
-            localFolder.appendMessages(new Message[] {
-                message
-            });
-            Message localMessage = localFolder.getMessage(message.getUid());
-            localMessage.setFlag(Flag.X_DOWNLOADED_FULL, true);
-
-            PendingCommand command = new PendingCommand();
-            command.command = PENDING_COMMAND_APPEND;
-            command.arguments = new String[] {
-                    localFolder.getName(),
-                    localMessage.getUid() };
-            queuePendingCommand(account, command);
-            processPendingCommands(account);
-        }
-        catch (MessagingException e) {
-            Log.e(Email.LOG_TAG, "Unable to save message as draft.", e);
-            addErrorMessage(account, e);
-        }
-    }
-
-    class Command {
-        public Runnable runnable;
-
-        public MessagingListener listener;
-
-        public String description;
-    }
-
-    public MessagingListener getCheckMailListener()
-    {
-      return checkMailListener;
-    }
-
-    public void setCheckMailListener(MessagingListener checkMailListener)
-    {
-      if (this.checkMailListener != null)
-      {
-        removeListener(this.checkMailListener);
-      }
-      this.checkMailListener = checkMailListener;
-      if (this.checkMailListener != null)
-      {
-        addListener(this.checkMailListener);
-      }
-    }
-
-    public SORT_TYPE getSortType()
-    {
-      return sortType;
-    }
-
-    public void setSortType(SORT_TYPE sortType)
-    {
-      this.sortType = sortType;
-    }
-
-    public boolean isSortAscending(SORT_TYPE sortType)
-    {
-      Boolean sortAsc = sortAscending.get(sortType);
-      if (sortAsc == null)
-      {
-        return sortType.isDefaultAscending();
-      }
-      else return sortAsc;
-    }
-
-    public void setSortAscending(SORT_TYPE sortType, boolean nsortAscending)
-    {
-      sortAscending.put(sortType, nsortAscending);
-    }
-}
Index: src/com/android/email/activity/Debug.java
===================================================================
--- src/com/android/email/activity/Debug.java	(revision 718)
+++ src/com/android/email/activity/Debug.java	(working copy)
@@ -1,91 +0,0 @@
-
-package com.android.email.activity;
-
-import com.android.email.K9Activity;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.widget.CheckBox;
-import android.widget.CompoundButton;
-import android.widget.TextView;
-import android.widget.CompoundButton.OnCheckedChangeListener;
-
-import com.android.email.Email;
-import com.android.email.Preferences;
-import com.android.email.R;
-
-import java.lang.Integer;
-
-public class Debug extends K9Activity implements OnCheckedChangeListener {
-    private TextView mVersionView;
-    private CheckBox mEnableDebugLoggingView;
-    private CheckBox mEnableSensitiveLoggingView;
-
-    private Preferences mPreferences;
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        setContentView(R.layout.debug);
-
-        mPreferences = Preferences.getPreferences(this);
-
-        mVersionView = (TextView)findViewById(R.id.version);
-        mEnableDebugLoggingView = (CheckBox)findViewById(R.id.debug_logging);
-        mEnableSensitiveLoggingView = (CheckBox)findViewById(R.id.sensitive_logging);
-
-        mEnableDebugLoggingView.setOnCheckedChangeListener(this);
-        mEnableSensitiveLoggingView.setOnCheckedChangeListener(this);
-	
-        mVersionView.setText(String.format(getString(R.string.debug_version_fmt).toString(), getVersionNumber()));
-
-        mEnableDebugLoggingView.setChecked(Email.DEBUG);
-        mEnableSensitiveLoggingView.setChecked(Email.DEBUG_SENSITIVE);
-    }
-
-    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
-        if (buttonView.getId() == R.id.debug_logging) {
-            Email.DEBUG = isChecked;
-            mPreferences.setEnableDebugLogging(Email.DEBUG);
-        } else if (buttonView.getId() == R.id.sensitive_logging) {
-            Email.DEBUG_SENSITIVE = isChecked;
-            mPreferences.setEnableSensitiveLogging(Email.DEBUG_SENSITIVE);
-        }
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        int id = item.getItemId();
-        if (id == R.id.dump_settings) {
-            Preferences.getPreferences(this).dump();
-            return true;
-        }
-        return super.onOptionsItemSelected(item);
-    }
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        super.onCreateOptionsMenu(menu);
-        getMenuInflater().inflate(R.menu.debug_option, menu);
-        return true;
-    }
-
-    private String getVersionNumber() {
-	String version = "?";
-	int vnum;
-
-	try {
-	    PackageInfo pi = 
-		getPackageManager().getPackageInfo(getPackageName(), 0);
-	    version = Integer.toString(pi.versionCode);
-	    
-	} catch (PackageManager.NameNotFoundException e){
-	    Log.e(Email.LOG_TAG, "Package name not found: " + e.getMessage());
-	};
-	return version;
-    }
-}
Index: src/com/android/email/MessagingListener.java
===================================================================
--- src/com/android/email/MessagingListener.java	(revision 718)
+++ src/com/android/email/MessagingListener.java	(working copy)
@@ -1,166 +0,0 @@
-
-package com.android.email;
-
-import android.content.Context;
-
-import com.android.email.mail.Folder;
-import com.android.email.mail.Message;
-import com.android.email.mail.Part;
-
-/**
- * Defines the interface that MessagingController will use to callback to requesters. This class
- * is defined as non-abstract so that someone who wants to receive only a few messages can
- * do so without implementing the entire interface. It is highly recommended that users of
- * this interface use the @Override annotation in their implementations to avoid being caught by
- * changes in this class.
- */
-public class MessagingListener {
-  
-    public void accountStatusChanged(Account account, int unreadMessageCount) {
-    }
-    
-    public void accountSizeChanged(Account account, long oldSize, long newSize)
-    {
-    }
-    
-    public void accountReset(Account account) {
-      
-    }
-  
-    public void listFoldersStarted(Account account) {
-    }
-
-    public void listFolders(Account account, Folder[] folders) {
-    }
-
-    public void listFoldersFailed(Account account, String message) {
-    }
-
-    public void listFoldersFinished(Account account) {
-    }
-
-    public void listLocalMessagesStarted(Account account, String folder) {
-    }
-
-    public void listLocalMessages(Account account, String folder, Message[] messages) {
-    }
-    
-    public void listLocalMessagesAddMessage(Account account, String folder, Message message) {
-    }
-
-    public void listLocalMessagesUpdateMessage(Account account, String folder, Message message) {
-    }
-
-    public void listLocalMessagesRemoveMessage(Account account, String folder, Message message) {
-    }
-
-    public void listLocalMessagesFailed(Account account, String folder, String message) {
-    }
-
-    public void listLocalMessagesFinished(Account account, String folder) {
-    }
-
-    public void synchronizeMailboxStarted(Account account, String folder) {
-    }
-
-    public void synchronizeMailboxNewMessage(Account account, String folder, Message message) {
-    }
-
-    public void synchronizeMailboxRemovedMessage(Account account, String folder,Message message) {
-    }
-
-    public void synchronizeMailboxFinished(Account account, String folder,
-            int totalMessagesInMailbox, int numNewMessages) {
-    }
-
-    public void synchronizeMailboxFailed(Account account, String folder,
-            String message) {
-    }
-
-    public void loadMessageForViewStarted(Account account, String folder, String uid) {
-    }
-
-    public void loadMessageForViewHeadersAvailable(Account account, String folder, String uid,
-            Message message) {
-    }
-
-    public void loadMessageForViewBodyAvailable(Account account, String folder, String uid,
-            Message message) {
-    }
-
-    public void loadMessageForViewFinished(Account account, String folder, String uid,
-            Message message) {
-    }
-
-    public void loadMessageForViewFailed(Account account, String folder, String uid, String message) {
-    }
-
-    public void checkMailStarted(Context context, Account account) {
-    }
-
-    public void checkMailFinished(Context context, Account account) {
-    }
-    
-    public void checkMailFailed(Context context, Account account, String reason) {
-    }
-
-    public void sendPendingMessagesStarted(Account account) {
-    }
-
-    public void sendPendingMessagesCompleted(Account account) {
-    }
-    
-    public void sendPendingMessagesFailed(Account account) {
-    }
-
-    public void messageDeleted(Account account, String folder, Message message)
-    {
-      
-    }
-    public void emptyTrashCompleted(Account account) {
-    }
-
-    public void folderStatusChanged(Account account, String folderName) {
-    }
-
-    public void messageUidChanged(Account account, String folder, String oldUid, String newUid) {
-
-    }
-
-    public void loadAttachmentStarted(
-            Account account,
-            Message message,
-            Part part,
-            Object tag,
-            boolean requiresDownload)
-    {
-    }
-
-    public void loadAttachmentFinished(
-            Account account,
-            Message message,
-            Part part,
-            Object tag)
-    {
-    }
-
-    public void loadAttachmentFailed(
-            Account account,
-            Message message,
-            Part part,
-            Object tag,
-            String reason)
-    {
-    }
-
-    /**
-     * General notification messages subclasses can override to be notified that the controller
-     * has completed a command. This is useful for turning off progress indicators that may have
-     * been left over from previous commands.
-     * @param moreCommandsToRun True if the controller will continue on to another command
-     * immediately.
-     */
-    public void controllerCommandCompleted(boolean moreCommandsToRun) {
-
-    }
-}
Index: src/com/android/email/activity/ChooseFolder.java
===================================================================
--- src/com/android/email/activity/ChooseFolder.java	(revision 718)
+++ src/com/android/email/activity/ChooseFolder.java	(working copy)
@@ -1,293 +0,0 @@
-
-package com.android.email.activity;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-
-import com.android.email.K9ListActivity;
-import android.content.Intent;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Process;
-import android.util.Log;
-import android.view.View;
-import android.view.Window;
-import android.widget.AdapterView;
-import android.widget.ArrayAdapter;
-import android.widget.ListView;
-import android.widget.TextView;
-
-import com.android.email.Account;
-import com.android.email.Email;
-import com.android.email.MessagingController;
-import com.android.email.MessagingListener;
-import com.android.email.Preferences;
-import com.android.email.R;
-import com.android.email.mail.Folder;
-import com.android.email.mail.MessagingException;
-
-public class ChooseFolder extends K9ListActivity
-{
-  String mFolder;
-  Account mAccount;
-  String	mUID;
-  ArrayAdapter<String> adapter;
-  private ChooseFolderHandler mHandler = new ChooseFolderHandler();
-  String heldInbox = null;
-  boolean hideCurrentFolder = true;
-  boolean showOptionNone = false;
-  boolean showDisplayableOnly = false;
-
-  public static final String EXTRA_ACCOUNT = "com.android.email.ChooseFolder_account";
-  public static final String EXTRA_CUR_FOLDER = "com.android.email.ChooseFolder_curfolder";
-  public static final String EXTRA_NEW_FOLDER = "com.android.email.ChooseFolder_newfolder";
-  public static final String EXTRA_MESSAGE_UID = "com.android.email.ChooseFolder_messageuid";
-  public static final String EXTRA_SHOW_CURRENT = "com.android.email.ChooseFolder_showcurrent";
-  public static final String EXTRA_SHOW_FOLDER_NONE = "com.android.email.ChooseFolder_showOptionNone";
-  public static final String EXTRA_SHOW_DISPLAYABLE_ONLY = "com.android.email.ChooseFolder_showDisplayableOnly";
-
-  @Override
-  public void onCreate(Bundle savedInstanceState)
-  {
-    super.onCreate(savedInstanceState);
-
-    requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
-    
-    getListView().setTextFilterEnabled(true);
-    getListView().setItemsCanFocus(false);
-    getListView().setChoiceMode(ListView.CHOICE_MODE_NONE);
-    Intent intent = getIntent();
-    mAccount = (Account) intent.getSerializableExtra(EXTRA_ACCOUNT);
-    mUID = intent.getStringExtra(EXTRA_MESSAGE_UID);
-    mFolder = intent.getStringExtra(EXTRA_CUR_FOLDER);
-    if (intent.getStringExtra(EXTRA_SHOW_CURRENT) != null) {
-    	hideCurrentFolder = false;
-    }
-    if (intent.getStringExtra(EXTRA_SHOW_FOLDER_NONE) != null) {
-      showOptionNone = true;
-    }
-    if (intent.getStringExtra(EXTRA_SHOW_DISPLAYABLE_ONLY) != null) {
-      showDisplayableOnly = true;
-    }
-    if(mFolder == null)
-      mFolder = "";
-    
-    adapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1);
-
-    setListAdapter(adapter);
-
-    new Thread()
-    {
-      public void run()
-      {
-        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
-        MessagingController.getInstance(getApplication()).listFolders(mAccount,
-            false, mListener);
-
-      }
-    }.start();
-
-    this.getListView().setOnItemClickListener(new AdapterView.OnItemClickListener() {  
-      public void onItemClick(AdapterView adapterview, View view, int i, long l)
-      {
-        Intent intent = new Intent();
-        intent.putExtra(EXTRA_CUR_FOLDER, mFolder);
-        String destFolderName = (String)((TextView)view).getText();
-        if (heldInbox != null && getString(R.string.special_mailbox_name_inbox).equals(destFolderName))
-        {
-          destFolderName = heldInbox;
-        }
-        intent.putExtra(EXTRA_NEW_FOLDER, destFolderName);
-        intent.putExtra(EXTRA_MESSAGE_UID, mUID);
-        setResult(RESULT_OK, intent);
-        finish();
-      }  
-    });  
-
-  }
-  
-  class ChooseFolderHandler extends Handler
-  {
-
-    private static final int MSG_PROGRESS = 2;
-
-    private static final int MSG_DATA_CHANGED = 3;
-    private static final int MSG_SET_SELECTED_FOLDER = 4;
-
-    public void handleMessage(android.os.Message msg)
-    {
-      switch (msg.what)
-      {
-        case MSG_PROGRESS:
-          setProgressBarIndeterminateVisibility(msg.arg1 != 0);
-          break;
-        case MSG_DATA_CHANGED:
-          adapter.notifyDataSetChanged();
-          break;
-        case MSG_SET_SELECTED_FOLDER:
-          // TODO: I want this to highlight the chosen folder, but this doesn't work.
-//          getListView().setSelection(msg.arg1);
-//          getListView().setItemChecked(msg.arg1, true);
-          break;
-      }
-    }
-
-    public void progress(boolean progress)
-    {
-      android.os.Message msg = new android.os.Message();
-      msg.what = MSG_PROGRESS;
-      msg.arg1 = progress ? 1 : 0;
-      sendMessage(msg);
-    }
-    
-    public void setSelectedFolder(int position)
-    {
-      android.os.Message msg = new android.os.Message();
-      msg.what = MSG_SET_SELECTED_FOLDER;
-      msg.arg1 = position;
-      sendMessage(msg);
-    }
-
-    public void dataChanged()
-    {
-      sendEmptyMessage(MSG_DATA_CHANGED);
-    }
-  }
-  
-  private MessagingListener mListener = new MessagingListener()
-  {
-    public void listFoldersStarted(Account account)
-    {
-      if (!account.equals(mAccount))
-      {
-        return;
-      }
-      mHandler.progress(true);
-    }
-
-    @Override
-    public void listFoldersFailed(Account account, String message)
-    {
-      if (!account.equals(mAccount))
-      {
-        return;
-      }
-    mHandler.progress(false);
-    }
-
-    @Override
-    public void listFoldersFinished(Account account)
-    {
-      if (!account.equals(mAccount))
-      {
-        return;
-      }
-      mHandler.progress(false);
-    }
-    @Override
-    public void listFolders(Account account, Folder[] folders)
-    {
-      if (!account.equals(mAccount))
-      {
-        return;
-      }
-      Account.FolderMode aMode = Account.FolderMode.ALL;
-      if (showDisplayableOnly)
-      {
-        aMode = account.getFolderDisplayMode();
-      }
-      else
-      {
-        aMode = account.getFolderTargetMode();
-      }
-      Preferences prefs = Preferences.getPreferences(getApplication().getApplicationContext());
-      ArrayList<String> localFolders = new ArrayList<String>();
-
-      for (Folder folder : folders)
-      {
-        String name = folder.getName();
-
-        // Inbox needs to be compared case-insensitively
-        if(hideCurrentFolder && (name.equals(mFolder) || (Email.INBOX.equalsIgnoreCase(mFolder) && Email.INBOX.equalsIgnoreCase(name)))) {
-          continue;
-        }
-        try
-        {
-          folder.refresh(prefs);
-          Folder.FolderClass fMode = folder.getDisplayClass();
-
-          if ((aMode == Account.FolderMode.FIRST_CLASS && fMode != Folder.FolderClass.FIRST_CLASS)
-              || (aMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
-                  fMode != Folder.FolderClass.FIRST_CLASS &&
-                  fMode != Folder.FolderClass.SECOND_CLASS)
-                  || (aMode == Account.FolderMode.NOT_SECOND_CLASS && fMode == Folder.FolderClass.SECOND_CLASS))
-          {
-            continue;
-          }
-        }
-        catch (MessagingException me)
-        {
-          Log.e(Email.LOG_TAG, "Couldn't get prefs to check for displayability of folder " + folder.getName(), me);
-        }
-        
-        localFolders.add(folder.getName());
-        
-      }
-      
-      if (showOptionNone)
-      {
-        localFolders.add(Email.FOLDER_NONE);
-      }
-      
-      Collections.sort(localFolders, new Comparator<String>() {
-        public int compare(String aName, String bName)
-        {
-          if (Email.INBOX.equalsIgnoreCase(aName))
-          {
-            return -1;
-          }
-          if (Email.INBOX.equalsIgnoreCase(bName))
-          {
-            return 1;
-          }
-          if (Email.FOLDER_NONE.equalsIgnoreCase(aName))
-          {
-            return 1;
-          }
-          if (Email.FOLDER_NONE.equalsIgnoreCase(bName))
-          {
-            return -1;
-          }
-          
-          return aName.compareToIgnoreCase(bName); 
-        }
-      });
-      adapter.setNotifyOnChange(false);
-      adapter.clear();
-      int selectedFolder = -1;
-      int position = 0;
-      for (String name : localFolders) {
-        if (Email.INBOX.equalsIgnoreCase(name))
-        {
-           adapter.add(getString(R.string.special_mailbox_name_inbox));
-           heldInbox = name;
-        }
-        else {
-          adapter.add(name);
-        }
-        
-        if((name.equals(mFolder) || (Email.INBOX.equalsIgnoreCase(mFolder) && Email.INBOX.equalsIgnoreCase(name)))) {
-          selectedFolder = position;
-        }
-        position++;
-      }
-      if (selectedFolder != -1)
-      {
-        mHandler.setSelectedFolder(selectedFolder);
-      }
-      mHandler.dataChanged();
-      
-    }
-  };
-}
Index: jar.jardesc
===================================================================
--- jar.jardesc	(revision 0)
+++ jar.jardesc	(revision 0)
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="MacRoman"?>
+<jardesc>
+<jar path="SmsSync/external/imapstore.jar"/>
+<options buildIfNeeded="true" compress="true" descriptionLocation="/k9mail/jar.jardesc" exportErrors="true" exportWarnings="true" includeDirectoryEntries="false" overwrite="false" saveDescription="true" storeRefactorings="false" useSourceFolders="false"/>
+<storedRefactorings deprecationInfo="true" structuralOnly="false"/>
+<selectedProjects/>
+<manifest generateManifest="true" manifestLocation="" manifestVersion="1.0" reuseManifest="false" saveManifest="false" usesManifest="true">
+<sealing sealJar="false">
+<packagesToSeal/>
+<packagesToUnSeal/>
+</sealing>
+</manifest>
+<selectedElements exportClassFiles="true" exportJavaFiles="false" exportOutputFolder="false">
+<javaElement handleIdentifier="=k9mail/src"/>
+</selectedElements>
+<fatjar builder="org.eclipse.jdt.ui.plain_jar_builder" launchConfig=""/>
+</jardesc>
Index: src/com/android/email/activity/MessageCompose.java
===================================================================
--- src/com/android/email/activity/MessageCompose.java	(revision 718)
+++ src/com/android/email/activity/MessageCompose.java	(working copy)
@@ -1,1295 +0,0 @@
-
-package com.android.email.activity;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.StringTokenizer;
-
-import com.android.email.K9Activity;
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.ActivityInfo;
-import android.database.Cursor;
-import android.net.Uri;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Parcelable;
-import android.provider.OpenableColumns;
-import android.text.TextWatcher;
-import android.text.util.Rfc822Tokenizer;
-import android.util.Config;
-import android.util.Log;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.View;
-import android.view.Window;
-import android.view.View.OnClickListener;
-import android.view.View.OnFocusChangeListener;
-import android.webkit.WebView;
-import android.widget.Button;
-import android.widget.EditText;
-import android.widget.ImageButton;
-import android.widget.LinearLayout;
-import android.widget.MultiAutoCompleteTextView;
-import android.widget.TextView;
-import android.widget.Toast;
-import android.widget.AutoCompleteTextView.Validator;
-
-import com.android.email.Account;
-import com.android.email.Email;
-import com.android.email.EmailAddressAdapter;
-import com.android.email.EmailAddressValidator;
-import com.android.email.MessagingController;
-import com.android.email.MessagingListener;
-import com.android.email.Preferences;
-import com.android.email.R;
-import com.android.email.Utility;
-import com.android.email.mail.Address;
-import com.android.email.mail.Body;
-import com.android.email.mail.Flag;
-import com.android.email.mail.Message;
-import com.android.email.mail.MessagingException;
-import com.android.email.mail.Multipart;
-import com.android.email.mail.Part;
-import com.android.email.mail.Message.RecipientType;
-import com.android.email.mail.internet.MimeBodyPart;
-import com.android.email.mail.internet.MimeHeader;
-import com.android.email.mail.internet.MimeMessage;
-import com.android.email.mail.internet.MimeMultipart;
-import com.android.email.mail.internet.MimeUtility;
-import com.android.email.mail.internet.TextBody;
-import com.android.email.mail.store.LocalStore;
-import com.android.email.mail.store.LocalStore.LocalAttachmentBody;
-
-public class MessageCompose extends K9Activity implements OnClickListener, OnFocusChangeListener {
-    private static final String ACTION_REPLY = "com.android.email.intent.action.REPLY";
-    private static final String ACTION_REPLY_ALL = "com.android.email.intent.action.REPLY_ALL";
-    private static final String ACTION_FORWARD = "com.android.email.intent.action.FORWARD";
-    private static final String ACTION_EDIT_DRAFT = "com.android.email.intent.action.EDIT_DRAFT";
-
-
-    private static final String EXTRA_ACCOUNT = "account";
-    private static final String EXTRA_FOLDER = "folder";
-    private static final String EXTRA_MESSAGE = "message";
-
-    private static final String STATE_KEY_ATTACHMENTS =
-        "com.android.email.activity.MessageCompose.attachments";
-    private static final String STATE_KEY_CC_SHOWN =
-        "com.android.email.activity.MessageCompose.ccShown";
-    private static final String STATE_KEY_BCC_SHOWN =
-        "com.android.email.activity.MessageCompose.bccShown";
-    private static final String STATE_KEY_QUOTED_TEXT_SHOWN =
-        "com.android.email.activity.MessageCompose.quotedTextShown";
-    private static final String STATE_KEY_SOURCE_MESSAGE_PROCED =
-        "com.android.email.activity.MessageCompose.stateKeySourceMessageProced";
-    private static final String STATE_KEY_DRAFT_UID =
-        "com.android.email.activity.MessageCompose.draftUid";
-    private static final String STATE_IDENTITY_CHANGED =
-      "com.android.email.activity.MessageCompose.identityChanged";
-    private static final String STATE_IDENTITY =
-      "com.android.email.activity.MessageCompose.identity";
-
-    private static final int MSG_PROGRESS_ON = 1;
-    private static final int MSG_PROGRESS_OFF = 2;
-    private static final int MSG_UPDATE_TITLE = 3;
-    private static final int MSG_SKIPPED_ATTACHMENTS = 4;
-    private static final int MSG_SAVED_DRAFT = 5;
-    private static final int MSG_DISCARDED_DRAFT = 6;
-
-    private static final int ACTIVITY_REQUEST_PICK_ATTACHMENT = 1;
-    private static final int ACTIVITY_CHOOSE_IDENTITY = 2;
-
-    private Account mAccount;
-    private Account.Identity mIdentity;
-    private boolean mIdentityChanged = false;
-    private boolean mSignatureChanged = false;
-    private String mFolder;
-    private String mSourceMessageUid;
-    private Message mSourceMessage;
-    /**
-     * Indicates that the source message has been processed at least once and should not
-     * be processed on any subsequent loads. This protects us from adding attachments that
-     * have already been added from the restore of the view state.
-     */
-    private boolean mSourceMessageProcessed = false;
-
-
-    private TextView mFromView;
-    private MultiAutoCompleteTextView mToView;
-    private MultiAutoCompleteTextView mCcView;
-    private MultiAutoCompleteTextView mBccView;
-    private EditText mSubjectView;
-    private EditText mSignatureView;
-    private EditText mMessageContentView;
-    private LinearLayout mAttachments;
-    private View mQuotedTextBar;
-    private ImageButton mQuotedTextDelete;
-    private EditText mQuotedText;
-
-    private boolean mDraftNeedsSaving = false;
-
-    /**
-     * The draft uid of this message. This is used when saving drafts so that the same draft is
-     * overwritten instead of being created anew. This property is null until the first save.
-     */
-    private String mDraftUid;
-
-    private Handler mHandler = new Handler() {
-        @Override
-        public void handleMessage(android.os.Message msg) {
-            switch (msg.what) {
-                case MSG_PROGRESS_ON:
-                    setProgressBarIndeterminateVisibility(true);
-                    break;
-                case MSG_PROGRESS_OFF:
-                    setProgressBarIndeterminateVisibility(false);
-                    break;
-                case MSG_UPDATE_TITLE:
-                    updateTitle();
-                    break;
-                case MSG_SKIPPED_ATTACHMENTS:
-                    Toast.makeText(
-                            MessageCompose.this,
-                            getString(R.string.message_compose_attachments_skipped_toast),
-                            Toast.LENGTH_LONG).show();
-                    break;
-                case MSG_SAVED_DRAFT:
-                    Toast.makeText(
-                            MessageCompose.this,
-                            getString(R.string.message_saved_toast),
-                            Toast.LENGTH_LONG).show();
-                    break;
-                case MSG_DISCARDED_DRAFT:
-                    Toast.makeText(
-                            MessageCompose.this,
-                            getString(R.string.message_discarded_toast),
-                            Toast.LENGTH_LONG).show();
-                    break;
-                default:
-                    super.handleMessage(msg);
-                    break;
-            }
-        }
-    };
-
-    private Listener mListener = new Listener();
-    private EmailAddressAdapter mAddressAdapter;
-    private Validator mAddressValidator;
-
-
-    class Attachment implements Serializable {
-        public String name;
-        public String contentType;
-        public long size;
-        public Uri uri;
-    }
-
-    /**
-     * Compose a new message using the given account. If account is null the default account
-     * will be used.
-     * @param context
-     * @param account
-     */
-    public static void actionCompose(Context context, Account account) {
-       Intent i = new Intent(context, MessageCompose.class);
-       i.putExtra(EXTRA_ACCOUNT, account);
-       context.startActivity(i);
-    }
-
-    /**
-     * Compose a new message as a reply to the given message. If replyAll is true the function
-     * is reply all instead of simply reply.
-     * @param context
-     * @param account
-     * @param message
-     * @param replyAll
-     */
-    public static void actionReply(
-            Context context,
-            Account account,
-            Message message,
-            boolean replyAll) { 
-        Intent i = new Intent(context, MessageCompose.class);
-        i.putExtra(EXTRA_ACCOUNT, account);
-        i.putExtra(EXTRA_FOLDER, message.getFolder().getName());
-        i.putExtra(EXTRA_MESSAGE, message.getUid());
-        if (replyAll) {
-            i.setAction(ACTION_REPLY_ALL);
-        }
-        else {
-            i.setAction(ACTION_REPLY);
-        }
-        context.startActivity(i);
-    }
-
-    /**
-     * Compose a new message as a forward of the given message.
-     * @param context
-     * @param account
-     * @param message
-     */
-    public static void actionForward(Context context, Account account, Message message) {
-        Intent i = new Intent(context, MessageCompose.class);
-        i.putExtra(EXTRA_ACCOUNT, account);
-        i.putExtra(EXTRA_FOLDER, message.getFolder().getName());
-        i.putExtra(EXTRA_MESSAGE, message.getUid());
-        i.setAction(ACTION_FORWARD);
-        context.startActivity(i);
-    }
-
-    /**
-     * Continue composition of the given message. This action modifies the way this Activity
-     * handles certain actions.
-     * Save will attempt to replace the message in the given folder with the updated version.
-     * Discard will delete the message from the given folder.
-     * @param context
-     * @param account
-     * @param folder
-     * @param message
-     */
-    public static void actionEditDraft(Context context, Account account, Message message) {
-        Intent i = new Intent(context, MessageCompose.class);
-        i.putExtra(EXTRA_ACCOUNT, account);
-        i.putExtra(EXTRA_FOLDER, message.getFolder().getName());
-        i.putExtra(EXTRA_MESSAGE, message.getUid());
-        i.setAction(ACTION_EDIT_DRAFT);
-        context.startActivity(i);
-    }
-
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
-
-        setContentView(R.layout.message_compose);
-
-        mAddressAdapter = new EmailAddressAdapter(this);
-        mAddressValidator = new EmailAddressValidator();
-
-
-        mFromView = (TextView)findViewById(R.id.from);
-        mToView = (MultiAutoCompleteTextView)findViewById(R.id.to);
-        mCcView = (MultiAutoCompleteTextView)findViewById(R.id.cc);
-        mBccView = (MultiAutoCompleteTextView)findViewById(R.id.bcc);
-        mSubjectView = (EditText)findViewById(R.id.subject);
-        
-        EditText upperSignature = (EditText)findViewById(R.id.upper_signature);
-        EditText lowerSignature = (EditText)findViewById(R.id.lower_signature);
-        
-        
-        mMessageContentView = (EditText)findViewById(R.id.message_content);
-        mAttachments = (LinearLayout)findViewById(R.id.attachments);
-        mQuotedTextBar = findViewById(R.id.quoted_text_bar);
-        mQuotedTextDelete = (ImageButton)findViewById(R.id.quoted_text_delete);
-        mQuotedText = (EditText)findViewById(R.id.quoted_text);
-
-        TextWatcher watcher = new TextWatcher() {
-            public void beforeTextChanged(CharSequence s, int start,
-                                          int before, int after) { }
-
-            public void onTextChanged(CharSequence s, int start,
-                                          int before, int count) {
-                mDraftNeedsSaving = true;
-            }
-
-            public void afterTextChanged(android.text.Editable s) { }
-        };
-
-        TextWatcher sigwatcher = new TextWatcher() {
-            public void beforeTextChanged(CharSequence s, int start,
-                                          int before, int after) { }
-
-            public void onTextChanged(CharSequence s, int start,
-                                          int before, int count) {
-                mDraftNeedsSaving = true;
-                mSignatureChanged = true;
-            }
-
-            public void afterTextChanged(android.text.Editable s) { }
-        };
-
-        mToView.addTextChangedListener(watcher);
-        mCcView.addTextChangedListener(watcher);
-        mBccView.addTextChangedListener(watcher);
-        mSubjectView.addTextChangedListener(watcher);
-        
-        mMessageContentView.addTextChangedListener(watcher);
-
-        /*
-         * We set this to invisible by default. Other methods will turn it back on if it's
-         * needed.
-         */
-        mQuotedTextBar.setVisibility(View.GONE);
-        mQuotedText.setVisibility(View.GONE);
-
-        mQuotedTextDelete.setOnClickListener(this);
-
-        mFromView.setVisibility(View.GONE);
-               
-        mToView.setAdapter(mAddressAdapter);
-        mToView.setTokenizer(new Rfc822Tokenizer());
-        mToView.setValidator(mAddressValidator);
-
-        mCcView.setAdapter(mAddressAdapter);
-        mCcView.setTokenizer(new Rfc822Tokenizer());
-        mCcView.setValidator(mAddressValidator);
-
-        mBccView.setAdapter(mAddressAdapter);
-        mBccView.setTokenizer(new Rfc822Tokenizer());
-        mBccView.setValidator(mAddressValidator);
-
-
-        mSubjectView.setOnFocusChangeListener(this);
-
-        if (savedInstanceState != null) {
-            /*
-             * This data gets used in onCreate, so grab it here instead of onRestoreIntstanceState
-             */
-            mSourceMessageProcessed = savedInstanceState.getBoolean(STATE_KEY_SOURCE_MESSAGE_PROCED, false);
-        }
-
-        Intent intent = getIntent();
-
-        String action = intent.getAction();
-
-        if (Intent.ACTION_VIEW.equals(action) || Intent.ACTION_SENDTO.equals(action)) {
-            /*
-             * Someone has clicked a mailto: link. The address is in the URI.
-             */
-            mAccount = Preferences.getPreferences(this).getDefaultAccount();
-            if (mAccount == null) {
-                /*
-                 * There are no accounts set up. This should not have happened. Prompt the
-                 * user to set up an account as an acceptable bailout.
-                 */
-                startActivity(new Intent(this, Accounts.class));
-                mDraftNeedsSaving = false;
-                finish();
-                return;
-            }
-            if (intent.getData() != null) {
-                Uri uri = intent.getData();
-                try {
-                    if (uri.getScheme().equalsIgnoreCase("mailto")) {
-                        Address[] addresses = Address.parse(uri.getSchemeSpecificPart());
-                        addAddresses(mToView, addresses);
-                    }
-                }
-                catch (Exception e) {
-                    /*
-                     * If we can't extract any information from the URI it's okay. They can
-                     * still compose a message.
-                     */
-                }
-            }
-        }
-        else if (Intent.ACTION_SEND.equals(action)) {
-            /*
-             * Someone is trying to compose an email with an attachment, probably Pictures.
-             * The Intent should contain an EXTRA_STREAM with the data to attach.
-             */
-
-            mAccount = Preferences.getPreferences(this).getDefaultAccount();
-            if (mAccount == null) {
-                /*
-                 * There are no accounts set up. This should not have happened. Prompt the
-                 * user to set up an account as an acceptable bailout.
-                 */
-                startActivity(new Intent(this, Accounts.class));
-                mDraftNeedsSaving = false;
-                finish();
-                return;
-            }
-
-            String text = intent.getStringExtra(Intent.EXTRA_TEXT);
-            if (text != null) {
-            	mMessageContentView.setText(text);
-            }
-            String subject = intent.getStringExtra(Intent.EXTRA_SUBJECT);
-            if (subject != null) {
-            	mSubjectView.setText(subject);
-            }
-            
-            String type = intent.getType();
-            Uri stream = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM);
-            if (stream != null && type != null) {
-                if (MimeUtility.mimeTypeMatches(type, Email.ACCEPTABLE_ATTACHMENT_SEND_TYPES)) {
-                    addAttachment(stream);
-                }
-            }
-
-            /*
-             * There might be an EXTRA_SUBJECT, EXTRA_TEXT, EXTRA_EMAIL, EXTRA_BCC or EXTRA_CC
-             */
-            
-            String extraSubject = intent.getStringExtra(Intent.EXTRA_SUBJECT);
-            String extraText = intent.getStringExtra(Intent.EXTRA_TEXT);
-            String[] extraEmail = intent.getStringArrayExtra(Intent.EXTRA_EMAIL);
-            String[] extraBcc = intent.getStringArrayExtra(Intent.EXTRA_BCC);
-            String[] extraCc = intent.getStringArrayExtra(Intent.EXTRA_CC);
-
-            String addressList = new String();
-            // Cache array size, as per Google's recommendations.
-            int arraySize;
-            int i;
-
-            mSubjectView.setText(extraSubject);
-            mMessageContentView.setText(extraText);
-
-            if (extraEmail != null) {
-                arraySize = extraEmail.length;
-                if (arraySize > 1){
-              	    for (i=0; i < (arraySize-1); i++) {
-                        addressList += extraEmail[i]+", ";
-                    }
-                addressList += extraEmail[arraySize-1];
-                }
-            }
-            mToView.setText(addressList);
-            addressList = "";
-
-            if (extraBcc != null) {
-                arraySize = extraBcc.length;
-                if (arraySize > 1) {
-              	    for (i=0; i < (arraySize-1); i++) {
-                        addressList += extraBcc[i]+", ";
-                    }
-                addressList += extraBcc[arraySize-1];
-                }
-            }
-            mBccView.setText(addressList);
-            addressList = "";
-
-            if (extraCc != null){
-                arraySize = extraCc.length;
-                if (arraySize > 1){
-              	    for (i=0; i < (arraySize-1); i++) {
-                        addressList += extraCc[i]+", ";
-                    }
-                addressList += extraCc[arraySize-1];
-                }
-            }
-            mCcView.setText(addressList);
-            addressList = "";
-
-        } else {
-            mAccount = (Account) intent.getSerializableExtra(EXTRA_ACCOUNT);
-            mFolder = (String) intent.getStringExtra(EXTRA_FOLDER);
-            mSourceMessageUid = (String) intent.getStringExtra(EXTRA_MESSAGE);
-        }
-        
-        if (mIdentity == null)
-        {
-          mIdentity = mAccount.getIdentity(0);
-        }
-        
-        if (mAccount.isSignatureBeforeQuotedText())
-        {
-            mSignatureView = upperSignature;
-            lowerSignature.setVisibility(View.GONE);
-        }
-        else
-        {
-            mSignatureView = lowerSignature;
-            upperSignature.setVisibility(View.GONE);
-        }
-        mSignatureView.addTextChangedListener(sigwatcher);
-        
-        updateFrom();
-        updateSignature();
-               
-        Log.d(Email.LOG_TAG, "action = " + action + ", mAccount = " + mAccount + ", mFolder = " + mFolder + ", mSourceMessageUid = " + mSourceMessageUid);
-        if ((ACTION_REPLY.equals(action) || ACTION_REPLY_ALL.equals(action)) && mAccount != null && mFolder != null && mSourceMessageUid != null) {
-          Log.d(Email.LOG_TAG, "Setting message ANSWERED flag to true");
-          // TODO: Really, we should wait until we send the message, but that would require saving the original
-          // message info along with a Draft copy, in case it is left in Drafts for a while before being sent
-            MessagingController.getInstance(getApplication()).setMessageFlag(mAccount, mFolder, mSourceMessageUid, Flag.ANSWERED, true);
-        }
-
-        if (ACTION_REPLY.equals(action) || ACTION_REPLY_ALL.equals(action) || ACTION_FORWARD.equals(action) || ACTION_EDIT_DRAFT.equals(action)) {
-            /*
-             * If we need to load the message we add ourself as a message listener here
-             * so we can kick it off. Normally we add in onResume but we don't
-             * want to reload the message every time the activity is resumed.
-             * There is no harm in adding twice.
-             */
-            MessagingController.getInstance(getApplication()).addListener(mListener);
-            MessagingController.getInstance(getApplication()).loadMessageForView( mAccount, mFolder, mSourceMessageUid, null);
-        }
-        if (ACTION_REPLY.equals(action) || ACTION_REPLY_ALL.equals(action) || ACTION_EDIT_DRAFT.equals(action)) {
-            //change focus to message body.
-            mMessageContentView.requestFocus();
-        }
-
-        if (!ACTION_EDIT_DRAFT.equals(action)) {
-            addAddress(mBccView, new Address(mAccount.getAlwaysBcc(), ""));
-        }
-
-        updateTitle();
-    }
-
-    public void onResume() {
-        super.onResume();
-        MessagingController.getInstance(getApplication()).addListener(mListener);
-    }
-
-    public void onPause() {
-        super.onPause();
-        saveIfNeeded();
-        MessagingController.getInstance(getApplication()).removeListener(mListener);
-    }
-
-    /**
-     * The framework handles most of the fields, but we need to handle stuff that we
-     * dynamically show and hide:
-     * Attachment list,
-     * Cc field,
-     * Bcc field,
-     * Quoted text,
-     */
-    @Override
-    protected void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        saveIfNeeded();
-        ArrayList<Uri> attachments = new ArrayList<Uri>();
-        for (int i = 0, count = mAttachments.getChildCount(); i < count; i++) {
-            View view = mAttachments.getChildAt(i);
-            Attachment attachment = (Attachment) view.getTag();
-            attachments.add(attachment.uri);
-        }
-        outState.putParcelableArrayList(STATE_KEY_ATTACHMENTS, attachments);
-        outState.putBoolean(STATE_KEY_CC_SHOWN, mCcView.getVisibility() == View.VISIBLE);
-        outState.putBoolean(STATE_KEY_BCC_SHOWN, mBccView.getVisibility() == View.VISIBLE);
-        outState.putBoolean(STATE_KEY_QUOTED_TEXT_SHOWN, mQuotedTextBar.getVisibility() == View.VISIBLE);
-        outState.putBoolean(STATE_KEY_SOURCE_MESSAGE_PROCED, mSourceMessageProcessed);
-        outState.putString(STATE_KEY_DRAFT_UID, mDraftUid);
-        outState.putSerializable(STATE_IDENTITY, mIdentity);
-        outState.putBoolean(STATE_IDENTITY_CHANGED, mIdentityChanged);
-    }
-
-    @Override
-    protected void onRestoreInstanceState(Bundle savedInstanceState) {
-        super.onRestoreInstanceState(savedInstanceState);
-        ArrayList<Parcelable> attachments = (ArrayList<Parcelable>) savedInstanceState.getParcelableArrayList(STATE_KEY_ATTACHMENTS);
-        mAttachments.removeAllViews();
-        for (Parcelable p : attachments) {
-            Uri uri = (Uri) p;
-            addAttachment(uri);
-        }
-
-        mCcView.setVisibility(savedInstanceState.getBoolean(STATE_KEY_CC_SHOWN) ?  View.VISIBLE : View.GONE);
-        mBccView.setVisibility(savedInstanceState.getBoolean(STATE_KEY_BCC_SHOWN) ?  View.VISIBLE : View.GONE);
-        mQuotedTextBar.setVisibility(savedInstanceState.getBoolean(STATE_KEY_QUOTED_TEXT_SHOWN) ?  View.VISIBLE : View.GONE);
-        mQuotedText.setVisibility(savedInstanceState.getBoolean(STATE_KEY_QUOTED_TEXT_SHOWN) ?  View.VISIBLE : View.GONE);
-        mDraftUid = savedInstanceState.getString(STATE_KEY_DRAFT_UID);
-        mIdentity = (Account.Identity)savedInstanceState.getSerializable(STATE_IDENTITY);
-        mIdentityChanged = savedInstanceState.getBoolean(STATE_IDENTITY_CHANGED);
-        updateFrom();
-        updateSignature();
-          
-        mDraftNeedsSaving = false;
-    }
-
-    private void updateTitle() {
-        if (mSubjectView.getText().length() == 0) {
-            setTitle(R.string.compose_title);
-        } else {
-            setTitle(mSubjectView.getText().toString());
-        }
-    }
-
-    public void onFocusChange(View view, boolean focused) {
-        if (!focused) {
-            updateTitle();
-        }
-    }
-
-    private void addAddresses(MultiAutoCompleteTextView view, Address[] addresses) {
-        if (addresses == null) {
-            return;
-        }
-        for (Address address : addresses) {
-            addAddress(view, address);
-        }
-    }
-
-    private void addAddress(MultiAutoCompleteTextView view, Address address) {
-        view.append(address + ", ");
-    }
-
-    private Address[] getAddresses(MultiAutoCompleteTextView view) {
-        Address[] addresses = Address.parseUnencoded(view.getText().toString().trim());
-        return addresses;
-    }
-
-    private MimeMessage createMessage(boolean appendSig) throws MessagingException {
-        MimeMessage message = new MimeMessage();
-        message.setSentDate(new Date());
-        Address from = new Address(mIdentity.getEmail(), mIdentity.getName());
-        message.setFrom(from);
-        message.setRecipients(RecipientType.TO, getAddresses(mToView));
-        message.setRecipients(RecipientType.CC, getAddresses(mCcView));
-        message.setRecipients(RecipientType.BCC, getAddresses(mBccView));
-        message.setSubject(mSubjectView.getText().toString());
-        // XXX TODO - not sure why this won't add header
-        // message.setHeader("X-User-Agent", getString(R.string.message_header_mua));
-
-        /*
-         * Build the Body that will contain the text of the message. We'll decide where to
-         * include it later.
-         */
-
-        String text = mMessageContentView.getText().toString();
-        if (appendSig && mAccount.isSignatureBeforeQuotedText()) {
-            text = appendSignature(text);
-        }
-
-        if (mQuotedTextBar.getVisibility() == View.VISIBLE) {
-            text += "\n" + mQuotedText.getText().toString();
-        }
-            
-        
-        if (appendSig && mAccount.isSignatureBeforeQuotedText() == false) {
-            text = appendSignature(text);
-        }
-
-        TextBody body = new TextBody(text);
-
-        if (mAttachments.getChildCount() > 0) {
-            /*
-             * The message has attachments that need to be included. First we add the part
-             * containing the text that will be sent and then we include each attachment.
-             */
-
-            MimeMultipart mp;
-
-            mp = new MimeMultipart();
-            mp.addBodyPart(new MimeBodyPart(body, "text/plain"));
-
-            for (int i = 0, count = mAttachments.getChildCount(); i < count; i++) {
-                Attachment attachment = (Attachment) mAttachments.getChildAt(i).getTag();
-                MimeBodyPart bp = new MimeBodyPart( new LocalStore.LocalAttachmentBody(attachment.uri, getApplication()));
-                bp.setHeader(MimeHeader.HEADER_CONTENT_TYPE, String.format("%s;\n name=\"%s\"", attachment.contentType, attachment.name));
-                bp.setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, "base64");
-                bp.setHeader(MimeHeader.HEADER_CONTENT_DISPOSITION, String.format("attachment;\n filename=\"%s\"", attachment.name));
-                mp.addBodyPart(bp);
-            }
-
-            message.setBody(mp);
-        }
-        else {
-            /*
-             * No attachments to include, just stick the text body in the message and call
-             * it good.
-             */
-            message.setBody(body);
-        }
-
-        return message;
-    }
-
-    private String appendSignature (String text) {
-        String signature= mSignatureView.getText().toString();
-        
-       if (signature != null && ! signature.contentEquals("")){
-         text += "\n" + signature;
-        }
-
-        return text;
-    }
-
-    private void sendOrSaveMessage(boolean save) {
-        /*
-         * Create the message from all the data the user has entered.
-         */
-        MimeMessage message;
-        try {
-            message = createMessage(!save);  // Only append sig on save
-        }
-        catch (MessagingException me) {
-            Log.e(Email.LOG_TAG, "Failed to create new message for send or save.", me);
-            throw new RuntimeException("Failed to create a new message for send or save.", me);
-        }
-
-        if (save) {
-            /*
-             * Save a draft
-             */
-            if (mDraftUid != null) {
-                message.setUid(mDraftUid);
-            }
-            else if (ACTION_EDIT_DRAFT.equals(getIntent().getAction())) {
-                /*
-                 * We're saving a previously saved draft, so update the new message's uid
-                 * to the old message's uid.
-                 */
-                message.setUid(mSourceMessageUid);
-            }
-            
-            String k9identity = Utility.base64Encode("" + mMessageContentView.getText().toString().length());
-            
-            if (mIdentityChanged || mSignatureChanged)
-            {
-              String signature  = mSignatureView.getText().toString();
-              k9identity += ":" + Utility.base64Encode(signature) ;
-              if (mIdentityChanged)
-              {
-              
-                  String name = mIdentity.getName();
-                  String email = mIdentity.getEmail();
-                  
-                  k9identity +=  ":" + Utility.base64Encode(name) + ":" + Utility.base64Encode(email);
-              }
-            }
-            
-            Log.d(Email.LOG_TAG, "Saving identity: " + k9identity);
-            message.setHeader(Email.K9MAIL_IDENTITY, k9identity);
-            
-            MessagingController.getInstance(getApplication()).saveDraft(mAccount, message);
-            mDraftUid = message.getUid();
-
-            // Don't display the toast if the user is just changing the orientation
-            if ((getChangingConfigurations() & ActivityInfo.CONFIG_ORIENTATION) == 0) {
-                mHandler.sendEmptyMessage(MSG_SAVED_DRAFT);
-            }
-        }
-        else {
-            /*
-             * Send the message
-             * TODO Is it possible for us to be editing a draft with a null source message? Don't
-             * think so. Could probably remove below check.
-             */
-            if (ACTION_EDIT_DRAFT.equals(getIntent().getAction()) && mSourceMessageUid != null) {
-                /*
-                 * We're sending a previously saved draft, so delete the old draft first.
-                 */
-                MessagingController.getInstance(getApplication()).deleteMessage( mAccount, mFolder, mSourceMessage, null);
-            }
-            MessagingController.getInstance(getApplication()).sendMessage(mAccount, message, null);
-        }
-    }
-
-    private void saveIfNeeded() {
-        if (!mDraftNeedsSaving) {
-            return;
-        }
-        mDraftNeedsSaving = false;
-        sendOrSaveMessage(true);
-    }
-
-    private void onSend() {
-        if (getAddresses(mToView).length == 0 && getAddresses(mCcView).length == 0 && getAddresses(mBccView).length == 0) {
-            mToView.setError(getString(R.string.message_compose_error_no_recipients));
-            Toast.makeText(this, getString(R.string.message_compose_error_no_recipients), Toast.LENGTH_LONG).show();
-            return;
-        }
-        sendOrSaveMessage(false);
-        mDraftNeedsSaving = false;
-        finish();
-    }
-
-    private void onDiscard() {
-        if (mSourceMessageUid != null) {
-            if (ACTION_EDIT_DRAFT.equals(getIntent().getAction()) && mSourceMessageUid != null) {
-                MessagingController.getInstance(getApplication()).deleteMessage( mAccount, mFolder, mSourceMessage, null);
-            }
-        }
-        mHandler.sendEmptyMessage(MSG_DISCARDED_DRAFT);
-        mDraftNeedsSaving = false;
-        finish();
-    }
-
-    private void onSave() {
-        saveIfNeeded();
-        finish();
-    }
-
-    private void onAddCcBcc() {
-        mCcView.setVisibility(View.VISIBLE);
-        mBccView.setVisibility(View.VISIBLE);
-    }
-
-    /**
-     * Kick off a picker for whatever kind of MIME types we'll accept and let Android take over.
-     */
-    private void onAddAttachment() {
-        Intent i = new Intent(Intent.ACTION_GET_CONTENT);
-        i.addCategory(Intent.CATEGORY_OPENABLE);
-        i.setType(Email.ACCEPTABLE_ATTACHMENT_SEND_TYPES[0]);
-        startActivityForResult(Intent.createChooser(i, null), ACTIVITY_REQUEST_PICK_ATTACHMENT);
-    }
-
-    private void addAttachment(Uri uri) {
-        addAttachment(uri, -1, null);
-    }
-
-    private void addAttachment(Uri uri, int size, String name) {
-        ContentResolver contentResolver = getContentResolver();
-
-        String contentType = contentResolver.getType(uri);
-
-        if (contentType == null) {
-            contentType = "";
-        }
-
-        Attachment attachment = new Attachment();
-        attachment.name = name;
-        attachment.contentType = contentType;
-        attachment.size = size;
-        attachment.uri = uri;
-
-        if (attachment.size == -1 || attachment.name == null) {
-            Cursor metadataCursor = contentResolver.query( uri, new String[]{ OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE }, null, null, null);
-            if (metadataCursor != null) {
-                try {
-                    if (metadataCursor.moveToFirst()) {
-                        if (attachment.name == null) {
-                            attachment.name = metadataCursor.getString(0);
-                        }
-                        if (attachment.size == -1) {
-                            attachment.size = metadataCursor.getInt(1);
-                        }
-                    }
-                } finally {
-                    metadataCursor.close();
-                }
-            }
-        }
-
-        if (attachment.name == null) {
-            attachment.name = uri.getLastPathSegment();
-        }
-
-        View view = getLayoutInflater().inflate( R.layout.message_compose_attachment, mAttachments, false);
-        TextView nameView = (TextView)view.findViewById(R.id.attachment_name);
-        ImageButton delete = (ImageButton)view.findViewById(R.id.attachment_delete);
-        nameView.setText(attachment.name);
-        delete.setOnClickListener(this);
-        delete.setTag(view);
-        view.setTag(attachment);
-        mAttachments.addView(view);
-    }
-
-    @Override
-    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
-      if(resultCode != RESULT_OK)
-        return;
-        if (data == null) {
-            return;
-        }
-      switch(requestCode) {
-        case ACTIVITY_REQUEST_PICK_ATTACHMENT:
-          
-        addAttachment(data.getData());
-        mDraftNeedsSaving = true;
-          break;
-        case ACTIVITY_CHOOSE_IDENTITY:
-          onIdentityChosen(data);
-          break;
-    }
-    }
-
-    private void onIdentityChosen(Intent intent)
-    {
-      Bundle bundle = intent.getExtras();;
-      mIdentity = (Account.Identity)bundle.getSerializable(ChooseIdentity.EXTRA_IDENTITY);
-//      if (mIdentityChanged == false)
-//      {
-//          Toast.makeText(this, getString(R.string.identity_will_not_be_saved),
-//                  Toast.LENGTH_LONG).show();
-//      }
-      mIdentityChanged = true;
-      mDraftNeedsSaving = true;
-      updateFrom();
-      updateSignature();
-    }
-    
-    private void updateFrom()
-    {
-      if (mIdentityChanged)
-      {
-        mFromView.setVisibility(View.VISIBLE);
-      }
-      mFromView.setText(getString(R.string.message_view_from_format, mIdentity.getName(), mIdentity.getEmail()));
-    }
-    
-    private void updateSignature()
-    {
-      mSignatureView.setText(mIdentity.getSignature());
-    }
-
-    public void onClick(View view) {
-        switch (view.getId()) {
-            case R.id.attachment_delete:
-                /*
-                 * The view is the delete button, and we have previously set the tag of
-                 * the delete button to the view that owns it. We don't use parent because the
-                 * view is very complex and could change in the future.
-                 */
-                mAttachments.removeView((View) view.getTag());
-                mDraftNeedsSaving = true;
-                break;
-            case R.id.quoted_text_delete:
-                mQuotedTextBar.setVisibility(View.GONE);
-                mQuotedText.setVisibility(View.GONE);
-                mDraftNeedsSaving = true;
-                break;
-        }
-    }
-
-    public boolean onOptionsItemSelected(MenuItem item) {
-        switch (item.getItemId()) {
-            case R.id.send:
-                onSend();
-                break;
-            case R.id.save:
-                onSave();
-                break;
-            case R.id.discard:
-                onDiscard();
-                break;
-            case R.id.add_cc_bcc:
-                onAddCcBcc();
-                break;
-            case R.id.add_attachment:
-                onAddAttachment();
-                break;
-            case R.id.choose_identity:
-              onChooseIdentity();
-              break;
-            default:
-                return super.onOptionsItemSelected(item);
-        }
-        return true;
-    }
-
-    private void onChooseIdentity()
-    {
-        if (mAccount.getIdentities().size() > 1)
-        {
-          Intent intent = new Intent(this, ChooseIdentity.class);
-          intent.putExtra(ChooseIdentity.EXTRA_ACCOUNT, mAccount);
-          startActivityForResult(intent, ACTIVITY_CHOOSE_IDENTITY);
-        }
-        else
-        {
-            Toast.makeText(this, getString(R.string.no_identities),
-                    Toast.LENGTH_LONG).show();
-        }
-    }
-
-    public boolean onCreateOptionsMenu(Menu menu) {
-        super.onCreateOptionsMenu(menu);
-        getMenuInflater().inflate(R.menu.message_compose_option, menu);
-     
-        return true;
-    }
-
-    /**
-     * Returns true if all attachments were able to be attached, otherwise returns false.
-     */
-    private boolean loadAttachments(Part part, int depth) throws MessagingException {
-        if (part.getBody() instanceof Multipart) {
-            Multipart mp = (Multipart) part.getBody();
-            boolean ret = true;
-            for (int i = 0, count = mp.getCount(); i < count; i++) {
-                if (!loadAttachments(mp.getBodyPart(i), depth + 1)) {
-                    ret = false;
-                }
-            }
-            return ret;
-        } else {
-            String contentType = MimeUtility.unfoldAndDecode(part.getContentType());
-            String name = MimeUtility.getHeaderParameter(contentType, "name");
-            if (name != null) {
-                Body body = part.getBody();
-                if (body != null && body instanceof LocalAttachmentBody) {
-                    final Uri uri = ((LocalAttachmentBody) body).getContentUri();
-                    mHandler.post(new Runnable() {
-                        public void run() {
-                            addAttachment(uri);
-                        }
-                    });
-                }
-                else {
-                    return false;
-                }
-            }
-            return true;
-        }
-    }
-
-    /**
-     * Pull out the parts of the now loaded source message and apply them to the new message
-     * depending on the type of message being composed.
-     * @param message
-     */
-    private void processSourceMessage(Message message) {
-        String action = getIntent().getAction();
-        if (ACTION_REPLY.equals(action) || ACTION_REPLY_ALL.equals(action)) {
-            try {
-                if (message.getSubject() != null && !message.getSubject().toLowerCase().startsWith("re:")) {
-                    mSubjectView.setText("Re: " + message.getSubject());
-                }
-                else {
-                    mSubjectView.setText(message.getSubject());
-                }
-                /*
-                 * If a reply-to was included with the message use that, otherwise use the from
-                 * or sender address.
-                 */
-                Address[] replyToAddresses;
-                if (message.getReplyTo().length > 0) {
-                    addAddresses(mToView, replyToAddresses = message.getReplyTo());
-                }
-                else {
-                    addAddresses(mToView, replyToAddresses = message.getFrom());
-                }
-                
-                Part part = MimeUtility.findFirstPartByMimeType(mSourceMessage,
-                        "text/plain");
-                if (part != null) {
-                    String quotedText = String.format(
-                            getString(R.string.message_compose_reply_header_fmt),
-                            Address.toString(mSourceMessage.getFrom()));
-                    
-                    quotedText += MimeUtility.getTextFromPart(part).replaceAll("(?m)^", ">");
-                    mQuotedText.setText(quotedText);
-
-                    mQuotedTextBar.setVisibility(View.VISIBLE);
-                    mQuotedText.setVisibility(View.VISIBLE);
-                }
-                
-                if (ACTION_REPLY_ALL.equals(action)) {
-                    for (Address address : message.getRecipients(RecipientType.TO)) {
-                        if (!mAccount.isAnIdentity(address)) {
-                            addAddress(mToView, address);
-                        }
-                    }
-                    if (message.getRecipients(RecipientType.CC).length > 0) {
-                        for (Address address : message.getRecipients(RecipientType.CC)) {
-                            if (!Utility.arrayContains(replyToAddresses, address)) {
-                                addAddress(mCcView, address);
-                            }
-                        }
-                        mCcView.setVisibility(View.VISIBLE);
-                    }
-                }
-             }
-            catch (MessagingException me) {
-                /*
-                 * This really should not happen at this point but if it does it's okay.
-                 * The user can continue composing their message.
-                 */
-            }
-        }
-        else if (ACTION_FORWARD.equals(action)) {
-            try {
-                if (message.getSubject() != null && !message.getSubject().toLowerCase().startsWith("fwd:")) {
-                    mSubjectView.setText("Fwd: " + message.getSubject());
-                }
-                else {
-                    mSubjectView.setText(message.getSubject());
-                }
-                Part part = MimeUtility.findFirstPartByMimeType(message, "text/plain");
-                if (part == null) {
-                    part = MimeUtility.findFirstPartByMimeType(message, "text/html");
-                }
-                if (part != null) {
-                    String quotedText = MimeUtility.getTextFromPart(part);
-                    if (quotedText != null) {
-                        String text = String.format(
-                                getString(R.string.message_compose_fwd_header_fmt),
-                                mSourceMessage.getSubject(),
-                                Address.toString(mSourceMessage.getFrom()),
-                                Address.toString(
-                                        mSourceMessage.getRecipients(RecipientType.TO)),
-                                Address.toString(
-                                        mSourceMessage.getRecipients(RecipientType.CC)));
-                    
-                        text += quotedText;
-                        mQuotedText.setText(text);
-                        mQuotedTextBar.setVisibility(View.VISIBLE);
-                        mQuotedText.setVisibility(View.VISIBLE);
-                    }
-                }
-                if (!mSourceMessageProcessed) {
-                    if (!loadAttachments(message, 0)) {
-                        mHandler.sendEmptyMessage(MSG_SKIPPED_ATTACHMENTS);
-                    }
-                }
-            }
-            catch (MessagingException me) {
-                /*
-                 * This really should not happen at this point but if it does it's okay.
-                 * The user can continue composing their message.
-                 */
-            }
-        }
-        else if (ACTION_EDIT_DRAFT.equals(action)) {
-            try {
-                mSubjectView.setText(message.getSubject());
-                addAddresses(mToView, message.getRecipients(RecipientType.TO));
-                if (message.getRecipients(RecipientType.CC).length > 0) {
-                    addAddresses(mCcView, message.getRecipients(RecipientType.CC));
-                    mCcView.setVisibility(View.VISIBLE);
-                }
-                if (message.getRecipients(RecipientType.BCC).length > 0) {
-                    addAddresses(mBccView, message.getRecipients(RecipientType.BCC));
-                    mBccView.setVisibility(View.VISIBLE);
-                }
-                
-                if (!mSourceMessageProcessed) {
-                    loadAttachments(message, 0);
-                }
-                Integer bodyLength = null;
-                String[] k9identities = message.getHeader(Email.K9MAIL_IDENTITY);
-                if (k9identities != null && k9identities.length > 0)
-                {
-                  String k9identity = k9identities[0];
-                
-                  if (k9identity != null)
-                  {
-                    Log.d(Email.LOG_TAG, "Got a saved identity: " + k9identity);
-                    StringTokenizer tokens = new StringTokenizer(k9identity, ":", false);
-                    
-                    String bodyLengthS = null;
-                    String name = null;
-                    String email = null;
-                    String signature = null;
-                    if (tokens.hasMoreTokens())
-                    {
-                      bodyLengthS = Utility.base64Decode(tokens.nextToken());
-                      try
-                      {
-                          bodyLength = Integer.parseInt(bodyLengthS);
-                      }
-                      catch (Exception e)
-                      {
-                          Log.e(Email.LOG_TAG, "Unable to parse bodyLength '" + bodyLengthS + "'");
-                      }
-                    }
-                    if (tokens.hasMoreTokens())
-                    {
-                      signature = Utility.base64Decode(tokens.nextToken());
-                    }
-                    if (tokens.hasMoreTokens())
-                    {
-                      name = Utility.base64Decode(tokens.nextToken());
-                    }
-                    if (tokens.hasMoreTokens())
-                    {
-                      email = Utility.base64Decode(tokens.nextToken());
-                    }
-                    
-                    Account.Identity newIdentity= mAccount.new Identity();
-                    if (signature != null)
-                    {
-                        newIdentity.setSignature(signature); 
-                        mSignatureChanged = true;
-                    }
-                    else
-                    {
-                        newIdentity.setSignature(mIdentity.getSignature());
-                    }
-                    
-                    if (name != null)
-                    {
-                        newIdentity.setName(name);
-                        mIdentityChanged = true;
-                    }
-                    else
-                    {
-                        newIdentity.setName(mIdentity.getName());
-                    }
-                    
-                    if (email != null)
-                    {
-                        newIdentity.setEmail(email);
-                        mIdentityChanged = true;
-                    }
-                    else
-                    {
-                        newIdentity.setEmail(mIdentity.getEmail());
-                    }
-                    
-                    mIdentity = newIdentity;
-                    
-                    updateSignature();
-                    updateFrom();
-                    
-                  }
-                }
-                Part part = MimeUtility.findFirstPartByMimeType(message, "text/plain");
-                if (part != null) {
-                    String text = MimeUtility.getTextFromPart(part);
-                    if (bodyLength != null && bodyLength + 1 < text.length())   // + 1 to get rid of the newline we added when saving the draft
-                    {
-                        String bodyText = text.substring(0, bodyLength);
-                        String quotedText = text.substring(bodyLength + 1, text.length());
-
-                        mMessageContentView.setText(bodyText);
-                        mQuotedText.setText(quotedText);
-
-                        mQuotedTextBar.setVisibility(View.VISIBLE);
-                        mQuotedText.setVisibility(View.VISIBLE);
-                    }
-                    else
-                    {
-                    mMessageContentView.setText(text);
-                }
-                }
-            }
-            catch (MessagingException me) {
-                // TODO
-            }
-        }
-        mSourceMessageProcessed = true;
-        mDraftNeedsSaving = false;
-    }
-
-    class Listener extends MessagingListener {
-        @Override
-        public void loadMessageForViewStarted(Account account, String folder, String uid) {
-            mHandler.sendEmptyMessage(MSG_PROGRESS_ON);
-        }
-
-        @Override
-        public void loadMessageForViewFinished(Account account, String folder, String uid, Message message) {
-            mHandler.sendEmptyMessage(MSG_PROGRESS_OFF);
-        }
-
-        @Override
-        public void loadMessageForViewBodyAvailable(Account account, String folder, String uid, final Message message) {
-            mSourceMessage = message;
-            runOnUiThread(new Runnable() {
-                public void run() {
-                    processSourceMessage(message);
-                }
-            });
-        }
-
-        @Override
-        public void loadMessageForViewFailed(Account account, String folder, String uid, final String message) {
-            mHandler.sendEmptyMessage(MSG_PROGRESS_OFF);
-            // TODO show network error
-        }
-
-        @Override
-        public void messageUidChanged( Account account, String folder, String oldUid, String newUid) {
-            if (account.equals(mAccount) && (folder.equals(mFolder) || (mFolder == null && folder.equals(mAccount.getDraftsFolderName())))) {
-                if (oldUid.equals(mDraftUid)) {
-                    mDraftUid = newUid;
-                }
-                if (oldUid.equals(mSourceMessageUid)) {
-                    mSourceMessageUid = newUid;
-                }
-                if (mSourceMessage != null && (oldUid.equals(mSourceMessage.getUid()))) {
-                    mSourceMessage.setUid(newUid);
-                }
-            }
-        }
-    }
-}
Index: src/com/android/email/activity/setup/AccountSetupCheckSettings.java
===================================================================
--- src/com/android/email/activity/setup/AccountSetupCheckSettings.java	(revision 718)
+++ src/com/android/email/activity/setup/AccountSetupCheckSettings.java	(working copy)
@@ -1,306 +0,0 @@
-
-package com.android.email.activity.setup;
-
-import java.security.cert.CertificateException;
-import java.security.cert.X509Certificate;
-
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Process;
-
-import android.util.Log;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.widget.Button;
-import android.widget.ProgressBar;
-import android.widget.TextView;
-
-import com.android.email.K9Activity;
-import com.android.email.Account;
-import com.android.email.Email;
-import com.android.email.MessagingController;
-import com.android.email.R;
-import com.android.email.mail.AuthenticationFailedException;
-import com.android.email.mail.MessagingException;
-import com.android.email.mail.Store;
-import com.android.email.mail.Transport;
-import com.android.email.mail.CertificateValidationException;
-import com.android.email.mail.store.TrustManagerFactory;
-
-/**
- * Checks the given settings to make sure that they can be used to send and
- * receive mail.
- *
- * XXX NOTE: The manifest for this app has it ignore config changes, because
- * it doesn't correctly deal with restarting while its thread is running.
- */
-public class AccountSetupCheckSettings extends K9Activity implements OnClickListener {
-	
-	public static final int ACTIVITY_REQUEST_CODE = 1;
-	
-    private static final String EXTRA_ACCOUNT = "account";
-
-    private static final String EXTRA_CHECK_INCOMING = "checkIncoming";
-
-    private static final String EXTRA_CHECK_OUTGOING = "checkOutgoing";
-
-    private Handler mHandler = new Handler();
-
-    private ProgressBar mProgressBar;
-
-    private TextView mMessageView;
-
-    private Account mAccount;
-
-    private boolean mCheckIncoming;
-
-    private boolean mCheckOutgoing;
-
-    private boolean mCanceled;
-
-    private boolean mDestroyed;
-
-    public static void actionCheckSettings(Activity context, Account account,
-            boolean checkIncoming, boolean checkOutgoing) {
-        Intent i = new Intent(context, AccountSetupCheckSettings.class);
-        i.putExtra(EXTRA_ACCOUNT, account);
-        i.putExtra(EXTRA_CHECK_INCOMING, checkIncoming);
-        i.putExtra(EXTRA_CHECK_OUTGOING, checkOutgoing);
-        context.startActivityForResult(i, ACTIVITY_REQUEST_CODE);
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.account_setup_check_settings);
-        mMessageView = (TextView)findViewById(R.id.message);
-        mProgressBar = (ProgressBar)findViewById(R.id.progress);
-        ((Button)findViewById(R.id.cancel)).setOnClickListener(this);
-
-        setMessage(R.string.account_setup_check_settings_retr_info_msg);
-        mProgressBar.setIndeterminate(true);
-
-        mAccount = (Account)getIntent().getSerializableExtra(EXTRA_ACCOUNT);
-        mCheckIncoming = (boolean)getIntent().getBooleanExtra(EXTRA_CHECK_INCOMING, false);
-        mCheckOutgoing = (boolean)getIntent().getBooleanExtra(EXTRA_CHECK_OUTGOING, false);
-
-        new Thread() {
-            public void run() {
-            	Store store = null;
-                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
-                try {
-                    if (mDestroyed) {
-                        return;
-                    }
-                    if (mCanceled) {
-                        finish();
-                        return;
-                    }
-                    if (mCheckIncoming) {
-                    	setMessage(R.string.account_setup_check_settings_check_incoming_msg);
-                    	store = Store.getInstance(mAccount.getStoreUri(), getApplication());
-                    	store.checkSettings();
-				        new Thread() {
-	
-				            public void run() {
-				                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
-				                MessagingController.getInstance(getApplication()).listFolders(mAccount, true, null);
-                                    MessagingController.getInstance(getApplication()).synchronizeMailbox( mAccount, Email.INBOX , null);
-				
-				            }
-				        }.start();
-				
-
-                    }
-                    if (mDestroyed) {
-                        return;
-                    }
-                    if (mCanceled) {
-                        finish();
-                        return;
-                    }
-                    if (mCheckOutgoing) {
-                        setMessage(R.string.account_setup_check_settings_check_outgoing_msg);
-                        Transport transport = Transport.getInstance(mAccount.getTransportUri());
-                        transport.close();
-                        transport.open();
-                        transport.close();
-                    }
-                    if (mDestroyed) {
-                        return;
-                    }
-                    if (mCanceled) {
-                        finish();
-                        return;
-                    }
-                    setResult(RESULT_OK);
-                    finish();
-                } catch (final AuthenticationFailedException afe) {
-                  Log.e(Email.LOG_TAG, "Error while testing settings", afe);
-                    showErrorDialog(
-                            R.string.account_setup_failed_dlg_auth_message_fmt,
-                            afe.getMessage() == null ? "" : afe.getMessage());
-                } catch (final CertificateValidationException cve) {
-                  Log.e(Email.LOG_TAG, "Error while testing settings", cve);
-                	acceptKeyDialog(
-                            R.string.account_setup_failed_dlg_certificate_message_fmt,
-                            cve);
-                } catch (final Throwable t) {
-                  Log.e(Email.LOG_TAG, "Error while testing settings", t);
-                    showErrorDialog(
-                            R.string.account_setup_failed_dlg_server_message_fmt,
-                            (t.getMessage() == null ? "" : t.getMessage()));
-                	
-                }
-            }
-
-        }.start();
-    }
-
-    @Override
-    public void onDestroy() {
-        super.onDestroy();
-        mDestroyed = true;
-        mCanceled = true;
-    }
-
-    private void setMessage(final int resId) {
-        mHandler.post(new Runnable() {
-            public void run() {
-                if (mDestroyed) {
-                    return;
-                }
-                mMessageView.setText(getString(resId));
-            }
-        });
-    }
-
-    private void showErrorDialog(final int msgResId, final Object... args) {
-        mHandler.post(new Runnable() {
-            public void run() {
-                if (mDestroyed) {
-                    return;
-                }
-                mProgressBar.setIndeterminate(false);
-                new AlertDialog.Builder(AccountSetupCheckSettings.this)
-                        .setTitle(getString(R.string.account_setup_failed_dlg_title))
-                        .setMessage(getString(msgResId, args))
-                        .setCancelable(true)
-                        .setNegativeButton(
-                                getString(R.string.account_setup_failed_dlg_continue_action),
-
-                                new DialogInterface.OnClickListener() {
-                                    public void onClick(DialogInterface dialog, int which) {
-                                        mCanceled=false;
-                                        setResult(RESULT_OK);
-                                        finish();
-                                    }
-                                })
-                        .setPositiveButton(
-                                getString(R.string.account_setup_failed_dlg_edit_details_action),
-                                new DialogInterface.OnClickListener() {
-                                    public void onClick(DialogInterface dialog, int which) {
-                                        finish();
-                                    }
-                                })
-                        .show();
-            }
-        });
-    }
-    private void acceptKeyDialog(final int msgResId, final Object... args) {
-        mHandler.post(new Runnable() {
-            public void run() {
-                if (mDestroyed) {
-                    return;
-                }
-                final X509Certificate[] chain = TrustManagerFactory.getLastCertChain();
-                String exMessage = "Unknown Error";
-                
-                Exception ex = ((Exception)args[0]);
-                if (ex != null) {
-                	if (ex.getCause() != null) {
-                    	if (ex.getCause().getCause() != null) {
-                    		exMessage = ex.getCause().getCause().getMessage();
-                    		
-                    	} else {
-                    		exMessage = ex.getCause().getMessage();
-                    	}
-                	} else {
-                		exMessage = ex.getMessage();
-                	}
-                }
-                
-                mProgressBar.setIndeterminate(false);
-                StringBuffer chainInfo = new StringBuffer(100);
-                for (int i = 0; i < chain.length; i++)
-                {
-                   // display certificate chain information
-                    chainInfo.append("Certificate chain[" + i + "]:\n");
-                    chainInfo.append("Subject: " + chain[i].getSubjectDN().toString() + "\n");
-                    chainInfo.append("Issuer: " + chain[i].getIssuerDN().toString() + "\n");
-                }
-
-                new AlertDialog.Builder(AccountSetupCheckSettings.this)
-                        .setTitle(getString(R.string.account_setup_failed_dlg_invalid_certificate_title))
-                        //.setMessage(getString(R.string.account_setup_failed_dlg_invalid_certificate)
-                        .setMessage(getString(msgResId,exMessage)
-                        		+ " " + chainInfo.toString()
-                        		)
-                        .setCancelable(true)
-                        .setPositiveButton(
-                        		getString(R.string.account_setup_failed_dlg_invalid_certificate_accept),
-                                new DialogInterface.OnClickListener() {
-                                    public void onClick(DialogInterface dialog, int which) {
-                                    	try {
-                                    		String alias = mAccount.getUuid();
-                                    		if (mCheckIncoming) {
-                                    			alias = alias + ".incoming";
-                                    		}
-                                    		if (mCheckOutgoing) {
-                                    			alias = alias + ".outgoing";
-                                    		}
-											TrustManagerFactory.addCertificateChain(alias, chain);
-										} catch (CertificateException e) {
-						                	showErrorDialog(
-						                            R.string.account_setup_failed_dlg_certificate_message_fmt,
-						                            e.getMessage() == null ? "" : e.getMessage());											
-										}
-                                    	AccountSetupCheckSettings.actionCheckSettings(AccountSetupCheckSettings.this, mAccount,
-                                                mCheckIncoming, mCheckOutgoing);
-                                    }
-                                })
-                        .setNegativeButton(
-                        		getString(R.string.account_setup_failed_dlg_invalid_certificate_reject),
-                                new DialogInterface.OnClickListener() {
-                                    public void onClick(DialogInterface dialog, int which) {
-                                        finish();
-                                    }
-                                })
-                        .show();
-            }
-        });
-    }
-
-    public void onActivityResult(int reqCode, int resCode, Intent data) {
-    	setResult(resCode);
-    	finish();
-    }
-
-    
-    private void onCancel() {
-        mCanceled = true;
-        setMessage(R.string.account_setup_check_settings_canceling_msg);
-    }
-
-    public void onClick(View v) {
-        switch (v.getId()) {
-            case R.id.cancel:
-                onCancel();
-                break;
-        }
-    }
-}
Index: src/com/android/email/activity/setup/AccountSetupNames.java
===================================================================
--- src/com/android/email/activity/setup/AccountSetupNames.java	(revision 718)
+++ src/com/android/email/activity/setup/AccountSetupNames.java	(working copy)
@@ -1,103 +0,0 @@
-
-package com.android.email.activity.setup;
-
-import com.android.email.K9Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.os.Bundle;
-import android.text.Editable;
-import android.text.TextWatcher;
-import android.text.method.TextKeyListener;
-import android.text.method.TextKeyListener.Capitalize;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.widget.Button;
-import android.widget.EditText;
-
-import com.android.email.Account;
-import com.android.email.Email;
-import com.android.email.Preferences;
-import com.android.email.R;
-import com.android.email.Utility;
-import com.android.email.activity.FolderList;
-
-public class AccountSetupNames extends K9Activity implements OnClickListener {
-    private static final String EXTRA_ACCOUNT = "account";
-
-    private EditText mDescription;
-
-    private EditText mName;
-
-    private Account mAccount;
-
-    private Button mDoneButton;
-
-    public static void actionSetNames(Context context, Account account) {
-        Intent i = new Intent(context, AccountSetupNames.class);
-        i.putExtra(EXTRA_ACCOUNT, account);
-        context.startActivity(i);
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.account_setup_names);
-        mDescription = (EditText)findViewById(R.id.account_description);
-        mName = (EditText)findViewById(R.id.account_name);
-        mDoneButton = (Button)findViewById(R.id.done);
-        mDoneButton.setOnClickListener(this);
-
-        TextWatcher validationTextWatcher = new TextWatcher() {
-            public void afterTextChanged(Editable s) {
-                validateFields();
-            }
-
-            public void beforeTextChanged(CharSequence s, int start, int count, int after) {
-            }
-
-            public void onTextChanged(CharSequence s, int start, int before, int count) {
-            }
-        };
-        mName.addTextChangedListener(validationTextWatcher);
-        
-        mName.setKeyListener(TextKeyListener.getInstance(false, Capitalize.WORDS));
-
-        mAccount = (Account)getIntent().getSerializableExtra(EXTRA_ACCOUNT);
-
-        /*
-         * Since this field is considered optional, we don't set this here. If
-         * the user fills in a value we'll reset the current value, otherwise we
-         * just leave the saved value alone.
-         */
-        // mDescription.setText(mAccount.getDescription());
-        if (mAccount.getName() != null) {
-            mName.setText(mAccount.getName());
-        }
-        if (!Utility.requiredFieldValid(mName)) {
-            mDoneButton.setEnabled(false);
-        }
-    }
-
-    private void validateFields() {
-        mDoneButton.setEnabled(Utility.requiredFieldValid(mName));
-        Utility.setCompoundDrawablesAlpha(mDoneButton, mDoneButton.isEnabled() ? 255 : 128);
-    }
-
-    private void onNext() {
-        if (Utility.requiredFieldValid(mDescription)) {
-            mAccount.setDescription(mDescription.getText().toString());
-        }
-        mAccount.setName(mName.getText().toString());
-        mAccount.save(Preferences.getPreferences(this));
-        FolderList.actionHandleAccount(this, mAccount, Email.INBOX);
-        finish();
-    }
-
-    public void onClick(View v) {
-        switch (v.getId()) {
-            case R.id.done:
-                onNext();
-                break;
-        }
-    }
-}
Index: src/com/android/email/activity/ManageIdentities.java
===================================================================
--- src/com/android/email/activity/ManageIdentities.java	(revision 718)
+++ src/com/android/email/activity/ManageIdentities.java	(working copy)
@@ -1,161 +0,0 @@
-package com.android.email.activity;
-
-import android.content.Intent;
-import android.view.ContextMenu;
-import android.view.KeyEvent;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.View;
-import android.view.ContextMenu.ContextMenuInfo;
-import android.widget.AdapterView;
-import android.widget.ListView;
-import android.widget.Toast;
-import android.widget.AdapterView.AdapterContextMenuInfo;
-
-import com.android.email.Account;
-import com.android.email.Preferences;
-import com.android.email.R;
-
-public class ManageIdentities extends ChooseIdentity
-{
-    private boolean mIdentitiesChanged = false;
-    public static final String EXTRA_IDENTITIES = "com.android.email.EditIdentity_identities";
-
-    private static final int ACTIVITY_EDIT_IDENTITY = 1;
-    protected void setupClickListeners()
-    {
-        this.getListView().setOnItemClickListener(new AdapterView.OnItemClickListener()
-        {
-            public void onItemClick(AdapterView adapterview, View view, int i, long l)
-            {
-                editItem(i);
-            }
-        });
-
-        ListView listView = getListView();
-        registerForContextMenu(listView);
-    }
-
-    private void editItem(int i)
-    {
-        Intent intent = new Intent(ManageIdentities.this, EditIdentity.class);
-
-        intent.putExtra(EditIdentity.EXTRA_ACCOUNT, mAccount);
-        intent.putExtra(EditIdentity.EXTRA_IDENTITY, mAccount.getIdentity(i));
-        intent.putExtra(EditIdentity.EXTRA_IDENTITY_INDEX, i);
-        startActivityForResult(intent, ACTIVITY_EDIT_IDENTITY);
-    }
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu)
-    {
-        super.onCreateOptionsMenu(menu);
-        getMenuInflater().inflate(R.menu.manage_identities_option, menu);
-        return true;
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item)
-    {
-        switch (item.getItemId())
-        {
-            case R.id.new_identity:
-                Intent intent = new Intent(ManageIdentities.this, EditIdentity.class);
-
-                intent.putExtra(EditIdentity.EXTRA_ACCOUNT, mAccount);
-                startActivityForResult(intent, ACTIVITY_EDIT_IDENTITY);
-                break;
-            default:
-                return super.onOptionsItemSelected(item);
-        }
-        return true;
-    }
-
-    @Override
-    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo)
-    {
-        super.onCreateContextMenu(menu, v, menuInfo);
-        menu.setHeaderTitle(R.string.manage_identities_context_menu_title);
-        getMenuInflater().inflate(R.menu.manage_identities_context, menu);
-    }
-
-    public boolean onContextItemSelected(MenuItem item)
-    {
-        AdapterContextMenuInfo menuInfo = (AdapterContextMenuInfo)item.getMenuInfo();
-        switch (item.getItemId())
-        {
-            case R.id.edit:
-                editItem(menuInfo.position);
-                break;
-            case R.id.up:
-                if (menuInfo.position > 0)
-                {
-                    Account.Identity identity = identities.remove(menuInfo.position);
-                    identities.add(menuInfo.position - 1, identity);
-                    mIdentitiesChanged = true;
-                    refreshView();
-                }
-
-                break;
-            case R.id.down:
-                if (menuInfo.position < identities.size() - 1)
-                {
-                    Account.Identity identity = identities.remove(menuInfo.position);
-                    identities.add(menuInfo.position + 1, identity);
-                    mIdentitiesChanged = true;
-                    refreshView();
-                }
-                break;
-            case R.id.top:
-                Account.Identity identity = identities.remove(menuInfo.position);
-                identities.add(0, identity);
-                mIdentitiesChanged = true;
-                refreshView();
-                break;
-            case R.id.remove:
-                if (identities.size() > 1)
-                {
-                  identities.remove(menuInfo.position);
-                  mIdentitiesChanged = true;
-                  refreshView();
-                }
-                else
-                {
-                    Toast.makeText(this, getString(R.string.no_removable_identity),
-                            Toast.LENGTH_LONG).show();
-                }
-                break;
-        }
-        return true;
-    }
-
-
-    @Override
-    public void onResume()
-    {
-        super.onResume();
-        mAccount.refresh(Preferences.getPreferences(getApplication().getApplicationContext()));
-        refreshView();
-    }
-
-
-    @Override
-    public boolean onKeyDown(int keyCode, KeyEvent event)
-    {
-        if (keyCode == KeyEvent.KEYCODE_BACK)
-        {
-            saveIdentities();
-        }
-        return super.onKeyDown(keyCode, event);
-    }
-
-    private void saveIdentities()
-    {
-        if (mIdentitiesChanged)
-        {
-            mAccount.setIdentities(identities);
-            mAccount.save(Preferences.getPreferences(getApplication().getApplicationContext()));
-        }
-        finish();
-    }
-}
Index: src/com/android/email/Preferences.java
===================================================================
--- src/com/android/email/Preferences.java	(revision 718)
+++ src/com/android/email/Preferences.java	(working copy)
@@ -1,140 +1,5 @@
-
 package com.android.email;
 
-import java.util.Arrays;
-
-import com.android.email.preferences.Editor;
-import com.android.email.preferences.Storage;
-
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.net.Uri;
-import android.util.Config;
-import android.util.Log;
-
 public class Preferences {
-    private static Preferences preferences;
-
-    private Storage mStorage;
-
-    private Preferences(Context context) {
-      mStorage = Storage.getStorage(context);
-      if (mStorage.size() == 0)
-      {
-        Log.i(Email.LOG_TAG, "Preferences storage is zero-size, importing from Android-style preferences");
-        Editor editor = mStorage.edit();
-        editor.copy(context.getSharedPreferences("AndroidMail.Main", Context.MODE_PRIVATE));
-        editor.commit();
-      }
-    }
-    
 
-    /**
-     * TODO need to think about what happens if this gets GCed along with the
-     * Activity that initialized it. Do we lose ability to read Preferences in
-     * further Activities? Maybe this should be stored in the Application
-     * context.
-     *
-     * @return
-     */
-    public static synchronized Preferences getPreferences(Context context) {
-        if (preferences == null) {
-            preferences = new Preferences(context);
-        }
-        return preferences;
-    }
-
-    /**
-     * Returns an array of the accounts on the system. If no accounts are
-     * registered the method returns an empty array.
-     *
-     * @return
-     */
-    public Account[] getAccounts() {
-        String accountUuids = getPreferences().getString("accountUuids", null);
-        if (accountUuids == null || accountUuids.length() == 0) {
-            return new Account[] {};
-        }
-        String[] uuids = accountUuids.split(",");
-        Account[] accounts = new Account[uuids.length];
-        for (int i = 0, length = uuids.length; i < length; i++) {
-            accounts[i] = new Account(this, uuids[i]);
-        }
-        return accounts;
-    }
-
-    public Account getAccountByContentUri(Uri uri) {
-        return new Account(this, uri.getPath().substring(1));
-    }
-
-    /**
-     * Returns the Account marked as default. If no account is marked as default
-     * the first account in the list is marked as default and then returned. If
-     * there are no accounts on the system the method returns null.
-     *
-     * @return
-     */
-    public Account getDefaultAccount() {
-        String defaultAccountUuid = getPreferences().getString("defaultAccountUuid", null);
-        Account defaultAccount = null;
-        Account[] accounts = getAccounts();
-        if (defaultAccountUuid != null) {
-            for (Account account : accounts) {
-                if (account.getUuid().equals(defaultAccountUuid)) {
-                    defaultAccount = account;
-                    break;
-                }
-            }
-        }
-
-        if (defaultAccount == null) {
-            if (accounts.length > 0) {
-                defaultAccount = accounts[0];
-                setDefaultAccount(defaultAccount);
-            }
-        }
-
-        return defaultAccount;
-    }
-
-    public void setDefaultAccount(Account account) {
-        getPreferences().edit().putString("defaultAccountUuid", account.getUuid()).commit();
-    }
-
-    public void setEnableDebugLogging(boolean value) {
-        getPreferences().edit().putBoolean("enableDebugLogging", value).commit();
-    }
-
-    public boolean getEnableDebugLogging() {
-        return getPreferences().getBoolean("enableDebugLogging", false);
-    }
-    
-    public void setTheme(int theme) {
-        getPreferences().edit().putInt("theme", theme).commit();
-    }
-
-    public int getTheme() {
-        return getPreferences().getInt("theme", android.R.style.Theme_Light);
-    } 
-
-    public void setEnableSensitiveLogging(boolean value) {
-        getPreferences().edit().putBoolean("enableSensitiveLogging", value).commit();
-    }
-
-    public boolean getEnableSensitiveLogging() {
-        return getPreferences().getBoolean("enableSensitiveLogging", false);
-    }
-
-    public void dump() {
-        if (Config.LOGV) {
-            for (String key : getPreferences().getAll().keySet()) {
-                Log.v(Email.LOG_TAG, key + " = " + getPreferences().getAll().get(key));
-            }
-        }
-    }
-
-    public SharedPreferences getPreferences()
-    {
-      return mStorage;
-    }
 }
Index: src/com/android/email/service/BootReceiver.java
===================================================================
--- src/com/android/email/service/BootReceiver.java	(revision 718)
+++ src/com/android/email/service/BootReceiver.java	(working copy)
@@ -1,26 +0,0 @@
-
-package com.android.email.service;
-
-import com.android.email.Email;
-import android.util.Log;
-import com.android.email.MessagingController;
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-
-public class BootReceiver extends BroadcastReceiver {
-    public void onReceive(Context context, Intent intent) {
-     	Log.v(Email.LOG_TAG, "BootReceiver.onReceive" + intent);
-
-        if (Intent.ACTION_BOOT_COMPLETED.equals(intent.getAction())) {
-         	Email.setServicesEnabled(context);
-        }
-        else if (Intent.ACTION_DEVICE_STORAGE_LOW.equals(intent.getAction())) {
-            MailService.actionCancel(context);
-        }
-        else if (Intent.ACTION_DEVICE_STORAGE_OK.equals(intent.getAction())) {
-            MailService.actionReschedule(context);
-        }
-    }
-}
Index: src/com/android/email/activity/ChooseIdentity.java
===================================================================
--- src/com/android/email/activity/ChooseIdentity.java	(revision 718)
+++ src/com/android/email/activity/ChooseIdentity.java	(working copy)
@@ -1,138 +0,0 @@
-
-package com.android.email.activity;
-
-import java.util.List;
-
-import android.app.ListActivity;
-import android.content.Intent;
-import android.os.Bundle;
-import android.os.Handler;
-import android.view.View;
-import android.view.Window;
-import android.widget.AdapterView;
-import android.widget.ArrayAdapter;
-import android.widget.ListView;
-import android.widget.Toast;
-
-import com.android.email.Account;
-import com.android.email.Preferences;
-import com.android.email.R;
-
-public class ChooseIdentity extends ListActivity
-{
-    Account mAccount;
-    String	mUID;
-    ArrayAdapter<String> adapter;
-    private ChooseIdentityHandler mHandler = new ChooseIdentityHandler();
-
-    public static final String EXTRA_ACCOUNT = "com.android.email.ChooseIdentity_account";
-    public static final String EXTRA_IDENTITY = "com.android.email.ChooseIdentity_identity";
-
-    protected List<Account.Identity> identities = null;
-
-    @Override
-    public void onCreate(Bundle savedInstanceState)
-    {
-        super.onCreate(savedInstanceState);
-
-        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
-
-        getListView().setTextFilterEnabled(true);
-        getListView().setItemsCanFocus(false);
-        getListView().setChoiceMode(ListView.CHOICE_MODE_NONE);
-        Intent intent = getIntent();
-        mAccount = (Account) intent.getSerializableExtra(EXTRA_ACCOUNT);
-
-        adapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1);
-
-        setListAdapter(adapter);
-        setupClickListeners();
-    }
-
-
-    @Override
-    public void onResume()
-    {
-        super.onResume();
-        refreshView();
-    }
-
-
-    protected void refreshView()
-    {
-        adapter.clear();
-
-        identities = mAccount.getIdentities();
-        for (Account.Identity identity : identities)
-        {
-            String email = identity.getEmail();
-            String description = identity.getDescription();
-            if (description == null || description.trim().length() == 0)
-            {
-                 description = getString(R.string.message_view_from_format, identity.getName(), identity.getEmail());
-            }
-            adapter.add(description);
-        }
-
-    }
-
-    protected void setupClickListeners()
-    {
-        this.getListView().setOnItemClickListener(new AdapterView.OnItemClickListener()
-        {
-            public void onItemClick(AdapterView adapterview, View view, int i, long l)
-            {
-                Account.Identity identity = mAccount.getIdentity(i);
-                String email = identity.getEmail();
-                if (email != null && email.trim().equals("") == false)
-                {
-                  Intent intent = new Intent();
-  
-                  intent.putExtra(EXTRA_IDENTITY, mAccount.getIdentity(i));
-                  setResult(RESULT_OK, intent);
-                  finish();
-                }
-                else
-                {
-                    Toast.makeText(ChooseIdentity.this, getString(R.string.identity_has_no_email),
-                            Toast.LENGTH_LONG).show();
-                }
-            }
-        });
-
-    }
-
-    class ChooseIdentityHandler extends Handler
-    {
-
-        private static final int MSG_PROGRESS = 2;
-        private static final int MSG_DATA_CHANGED = 3;
-
-        public void handleMessage(android.os.Message msg)
-        {
-            switch (msg.what)
-            {
-                case MSG_PROGRESS:
-                    setProgressBarIndeterminateVisibility(msg.arg1 != 0);
-                    break;
-                case MSG_DATA_CHANGED:
-                    adapter.notifyDataSetChanged();
-                    break;
-            }
-        }
-
-        public void progress(boolean progress)
-        {
-            android.os.Message msg = new android.os.Message();
-            msg.what = MSG_PROGRESS;
-            msg.arg1 = progress ? 1 : 0;
-            sendMessage(msg);
-        }
-
-        public void dataChanged()
-        {
-            sendEmptyMessage(MSG_DATA_CHANGED);
-        }
-    }
-
-}
Index: src/com/android/email/activity/EditIdentity.java
===================================================================
--- src/com/android/email/activity/EditIdentity.java	(revision 718)
+++ src/com/android/email/activity/EditIdentity.java	(working copy)
@@ -1,120 +0,0 @@
-package com.android.email.activity;
-
-import java.util.List;
-
-import com.android.email.Account;
-import com.android.email.Preferences;
-import com.android.email.R;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.os.Bundle;
-import android.view.KeyEvent;
-import android.widget.EditText;
-
-public class EditIdentity extends Activity
-{
-
-    public static final String EXTRA_IDENTITY = "com.android.email.EditIdentity_identity";
-    public static final String EXTRA_IDENTITY_INDEX = "com.android.email.EditIdentity_identity_index";
-    public static final String EXTRA_ACCOUNT = "com.android.email.EditIdentity_account";
-
-    private Account mAccount;
-    private Account.Identity mIdentity;
-    private int mIdentityIndex;
-    private EditText mDescriptionView;
-    private EditText mSignatureView;
-    private EditText mEmailView;
-//  private EditText mAlwaysBccView;
-    private EditText mNameView;
-
-    @Override
-    public void onCreate(Bundle savedInstanceState)
-    {
-        super.onCreate(savedInstanceState);
-
-        mIdentity = (Account.Identity)getIntent().getSerializableExtra(EXTRA_IDENTITY);
-        mIdentityIndex = getIntent().getIntExtra(EXTRA_IDENTITY_INDEX, -1);
-        mAccount = (Account) getIntent().getSerializableExtra(EXTRA_ACCOUNT);
-
-        if (mIdentityIndex == -1)
-        {
-            mIdentity = mAccount.new Identity();
-        }
-
-        setContentView(R.layout.edit_identity);
-
-        /*
-         * If we're being reloaded we override the original account with the one
-         * we saved
-         */
-        if (savedInstanceState != null && savedInstanceState.containsKey(EXTRA_IDENTITY))
-        {
-            mIdentity = (Account.Identity)savedInstanceState.getSerializable(EXTRA_IDENTITY);
-        }
-
-        mDescriptionView = (EditText)findViewById(R.id.description);
-        mDescriptionView.setText(mIdentity.getDescription());
-
-        mNameView = (EditText)findViewById(R.id.name);
-        mNameView.setText(mIdentity.getName());
-
-        mEmailView = (EditText)findViewById(R.id.email);
-        mEmailView.setText(mIdentity.getEmail());
-
-//      mAccountAlwaysBcc = (EditText)findViewById(R.id.bcc);
-//      mAccountAlwaysBcc.setText(mIdentity.getAlwaysBcc());
-
-        mSignatureView = (EditText)findViewById(R.id.signature);
-        mSignatureView.setText(mIdentity.getSignature());
-    }
-
-    @Override
-    public void onResume()
-    {
-        super.onResume();
-    }
-
-    private void saveIdentity()
-    {
-
-        mIdentity.setDescription(mDescriptionView.getText().toString());
-        mIdentity.setEmail(mEmailView.getText().toString());
-        //      mIdentity.setAlwaysBcc(mAccountAlwaysBcc.getText().toString());
-        mIdentity.setName(mNameView.getText().toString());
-        mIdentity.setSignature(mSignatureView.getText().toString());
-
-        List<Account.Identity> identities = mAccount.getIdentities();
-        if (mIdentityIndex == -1)
-        {
-            identities.add(mIdentity);
-        }
-        else
-        {
-            identities.remove(mIdentityIndex);
-            identities.add(mIdentityIndex, mIdentity);
-        }
-
-        mAccount.save(Preferences.getPreferences(getApplication().getApplicationContext()));
-
-        finish();
-    }
-
-    @Override
-    public boolean onKeyDown(int keyCode, KeyEvent event)
-    {
-        if (keyCode == KeyEvent.KEYCODE_BACK)
-        {
-            saveIdentity();
-            return true;
-        }
-        return super.onKeyDown(keyCode, event);
-    }
-
-    @Override
-    public void onSaveInstanceState(Bundle outState)
-    {
-        super.onSaveInstanceState(outState);
-        outState.putSerializable(EXTRA_IDENTITY, mIdentity);
-    }
-}
Index: src/com/android/email/activity/setup/AccountSetupBasics.java
===================================================================
--- src/com/android/email/activity/setup/AccountSetupBasics.java	(revision 718)
+++ src/com/android/email/activity/setup/AccountSetupBasics.java	(working copy)
@@ -1,388 +0,0 @@
-
-package com.android.email.activity.setup;
-
-import java.io.Serializable;
-import java.net.URI;
-import java.net.URISyntaxException;
-
-import com.android.email.K9Activity;
-import android.app.AlertDialog;
-import android.app.Dialog;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.content.res.XmlResourceParser;
-import android.database.Cursor;
-import android.net.Uri;
-import android.os.Bundle;
-import android.provider.Contacts;
-import android.provider.Contacts.People.ContactMethods;
-import android.text.Editable;
-import android.text.TextWatcher;
-import android.util.Log;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.widget.Button;
-import android.widget.CheckBox;
-import android.widget.EditText;
-
-import com.android.email.Account;
-import com.android.email.Email;
-import com.android.email.EmailAddressValidator;
-import com.android.email.Preferences;
-import com.android.email.R;
-import com.android.email.Utility;
-
-/**
- * Prompts the user for the email address and password. Also prompts for
- * "Use this account as default" if this is the 2nd+ account being set up.
- * Attempts to lookup default settings for the domain the user specified. If the
- * domain is known the settings are handed off to the AccountSetupCheckSettings
- * activity. If no settings are found the settings are handed off to the
- * AccountSetupAccountType activity.
- */
-public class AccountSetupBasics extends K9Activity
-        implements OnClickListener, TextWatcher {
-    private final static String EXTRA_ACCOUNT = "com.android.email.AccountSetupBasics.account";
-    private final static int DIALOG_NOTE = 1;
-    private final static String STATE_KEY_PROVIDER =
-        "com.android.email.AccountSetupBasics.provider";
-
-    private Preferences mPrefs;
-    private EditText mEmailView;
-    private EditText mPasswordView;
-    private CheckBox mDefaultView;
-    private Button mNextButton;
-    private Button mManualSetupButton;
-    private Account mAccount;
-    private Provider mProvider;
-
-    private EmailAddressValidator mEmailValidator = new EmailAddressValidator();
-
-    public static void actionNewAccount(Context context) {
-        Intent i = new Intent(context, AccountSetupBasics.class);
-        context.startActivity(i);
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.account_setup_basics);
-        mPrefs = Preferences.getPreferences(this);
-        mEmailView = (EditText)findViewById(R.id.account_email);
-        mPasswordView = (EditText)findViewById(R.id.account_password);
-        mDefaultView = (CheckBox)findViewById(R.id.account_default);
-        mNextButton = (Button)findViewById(R.id.next);
-        mManualSetupButton = (Button)findViewById(R.id.manual_setup);
-
-        mNextButton.setOnClickListener(this);
-        mManualSetupButton.setOnClickListener(this);
-
-        mEmailView.addTextChangedListener(this);
-        mPasswordView.addTextChangedListener(this);
-
-        if (mPrefs.getAccounts().length > 0) {
-            mDefaultView.setVisibility(View.VISIBLE);
-        }
-
-        if (savedInstanceState != null && savedInstanceState.containsKey(EXTRA_ACCOUNT)) {
-            mAccount = (Account)savedInstanceState.getSerializable(EXTRA_ACCOUNT);
-        }
-
-        if (savedInstanceState != null && savedInstanceState.containsKey(STATE_KEY_PROVIDER)) {
-            mProvider = (Provider)savedInstanceState.getSerializable(STATE_KEY_PROVIDER);
-        }
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        validateFields();
-    }
-
-    @Override
-    public void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        outState.putSerializable(EXTRA_ACCOUNT, mAccount);
-        if (mProvider != null) {
-            outState.putSerializable(STATE_KEY_PROVIDER, mProvider);
-        }
-    }
-
-    public void afterTextChanged(Editable s) {
-        validateFields();
-    }
-
-    public void beforeTextChanged(CharSequence s, int start, int count, int after) {
-    }
-
-    public void onTextChanged(CharSequence s, int start, int before, int count) {
-    }
-
-    private void validateFields() {
-        boolean valid = Utility.requiredFieldValid(mEmailView)
-                && Utility.requiredFieldValid(mPasswordView)
-                && mEmailValidator.isValid(mEmailView.getText().toString());
-        mNextButton.setEnabled(valid);
-        mManualSetupButton.setEnabled(valid);
-        /*
-         * Dim the next button's icon to 50% if the button is disabled.
-         * TODO this can probably be done with a stateful drawable. Check into it.
-         * android:state_enabled
-         */
-        Utility.setCompoundDrawablesAlpha(mNextButton, mNextButton.isEnabled() ? 255 : 128);
-    }
-
-    private String getOwnerName() {
-        String name = null;
-        String projection[] = {
-            ContactMethods.NAME
-        };
-        Cursor c = getContentResolver().query(
-                Uri.withAppendedPath(Contacts.People.CONTENT_URI, "owner"), projection, null, null,
-                null);
-        if (c.getCount() > 0) {
-            c.moveToFirst();
-            name = c.getString(0);
-            c.close();
-        }
-
-        if (name == null || name.length() == 0) {
-            Account account = Preferences.getPreferences(this).getDefaultAccount();
-            if (account != null) {
-                name = account.getName();
-            }
-        }
-        return name;
-    }
-
-    @Override
-    public Dialog onCreateDialog(int id) {
-        if (id == DIALOG_NOTE) {
-            if (mProvider != null && mProvider.note != null) {
-                return new AlertDialog.Builder(this)
-                    .setMessage(mProvider.note)
-                    .setPositiveButton(
-                            getString(R.string.okay_action),
-                            new DialogInterface.OnClickListener() {
-                                public void onClick(DialogInterface dialog, int which) {
-                                    finishAutoSetup();
-                                }
-                            })
-                    .setNegativeButton(
-                            getString(R.string.cancel_action),
-                            null)
-                    .create();
-            }
-        }
-        return null;
-    }
-
-    private void finishAutoSetup() {
-        String email = mEmailView.getText().toString();
-        String password = mPasswordView.getText().toString();
-        String[] emailParts = email.split("@");
-        String user = emailParts[0];
-        String domain = emailParts[1];
-        URI incomingUri = null;
-        URI outgoingUri = null;
-        try {
-            String incomingUsername = mProvider.incomingUsernameTemplate;
-            incomingUsername = incomingUsername.replaceAll("\\$email", email);
-            incomingUsername = incomingUsername.replaceAll("\\$user", user);
-            incomingUsername = incomingUsername.replaceAll("\\$domain", domain);
-
-            URI incomingUriTemplate = mProvider.incomingUriTemplate;
-            incomingUri = new URI(incomingUriTemplate.getScheme(), incomingUsername + ":"
-                    + password, incomingUriTemplate.getHost(), incomingUriTemplate.getPort(), null,
-                    null, null);
-
-            String outgoingUsername = mProvider.outgoingUsernameTemplate;
-            outgoingUsername = outgoingUsername.replaceAll("\\$email", email);
-            outgoingUsername = outgoingUsername.replaceAll("\\$user", user);
-            outgoingUsername = outgoingUsername.replaceAll("\\$domain", domain);
-
-            URI outgoingUriTemplate = mProvider.outgoingUriTemplate;
-            outgoingUri = new URI(outgoingUriTemplate.getScheme(), outgoingUsername + ":"
-                    + password, outgoingUriTemplate.getHost(), outgoingUriTemplate.getPort(), null,
-                    null, null);
-        } catch (URISyntaxException use) {
-            /*
-             * If there is some problem with the URI we give up and go on to
-             * manual setup.
-             */
-            onManualSetup();
-            return;
-        }
-
-        mAccount = new Account(this);
-        mAccount.setName(getOwnerName());
-        mAccount.setEmail(email);
-        mAccount.setStoreUri(incomingUri.toString());
-        mAccount.setTransportUri(outgoingUri.toString());
-        mAccount.setDraftsFolderName(getString(R.string.special_mailbox_name_drafts));
-        mAccount.setTrashFolderName(getString(R.string.special_mailbox_name_trash));
-        mAccount.setOutboxFolderName(getString(R.string.special_mailbox_name_outbox));
-        mAccount.setSentFolderName(getString(R.string.special_mailbox_name_sent));
-        if (incomingUri.toString().startsWith("imap")) {
-            mAccount.setDeletePolicy(Account.DELETE_POLICY_ON_DELETE);
-        }
-        AccountSetupCheckSettings.actionCheckSettings(this, mAccount, true, true);
-    }
-
-    private void onNext() {
-        String email = mEmailView.getText().toString();
-        String password = mPasswordView.getText().toString();
-        String[] emailParts = email.split("@");
-        String user = emailParts[0];
-        String domain = emailParts[1];
-        mProvider = findProviderForDomain(domain);
-        if (mProvider == null) {
-            /*
-             * We don't have default settings for this account, start the manual
-             * setup process.
-             */
-            onManualSetup();
-            return;
-        }
-
-        if (mProvider.note != null) {
-            showDialog(DIALOG_NOTE);
-        }
-        else {
-            finishAutoSetup();
-        }
-    }
-
-    @Override
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        if (resultCode == RESULT_OK) {
-            mAccount.setDescription(mAccount.getEmail());
-            mAccount.save(Preferences.getPreferences(this));
-            if (mDefaultView.isChecked()) {
-                Preferences.getPreferences(this).setDefaultAccount(mAccount);
-            }
-            Email.setServicesEnabled(this);
-            AccountSetupNames.actionSetNames(this, mAccount);
-            finish();
-        }
-    }
-
-    private void onManualSetup() {
-        String email = mEmailView.getText().toString();
-        String password = mPasswordView.getText().toString();
-        String[] emailParts = email.split("@");
-        String user = emailParts[0];
-        String domain = emailParts[1];
-
-        mAccount = new Account(this);
-        mAccount.setName(getOwnerName());
-        mAccount.setEmail(email);
-        try {
-            URI uri = new URI("placeholder", user + ":" + password, "mail." + domain, -1, null,
-                    null, null);
-            mAccount.setStoreUri(uri.toString());
-            mAccount.setTransportUri(uri.toString());
-        } catch (URISyntaxException use) {
-            /*
-             * If we can't set up the URL we just continue. It's only for
-             * convenience.
-             */
-        }
-        mAccount.setDraftsFolderName(getString(R.string.special_mailbox_name_drafts));
-        mAccount.setTrashFolderName(getString(R.string.special_mailbox_name_trash));
-        mAccount.setOutboxFolderName(getString(R.string.special_mailbox_name_outbox));
-        mAccount.setSentFolderName(getString(R.string.special_mailbox_name_sent));
-
-        AccountSetupAccountType.actionSelectAccountType(this, mAccount, mDefaultView.isChecked());
-        finish();
-    }
-
-    public void onClick(View v) {
-        switch (v.getId()) {
-            case R.id.next:
-                onNext();
-                break;
-            case R.id.manual_setup:
-                onManualSetup();
-                break;
-        }
-    }
-
-    /**
-     * Attempts to get the given attribute as a String resource first, and if it fails
-     * returns the attribute as a simple String value.
-     * @param xml
-     * @param name
-     * @return
-     */
-    private String getXmlAttribute(XmlResourceParser xml, String name) {
-        int resId = xml.getAttributeResourceValue(null, name, 0);
-        if (resId == 0) {
-            return xml.getAttributeValue(null, name);
-        }
-        else {
-            return getString(resId);
-        }
-    }
-
-    private Provider findProviderForDomain(String domain) {
-        try {
-            XmlResourceParser xml = getResources().getXml(R.xml.providers);
-            int xmlEventType;
-            Provider provider = null;
-            while ((xmlEventType = xml.next()) != XmlResourceParser.END_DOCUMENT) {
-                if (xmlEventType == XmlResourceParser.START_TAG
-                        && "provider".equals(xml.getName())
-                        && domain.equalsIgnoreCase(getXmlAttribute(xml, "domain"))) {
-                    provider = new Provider();
-                    provider.id = getXmlAttribute(xml, "id");
-                    provider.label = getXmlAttribute(xml, "label");
-                    provider.domain = getXmlAttribute(xml, "domain");
-                    provider.note = getXmlAttribute(xml, "note");
-                }
-                else if (xmlEventType == XmlResourceParser.START_TAG
-                        && "incoming".equals(xml.getName())
-                        && provider != null) {
-                    provider.incomingUriTemplate = new URI(getXmlAttribute(xml, "uri"));
-                    provider.incomingUsernameTemplate = getXmlAttribute(xml, "username");
-                }
-                else if (xmlEventType == XmlResourceParser.START_TAG
-                        && "outgoing".equals(xml.getName())
-                        && provider != null) {
-                    provider.outgoingUriTemplate = new URI(getXmlAttribute(xml, "uri"));
-                    provider.outgoingUsernameTemplate = getXmlAttribute(xml, "username");
-                }
-                else if (xmlEventType == XmlResourceParser.END_TAG
-                        && "provider".equals(xml.getName())
-                        && provider != null) {
-                    return provider;
-                }
-            }
-        }
-        catch (Exception e) {
-            Log.e(Email.LOG_TAG, "Error while trying to load provider settings.", e);
-        }
-        return null;
-    }
-
-    static class Provider implements Serializable {
-        private static final long serialVersionUID = 8511656164616538989L;
-
-        public String id;
-
-        public String label;
-
-        public String domain;
-
-        public URI incomingUriTemplate;
-
-        public String incomingUsernameTemplate;
-
-        public URI outgoingUriTemplate;
-
-        public String outgoingUsernameTemplate;
-
-        public String note;
-    }
-}
Index: src/com/android/email/activity/MessageView.java
===================================================================
--- src/com/android/email/activity/MessageView.java	(revision 718)
+++ src/com/android/email/activity/MessageView.java	(working copy)
@@ -1,1329 +0,0 @@
-
-package com.android.email.activity;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.text.DateFormat;
-import java.util.ArrayList;
-import java.util.Map;
-
-import org.apache.commons.io.IOUtils;
-
-import com.android.email.K9Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.content.res.Configuration;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.graphics.drawable.Drawable;
-import android.media.MediaScannerConnection;
-import android.media.MediaScannerConnection.MediaScannerConnectionClient;
-import android.net.Uri;
-import android.os.Bundle;
-import android.os.Environment;
-import android.os.Handler;
-import android.provider.Contacts;
-import android.provider.Contacts.Intents;
-import android.text.Spannable;
-import android.util.Config;
-import android.util.Log;
-import android.view.KeyEvent;
-import android.view.LayoutInflater;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.View;
-import android.view.Window;
-import android.view.View.OnClickListener;
-import android.webkit.CacheManager;
-import android.webkit.UrlInterceptHandler;
-import android.webkit.WebView;
-import android.webkit.CacheManager.CacheResult;
-import android.webkit.PluginData;
-import android.widget.Button;
-import android.widget.ImageView;
-import android.widget.LinearLayout;
-import android.widget.TextView;
-import android.widget.Toast;
-
-import com.android.email.Account;
-import com.android.email.Email;
-import com.android.email.MessagingController;
-import com.android.email.MessagingListener;
-import com.android.email.R;
-import com.android.email.Utility;
-import com.android.email.mail.Address;
-import com.android.email.mail.Flag;
-import com.android.email.mail.Message;
-import com.android.email.mail.MessagingException;
-import com.android.email.mail.Multipart;
-import com.android.email.mail.Part;
-import com.android.email.mail.Message.RecipientType;
-import com.android.email.mail.internet.MimeUtility;
-import com.android.email.mail.store.LocalStore.LocalAttachmentBodyPart;
-import com.android.email.mail.store.LocalStore.LocalMessage;
-import com.android.email.mail.store.LocalStore.LocalTextBody;
-import com.android.email.provider.AttachmentProvider;
-import java.net.HttpURLConnection;
-import java.util.HashMap;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
-public class MessageView extends K9Activity
-        implements UrlInterceptHandler, OnClickListener {
-    private static final String EXTRA_ACCOUNT = "com.android.email.MessageView_account";
-    private static final String EXTRA_FOLDER = "com.android.email.MessageView_folder";
-    private static final String EXTRA_MESSAGE = "com.android.email.MessageView_message";
-    private static final String EXTRA_FOLDER_UIDS = "com.android.email.MessageView_folderUids";
-    private static final String EXTRA_NEXT = "com.android.email.MessageView_next";
-
-    private static final String CID_PREFIX  = "http://cid/";
-
-    private static final int ACTIVITY_CHOOSE_FOLDER_MOVE = 1;
-
-    private static final int ACTIVITY_CHOOSE_FOLDER_COPY = 2;
-    
-    private TextView mFromView;
-    private TextView mDateView;
-    private TextView mTimeView;
-    private TextView mToView;
-    private TextView mCcView;
-    private TextView mSubjectView;
-    private int defaultSubjectColor;
-    private WebView mMessageContentView;
-    private LinearLayout mAttachments;
-    private View mAttachmentIcon;
-    private View mShowPicturesSection;
-    View next;
-    View next_scrolling;
-    View previous;
-    View previous_scrolling;
-
-    private Account mAccount;
-    private String mFolder;
-    private String mMessageUid;
-    private ArrayList<String> mFolderUids;
-
-    private Message mMessage;
-    private String mNextMessageUid = null;
-    private String mPreviousMessageUid = null;
-
-    private DateFormat dateFormat = null;
-    private DateFormat timeFormat = null;
-    
-    private Menu optionsMenu = null;
-
-    //Shall we use more threads? How often will the user move from non-fully-downloaded
-    //messages to another non-fully-downloaded message more than 3 times?
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(3);
-    
-    private DateFormat getDateFormat()
-    {
-      if (dateFormat == null)
-      {
-       String dateFormatS = android.provider.Settings.System.getString(getContentResolver(), 
-            android.provider.Settings.System.DATE_FORMAT);
-        if (dateFormatS != null) {
-          dateFormat = new java.text.SimpleDateFormat(dateFormatS);
-        }
-        else
-        {
-          dateFormat = new java.text.SimpleDateFormat(Email.BACKUP_DATE_FORMAT);
-        }
-      }
-       return  dateFormat;
-    }
-    private DateFormat getTimeFormat()
-    {
-      if (timeFormat == null)
-      { 
-        String timeFormatS = android.provider.Settings.System.getString(getContentResolver(), 
-            android.provider.Settings.System.TIME_12_24);
-        boolean b24 =  !(timeFormatS == null || timeFormatS.equals("12"));
-        timeFormat = new java.text.SimpleDateFormat(b24 ? Email.TIME_FORMAT_24 : Email.TIME_FORMAT_12);
-      }
-       return timeFormat;
-    }
-    private void clearFormats()
-    {
-	dateFormat = null;
-	timeFormat = null;
-    }
-
-    private Listener mListener = new Listener();
-    private MessageViewHandler mHandler = new MessageViewHandler();
-
-       public boolean onKeyDown(int keyCode, KeyEvent event) {
-        switch (keyCode) {
-            case KeyEvent.KEYCODE_DEL: { onDelete(); return true;}
-            case KeyEvent.KEYCODE_D: { onDelete(); return true;}
-            case KeyEvent.KEYCODE_F: { onForward(); return true;}
-            case KeyEvent.KEYCODE_A: { onReplyAll(); return true; }
-            case KeyEvent.KEYCODE_R: { onReply(); return true; }
-            case KeyEvent.KEYCODE_G: { onFlag(); return true; }
-
-            case KeyEvent.KEYCODE_M: { onMove(); return true; }
-            case KeyEvent.KEYCODE_Y: { onCopy(); return true; }
-            case KeyEvent.KEYCODE_J:
-            case KeyEvent.KEYCODE_P:
-            { onPrevious(); return true; }
-            case KeyEvent.KEYCODE_N:
-            case KeyEvent.KEYCODE_K: { onNext(); return true; }
-            case KeyEvent.KEYCODE_Z: { if (event.isShiftPressed()) {
-                                            mMessageContentView.zoomIn();
-                                        } else {
-                                            mMessageContentView.zoomOut();
-                                        }
-                                     return true; }
-
-           case KeyEvent.KEYCODE_H: {
-               Toast toast = Toast.makeText(this, R.string.message_help_key, Toast.LENGTH_LONG);
-               toast.show();
-               return true; }
-            }
-           return super.onKeyDown(keyCode, event);
-        }
-
-    class MessageViewHandler extends Handler {
-        private static final int MSG_PROGRESS = 2;
-        private static final int MSG_ADD_ATTACHMENT = 3;
-        private static final int MSG_SET_ATTACHMENTS_ENABLED = 4;
-        private static final int MSG_SET_HEADERS = 5;
-        private static final int MSG_NETWORK_ERROR = 6;
-        private static final int MSG_ATTACHMENT_SAVED = 7;
-        private static final int MSG_ATTACHMENT_NOT_SAVED = 8;
-        private static final int MSG_SHOW_SHOW_PICTURES = 9;
-        private static final int MSG_FETCHING_ATTACHMENT = 10;
-        private static final int FLAG_FLAGGED = 1;
-        private static final int FLAG_ANSWERED = 2;
-
-        @Override
-        public void handleMessage(android.os.Message msg) {
-            switch (msg.what) {
-                case MSG_PROGRESS:
-                    setProgressBarIndeterminateVisibility(msg.arg1 != 0);
-                    break;
-                case MSG_ADD_ATTACHMENT:
-                    mAttachments.addView((View) msg.obj);
-                    mAttachments.setVisibility(View.VISIBLE);
-                    break;
-                case MSG_SET_ATTACHMENTS_ENABLED:
-                    for (int i = 0, count = mAttachments.getChildCount(); i < count; i++) {
-                        Attachment attachment = (Attachment) mAttachments.getChildAt(i).getTag();
-                        attachment.viewButton.setEnabled(msg.arg1 == 1);
-                        attachment.downloadButton.setEnabled(msg.arg1 == 1);
-                    }
-                    break;
-                case MSG_SET_HEADERS:
-                    String[] values = (String[]) msg.obj;
-                    setTitle(values[0]);
-                    mSubjectView.setText(values[0]);
-                    mFromView.setText(values[1]);
-                    if (values[2]!=null) {
-                        mDateView.setText(values[2]);
-                        mDateView.setVisibility(View.VISIBLE);
-                    }
-                    else {
-                        mDateView.setVisibility(View.GONE);
-                    }
-                    mTimeView.setText(values[3]);
-                    mToView.setText(values[4]);
-                    mCcView.setText(values[5]);
-                    mAttachmentIcon.setVisibility(msg.arg1 == 1 ? View.VISIBLE : View.GONE);
-                    if ((msg.arg2 & FLAG_FLAGGED) != 0) {
-                      mSubjectView.setTextColor(0xff000000 | Email.FLAGGED_COLOR);
-                    }
-                    else {
-                      mSubjectView.setTextColor(0xff000000 | defaultSubjectColor );
-                    }
-                    if ((msg.arg2 & FLAG_ANSWERED) != 0) {
-                     Drawable answeredIcon = getResources().getDrawable(
-                          R.drawable.ic_mms_answered_small);
-                     mSubjectView.setCompoundDrawablesWithIntrinsicBounds(
-                          answeredIcon, // left 
-                              null, // top
-                              null, // right 
-                              null); // bottom
-                    }
-                    
-                    break;
-                case MSG_NETWORK_ERROR:
-                    Toast.makeText(MessageView.this,
-                            R.string.status_network_error, Toast.LENGTH_LONG).show();
-                    break;
-                case MSG_ATTACHMENT_SAVED:
-                    Toast.makeText(MessageView.this, String.format(
-                            getString(R.string.message_view_status_attachment_saved), msg.obj),
-                            Toast.LENGTH_LONG).show();
-                    break;
-                case MSG_ATTACHMENT_NOT_SAVED:
-                    Toast.makeText(MessageView.this,
-                            getString(R.string.message_view_status_attachment_not_saved),
-                            Toast.LENGTH_LONG).show();
-                    break;
-                case MSG_SHOW_SHOW_PICTURES:
-                    mShowPicturesSection.setVisibility(msg.arg1 == 1 ? View.VISIBLE : View.GONE);
-                    break;
-                case MSG_FETCHING_ATTACHMENT:
-                    Toast.makeText(MessageView.this,
-                            getString(R.string.message_view_fetching_attachment_toast),
-                            Toast.LENGTH_SHORT).show();
-                    break;
-                default:
-                    super.handleMessage(msg);
-            }
-        }
-
-        public void progress(boolean progress) {
-            android.os.Message msg = new android.os.Message();
-            msg.what = MSG_PROGRESS;
-            msg.arg1 = progress ? 1 : 0;
-            sendMessage(msg);
-        }
-
-        public void addAttachment(View attachmentView) {
-            android.os.Message msg = new android.os.Message();
-            msg.what = MSG_ADD_ATTACHMENT;
-            msg.obj = attachmentView;
-            sendMessage(msg);
-        }
-
-        public void setAttachmentsEnabled(boolean enabled) {
-            android.os.Message msg = new android.os.Message();
-            msg.what = MSG_SET_ATTACHMENTS_ENABLED;
-            msg.arg1 = enabled ? 1 : 0;
-            sendMessage(msg);
-        }
-
-        public void setHeaders(
-                String subject,
-                String from,
-                String date,
-                String time,
-                String to,
-                String cc,
-                boolean hasAttachments,
-                boolean flagged,
-                boolean seen) {
-            android.os.Message msg = new android.os.Message();
-            msg.what = MSG_SET_HEADERS;
-            msg.arg1 = hasAttachments ? 1 : 0;
-            msg.arg2 += (flagged ? FLAG_FLAGGED : 0);
-            msg.arg2 += (seen ? FLAG_ANSWERED : 0);
-           
-            msg.obj = new String[] { subject, from, date, time, to, cc };
-            sendMessage(msg);
-        }
-
-        public void networkError() {
-            sendEmptyMessage(MSG_NETWORK_ERROR);
-        }
-
-        public void attachmentSaved(String filename) {
-            android.os.Message msg = new android.os.Message();
-            msg.what = MSG_ATTACHMENT_SAVED;
-            msg.obj = filename;
-            sendMessage(msg);
-        }
-
-        public void attachmentNotSaved() {
-            sendEmptyMessage(MSG_ATTACHMENT_NOT_SAVED);
-        }
-
-        public void fetchingAttachment() {
-            sendEmptyMessage(MSG_FETCHING_ATTACHMENT);
-        }
-
-        public void showShowPictures(boolean show) {
-            android.os.Message msg = new android.os.Message();
-            msg.what = MSG_SHOW_SHOW_PICTURES;
-            msg.arg1 = show ? 1 : 0;
-            sendMessage(msg);
-        }
-
-
-
-    }
-
-    class Attachment {
-        public String name;
-        public String contentType;
-        public long size;
-        public LocalAttachmentBodyPart part;
-        public Button viewButton;
-        public Button downloadButton;
-        public ImageView iconView;
-    }
-
-    public static void actionView(Context context, Account account, String folder, String messageUid, ArrayList<String> folderUids) {
-        actionView(context, account, folder, messageUid, folderUids, null);
-    }
-
-    public static void actionView(Context context, Account account, String folder, String messageUid, ArrayList<String> folderUids, Bundle extras) {
-        Intent i = new Intent(context, MessageView.class);
-        i.putExtra(EXTRA_ACCOUNT, account);
-        i.putExtra(EXTRA_FOLDER, folder);
-        i.putExtra(EXTRA_MESSAGE, messageUid);
-        i.putExtra(EXTRA_FOLDER_UIDS, folderUids);
-        if (extras != null) {
-            i.putExtras(extras);
-        }
-        context.startActivity(i);
-     }
-
-    public void onCreate(Bundle icicle) {
-        super.onCreate(icicle);
-
-        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
-        requestWindowFeature(Window.FEATURE_NO_TITLE); 
-
-        setContentView(R.layout.message_view);
-
-        mFromView = (TextView)findViewById(R.id.from);
-        mToView = (TextView)findViewById(R.id.to);
-        mCcView = (TextView)findViewById(R.id.cc);
-        mSubjectView = (TextView)findViewById(R.id.subject);
-        defaultSubjectColor = mSubjectView.getCurrentTextColor();
-
-
-        mDateView = (TextView)findViewById(R.id.date);
-        mTimeView = (TextView)findViewById(R.id.time);
-        mMessageContentView = (WebView)findViewById(R.id.message_content);
-        //mMessageContentView.setWebViewClient(new MessageWebViewClient());
-        mAttachments = (LinearLayout)findViewById(R.id.attachments);
-        mAttachmentIcon = findViewById(R.id.attachment);
-        mShowPicturesSection = findViewById(R.id.show_pictures_section);
-
-
-        mMessageContentView.setVerticalScrollBarEnabled(false);
-        mAttachments.setVisibility(View.GONE);
-        mAttachmentIcon.setVisibility(View.GONE);
-
-        setOnClickListener(R.id.from);
-        setOnClickListener(R.id.reply);
-        setOnClickListener(R.id.reply_all);
-        setOnClickListener(R.id.delete);
-        setOnClickListener(R.id.forward);
-        setOnClickListener(R.id.next);
-        setOnClickListener(R.id.previous);
- 
-        setOnClickListener(R.id.reply_scrolling);
- //       setOnClickListener(R.id.reply_all_scrolling);
-        setOnClickListener(R.id.delete_scrolling);
-        setOnClickListener(R.id.forward_scrolling);
-        setOnClickListener(R.id.next_scrolling);
-        setOnClickListener(R.id.previous_scrolling);
-
-        setOnClickListener(R.id.show_pictures);
-
-        // UrlInterceptRegistry.registerHandler(this);
-
-        mMessageContentView.getSettings().setBlockNetworkImage(true);
-        mMessageContentView.getSettings().setSupportZoom(true);
-
-        setTitle("");
-
-        Intent intent = getIntent();
-        mAccount = (Account) intent.getSerializableExtra(EXTRA_ACCOUNT);
-        mFolder = intent.getStringExtra(EXTRA_FOLDER);
-        mMessageUid = intent.getStringExtra(EXTRA_MESSAGE);
-        mFolderUids = intent.getStringArrayListExtra(EXTRA_FOLDER_UIDS);
-       
-        next = findViewById(R.id.next);
-        previous = findViewById(R.id.previous);
-        
-       
-        setOnClickListener(R.id.next);
-        setOnClickListener(R.id.previous);
-
-        next_scrolling = findViewById(R.id.next_scrolling);
-        
-        
-        previous_scrolling = findViewById(R.id.previous_scrolling);
-
-        boolean goNext = intent.getBooleanExtra(EXTRA_NEXT, false);
-        if (goNext) {
-            next.requestFocus();
-        }
-        
-        Account.HideButtons hideButtons = mAccount.getHideMessageViewButtons();
-        
-        MessagingController.getInstance(getApplication()).addListener(mListener);
-        if (Account.HideButtons.ALWAYS == hideButtons)
-        {
-          hideButtons();
-        }
-        else if (Account.HideButtons.NEVER == hideButtons)
-        {
-          showButtons();
-        }
-        else // Account.HideButtons.KEYBOARD_AVAIL
-        {
-            final Configuration config = this.getResources().getConfiguration();
-            if (config.keyboardHidden == Configuration.KEYBOARDHIDDEN_NO )
-            {
-              hideButtons();
-            }
-            else
-            {
-              showButtons();
-            }
-        }
-        displayMessage(mMessageUid);
-  }
-
-    private void displayMessage(String uid)
-    {
-        mMessageUid = uid;
-        mAttachments.removeAllViews();
-        findSurroundingMessagesUid();
-        next.setEnabled(mNextMessageUid != null );
-        previous.setEnabled(mPreviousMessageUid != null);
-        if (next_scrolling != null)
-            next_scrolling.setEnabled(mNextMessageUid != null );
-        if (previous_scrolling != null)
-            previous_scrolling.setEnabled(mPreviousMessageUid != null);
-
-        Runnable loaderThread = new Runnable() {
-            public void run() {
-                MessagingController.getInstance(getApplication()).loadMessageForViewSynchronous(
-                    mAccount,
-                    mFolder,
-                    mMessageUid,
-                    null);
-            }
-        };
-
-        threadPool.execute(loaderThread);
-    }
-    
-    
-  private void showButtons()
-  {
-    View buttons = findViewById(R.id.scrolling_buttons);
-    if (buttons != null) {
-      buttons.setVisibility(View.GONE);
-    }
-  }
-  
-  private void hideButtons()
-  {
-    View buttons = findViewById(R.id.bottom_buttons);
-    if (buttons != null) {
-      buttons.setVisibility(View.GONE);
-    }
-  }
-    
-    private void setOnClickListener(int viewCode)
-    {
-      View thisView = findViewById(viewCode);
-      if (thisView != null)
-      {
-        thisView.setOnClickListener(this);
-      }
-    }
-
-    private void findSurroundingMessagesUid() {
-        mNextMessageUid = mPreviousMessageUid = null;
-        int i = mFolderUids.indexOf(mMessageUid);
-        if(i < 0)
-            return;
-        if(i != 0)
-            mNextMessageUid = mFolderUids.get(i - 1);
-        if(i != (mFolderUids.size() - 1))
-            mPreviousMessageUid = mFolderUids.get(i + 1);
-    }
-
-    public void onResume() {
-        super.onResume();
-        clearFormats();
-        MessagingController.getInstance(getApplication()).addListener(mListener);
-    }
-
-    public void onPause() {
-        super.onPause();
-        MessagingController.getInstance(getApplication()).removeListener(mListener);
-    }
-    
-    private void onDelete() {
-        if (mMessage != null) {
-           Message messageToDelete = mMessage;
-           String folderForDelete = mFolder;
-           Account accountForDelete = mAccount;
-
-           findSurroundingMessagesUid();
-
-            // Remove this message's Uid locally
-            mFolderUids.remove(messageToDelete.getUid());
-            
-            
-            MessagingController.getInstance(getApplication()).deleteMessage(
-                accountForDelete,
-                folderForDelete,
-                messageToDelete,
-                null);
-            if (mNextMessageUid != null) {
-              onNext();
-            }
-            else if (mPreviousMessageUid != null) {
-                onPrevious();
-            } else {
-                finish();
-            }
-        }
-    }
-
-    private void onClickSender() {
-        if (mMessage != null) {
-            try {
-                Address senderEmail = mMessage.getFrom()[0];
-                Uri contactUri = Uri.fromParts("mailto", senderEmail.getAddress(), null);
-
-                Intent contactIntent = new Intent(Contacts.Intents.SHOW_OR_CREATE_CONTACT);
-                contactIntent.setData(contactUri);
-
-                // Pass along full E-mail string for possible create dialog
-                contactIntent.putExtra(Contacts.Intents.EXTRA_CREATE_DESCRIPTION,
-                        senderEmail.toString());
-
-                // Only provide personal name hint if we have one
-                String senderPersonal = senderEmail.getPersonal();
-                if (senderPersonal != null) {
-                    contactIntent.putExtra(Intents.Insert.NAME, senderPersonal);
-                }
-
-                startActivity(contactIntent);
-            } catch (MessagingException me) {
-                if (Config.LOGV) {
-                    Log.v(Email.LOG_TAG, "loadMessageForViewHeadersAvailable", me);
-                }
-            }
-        }
-    }
-
-    private void onReply() {
-        if (mMessage != null) {
-            MessageCompose.actionReply(this, mAccount, mMessage, false);
-            finish();
-        }
-    }
-
-    private void onReplyAll() {
-        if (mMessage != null) {
-            MessageCompose.actionReply(this, mAccount, mMessage, true);
-            finish();
-        }
-    }
-
-    private void onForward() {
-        if (mMessage != null) {
-            MessageCompose.actionForward(this, mAccount, mMessage);
-            finish();
-        }
-    }
-    
-    private void onFlag() {
-      if (mMessage != null) {
-        MessagingController.getInstance(getApplication()).setMessageFlag(mAccount,
-            mMessage.getFolder().getName(), mMessage.getUid(), Flag.FLAGGED, !mMessage.isSet(Flag.FLAGGED));
-        try
-        {
-          mMessage.setFlag(Flag.FLAGGED, !mMessage.isSet(Flag.FLAGGED));
-          setHeaders(mAccount, mMessage.getFolder().getName(), mMessage.getUid(), mMessage);
-          setMenuFlag();
-        }
-        catch (MessagingException me)
-        {
-          Log.e(Email.LOG_TAG, "Could not set flag on local message", me);
-        }
-      }
-  }
-    
-    private void onMove()
-    {
-      if (MessagingController.getInstance(getApplication()).isMoveCapable(mAccount) == false)
-      {
-        return;
-      }
-      if (MessagingController.getInstance(getApplication()).isMoveCapable(mMessage) == false)
-      {
-       Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
-       toast.show();
-       return;
-      }
-      Intent intent = new Intent(this, ChooseFolder.class);
-      intent.putExtra(ChooseFolder.EXTRA_ACCOUNT, mAccount);
-      intent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, mFolder);
-      intent.putExtra(ChooseFolder.EXTRA_MESSAGE_UID, mMessageUid);
-      startActivityForResult(intent, ACTIVITY_CHOOSE_FOLDER_MOVE);
-    }
-    
-     private void onCopy()
-      {
-       if (MessagingController.getInstance(getApplication()).isCopyCapable(mAccount) == false)
-       {
-         return;
-       }
-       if (MessagingController.getInstance(getApplication()).isCopyCapable(mMessage) == false)
-       {
-        Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
-        toast.show();
-        return;
-       }
-        Intent intent = new Intent(this, ChooseFolder.class);
-
-        intent.putExtra(ChooseFolder.EXTRA_ACCOUNT, mAccount);
-        intent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, mFolder);
-        intent.putExtra(ChooseFolder.EXTRA_MESSAGE_UID, mMessageUid);
-        startActivityForResult(intent, ACTIVITY_CHOOSE_FOLDER_COPY);
-      }
-     
-     @Override
-     protected void onActivityResult(int requestCode, int resultCode, Intent data) {
-       if(resultCode != RESULT_OK)
-         return;
-
-       switch(requestCode) {
-         case ACTIVITY_CHOOSE_FOLDER_MOVE:
-         case ACTIVITY_CHOOSE_FOLDER_COPY:
-           if (data == null)
-             return;
-           String destFolderName = data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER);
-           String srcFolderName = data.getStringExtra(ChooseFolder.EXTRA_CUR_FOLDER);
-           String uid = data.getStringExtra(ChooseFolder.EXTRA_MESSAGE_UID);
-           
-           if (uid.equals(mMessageUid) && srcFolderName.equals(mFolder))
-           {
-             
-             switch (requestCode) {
-               case ACTIVITY_CHOOSE_FOLDER_MOVE:
-                 MessagingController.getInstance(getApplication()).moveMessage(mAccount,
-                     srcFolderName, mMessage, destFolderName, null);
-                 break;
-               case ACTIVITY_CHOOSE_FOLDER_COPY:
-                 MessagingController.getInstance(getApplication()).copyMessage(mAccount,
-                     srcFolderName, mMessage, destFolderName, null);
-                 break;
-             }
-           }
-       }
-     }
-  
-    
-    private void onSendAlternate() {
-      if (mMessage != null) {
-                       MessagingController.getInstance(getApplication()).sendAlternate(this, mAccount, mMessage);
-
-      }
-  }
-
-    private void onNext() {
-        if (mNextMessageUid == null) {
-            Toast.makeText(this, getString(R.string.end_of_folder), Toast.LENGTH_SHORT).show();
-            return;
-        }
-        displayMessage(mNextMessageUid);
-        next.requestFocus();
-    }
-
-    private void onPrevious() {
-        if (mPreviousMessageUid == null) {
-            Toast.makeText(this, getString(R.string.end_of_folder), Toast.LENGTH_SHORT).show();
-            return;
-        }
-        displayMessage(mPreviousMessageUid);
-        previous.requestFocus();
-    }
-
-    private void onMarkAsUnread() {
-      if (mMessage != null)
-      {
-        MessagingController.getInstance(getApplication()).markMessageRead(
-                mAccount,
-                mFolder,
-                mMessage.getUid(),
-                false);
-      }
-    }
-
-    /**
-     * Creates a unique file in the given directory by appending a hyphen
-     * and a number to the given filename.
-     * @param directory
-     * @param filename
-     * @return
-     */
-    private File createUniqueFile(File directory, String filename) {
-        File file = new File(directory, filename);
-        if (!file.exists()) {
-            return file;
-        }
-        // Get the extension of the file, if any.
-        int index = filename.lastIndexOf('.');
-        String format;
-        if (index != -1) {
-            String name = filename.substring(0, index);
-            String extension = filename.substring(index);
-            format = name + "-%d" + extension;
-        }
-        else {
-            format = filename + "-%d";
-        }
-        for (int i = 2; i < Integer.MAX_VALUE; i++) {
-            file = new File(directory, String.format(format, i));
-            if (!file.exists()) {
-                return file;
-            }
-        }
-        return null;
-    }
-
-    private void onDownloadAttachment(Attachment attachment) {
-        if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
-            /*
-             * Abort early if there's no place to save the attachment. We don't want to spend
-             * the time downloading it and then abort.
-             */
-            Toast.makeText(this,
-                    getString(R.string.message_view_status_attachment_not_saved),
-                    Toast.LENGTH_SHORT).show();
-            return;
-        }
-        if (mMessage != null)
-        {
-          MessagingController.getInstance(getApplication()).loadAttachment(
-                  mAccount,
-                  mMessage,
-                  attachment.part,
-                  new Object[] { true, attachment },
-                  mListener);
-        }
-    }
-
-    private void onViewAttachment(Attachment attachment) {
-      if (mMessage != null)
-      {
-        MessagingController.getInstance(getApplication()).loadAttachment(
-                mAccount,
-                mMessage,
-                attachment.part,
-                new Object[] { false, attachment },
-                mListener);
-      }
-    }
-
-    private void onShowPictures() {
-        mMessageContentView.getSettings().setBlockNetworkImage(false);
-        mShowPicturesSection.setVisibility(View.GONE);
-    }
-
-    public void onClick(View view) {
-        switch (view.getId()) {
-            case R.id.from:
-                onClickSender();
-                break;
-            case R.id.reply:
-            case R.id.reply_scrolling:
-                onReply();
-                break;
-            case R.id.reply_all:
-              onReplyAll();
-              break;
-            case R.id.delete:
-            case R.id.delete_scrolling:
-                onDelete();
-                break;
-            case R.id.forward:
-            case R.id.forward_scrolling:
-                onForward();
-                break;
-            case R.id.next:
-            case R.id.next_scrolling:
-                onNext();
-                break;
-            case R.id.previous:
-            case R.id.previous_scrolling:
-                onPrevious();
-                break;
-            case R.id.download:
-                onDownloadAttachment((Attachment) view.getTag());
-                break;
-            case R.id.view:
-                onViewAttachment((Attachment) view.getTag());
-                break;
-            case R.id.show_pictures:
-                onShowPictures();
-                break;
-        }
-    }
-
-    public boolean onOptionsItemSelected(MenuItem item) {
-        switch (item.getItemId()) {
-            case R.id.delete:
-                onDelete();
-                break;
-            case R.id.reply:
-                onReply();
-                break;
-            case R.id.reply_all:
-                onReplyAll();
-                break;
-            case R.id.forward:
-                onForward();
-                break;
-            case R.id.send_alternate:
-              onSendAlternate();
-              break;
-            case R.id.mark_as_unread:
-                onMarkAsUnread();
-                break;
-            case R.id.flag:
-              onFlag();
-              break;
-            case R.id.move:
-              onMove();
-              break;
-            case R.id.copy:
-              onCopy();
-              break;
-            default:
-                return super.onOptionsItemSelected(item);
-        }
-        return true;
-    }
-
-    public boolean onCreateOptionsMenu(Menu menu) {
-        super.onCreateOptionsMenu(menu);
-        getMenuInflater().inflate(R.menu.message_view_option, menu);
-        optionsMenu = menu;
-        setMenuFlag();
-        if (MessagingController.getInstance(getApplication()).isCopyCapable(mAccount) == false)
-        {
-         menu.findItem(R.id.copy).setVisible(false);
-        }
-       if (MessagingController.getInstance(getApplication()).isMoveCapable(mAccount) == false)
-       {
-        menu.findItem(R.id.move).setVisible(false);
-       }
-        return true;
-    }
-    
-    private void setMenuFlag()
-    {
-      Menu menu = optionsMenu;
-      if (menu != null)
-      {
-        MenuItem flagItem = menu.findItem(R.id.flag);
-        if (flagItem != null && mMessage != null)
-        {
-          flagItem.setTitle((mMessage.isSet(Flag.FLAGGED) ? R.string.unflag_action : R.string.flag_action));
-        }
-      }
-    }
-    
-    public CacheResult service(String url, Map<String, String> headers) {
-        if (url.startsWith(CID_PREFIX) && mMessage != null) {
-            try {
-                String contentId = url.substring(CID_PREFIX.length());
-                final Part part = MimeUtility.findPartByContentId(mMessage, "<" + contentId + ">");
-                if (part != null) {
-                    CacheResult cr = new CacheManager.CacheResult();
-                    // TODO looks fixed in Mainline, cr.setInputStream
-                    // part.getBody().writeTo(cr.getStream());
-                    return cr;
-                }
-            }
-            catch (Exception e) {
-                // TODO
-            }
-        }
-        return null;
-    }
-
-    public PluginData getPluginData(String url, Map<String, String> headers) {
-        if (url.startsWith(CID_PREFIX) && mMessage != null) {
-            try {
-                String contentId = url.substring(CID_PREFIX.length());
-                final Part part = MimeUtility.findPartByContentId(mMessage, "<" + contentId + ">");
-                if (part != null) {
-                    Map<String, String[]> splittedHeaders = new HashMap<String, String[]>();
-                    for (String headerName : headers.keySet()) {
-                        String heaverValue = headers.get(headerName);
-                        //There must be a better way to do this split and trim...
-                        String[] headerValues = heaverValue.split(",");
-                        for (int i=0; i<headerValues.length; i++) {
-                            headerValues[i] = headerValues[i].trim();
-                        }
-                        splittedHeaders.put(headerName, headerValues);
-                    }
-                    return new PluginData(
-                        part.getBody().getInputStream(),
-                        part.getSize(),
-                        splittedHeaders,
-                        HttpURLConnection.HTTP_OK);
-                }
-            }
-            catch (Exception e) {
-                // TODO
-            }
-        }
-        return null;
-    }
-
-    private Bitmap getPreviewIcon(Attachment attachment) throws MessagingException {
-        try {
-            return BitmapFactory.decodeStream(
-                    getContentResolver().openInputStream(
-                            AttachmentProvider.getAttachmentThumbnailUri(mAccount,
-                                    attachment.part.getAttachmentId(),
-                                    62,
-                                    62)));
-        }
-        catch (Exception e) {
-            /*
-             * We don't care what happened, we just return null for the preview icon.
-             */
-            return null;
-        }
-    }
-
-    /*
-     * Formats the given size as a String in bytes, kB, MB or GB with a single digit
-     * of precision. Ex: 12,315,000 = 12.3 MB
-     */
-    public static String formatSize(float size) {
-        long kb = 1024;
-        long mb = (kb * 1024);
-        long gb  = (mb * 1024);
-        if (size < kb) {
-            return String.format("%d bytes", (int) size);
-        }
-        else if (size < mb) {
-            return String.format("%.1f kB", size / kb);
-        }
-        else if (size < gb) {
-            return String.format("%.1f MB", size / mb);
-        }
-        else {
-            return String.format("%.1f GB", size / gb);
-        }
-    }
-
-    private void renderAttachments(Part part, int depth) throws MessagingException {
-        String contentType = MimeUtility.unfoldAndDecode(part.getContentType());
-        String contentDisposition = MimeUtility.unfoldAndDecode(part.getDisposition());
-        String name = MimeUtility.getHeaderParameter(contentType, "name");
-        if (name == null)
-        {
-          name = MimeUtility.getHeaderParameter(contentDisposition, "filename");
-        }
-        if (name != null) {
-            /*
-             * We're guaranteed size because LocalStore.fetch puts it there.
-             */
-            int size = Integer.parseInt(MimeUtility.getHeaderParameter(contentDisposition, "size"));
-
-            Attachment attachment = new Attachment();
-            attachment.size = size;
-            attachment.contentType = part.getMimeType();
-            attachment.name = name;
-            attachment.part = (LocalAttachmentBodyPart) part;
-
-            LayoutInflater inflater = getLayoutInflater();
-            View view = inflater.inflate(R.layout.message_view_attachment, null);
-
-            TextView attachmentName = (TextView)view.findViewById(R.id.attachment_name);
-            TextView attachmentInfo = (TextView)view.findViewById(R.id.attachment_info);
-            ImageView attachmentIcon = (ImageView)view.findViewById(R.id.attachment_icon);
-            Button attachmentView = (Button)view.findViewById(R.id.view);
-            Button attachmentDownload = (Button)view.findViewById(R.id.download);
-
-            if ((!MimeUtility.mimeTypeMatches(attachment.contentType,
-                    Email.ACCEPTABLE_ATTACHMENT_VIEW_TYPES))
-                    || (MimeUtility.mimeTypeMatches(attachment.contentType,
-                            Email.UNACCEPTABLE_ATTACHMENT_VIEW_TYPES))) {
-                attachmentView.setVisibility(View.GONE);
-            }
-            if ((!MimeUtility.mimeTypeMatches(attachment.contentType,
-                    Email.ACCEPTABLE_ATTACHMENT_DOWNLOAD_TYPES))
-                    || (MimeUtility.mimeTypeMatches(attachment.contentType,
-                            Email.UNACCEPTABLE_ATTACHMENT_DOWNLOAD_TYPES))) {
-                attachmentDownload.setVisibility(View.GONE);
-            }
-
-            if (attachment.size > Email.MAX_ATTACHMENT_DOWNLOAD_SIZE) {
-                attachmentView.setVisibility(View.GONE);
-                attachmentDownload.setVisibility(View.GONE);
-            }
-
-            attachment.viewButton = attachmentView;
-            attachment.downloadButton = attachmentDownload;
-            attachment.iconView = attachmentIcon;
-
-            view.setTag(attachment);
-            attachmentView.setOnClickListener(this);
-            attachmentView.setTag(attachment);
-            attachmentDownload.setOnClickListener(this);
-            attachmentDownload.setTag(attachment);
-
-            attachmentName.setText(name);
-            attachmentInfo.setText(formatSize(size));
-
-            Bitmap previewIcon = getPreviewIcon(attachment);
-            if (previewIcon != null) {
-                attachmentIcon.setImageBitmap(previewIcon);
-            }
-
-            mHandler.addAttachment(view);
-        }
-
-        if (part.getBody() instanceof Multipart) {
-            Multipart mp = (Multipart)part.getBody();
-            for (int i = 0; i < mp.getCount(); i++) {
-                renderAttachments(mp.getBodyPart(i), depth + 1);
-            }
-        }
-    }
-    
-    private void setHeaders(Account account, String folder, String uid,
-                final Message message) throws MessagingException
-    {
-      String subjectText = message.getSubject();
-      String fromText = Address.toFriendly(message.getFrom());
-      String dateText = Utility.isDateToday(message.getSentDate()) ? 
-          null :
-          getDateFormat().format(message.getSentDate());
-      String timeText = getTimeFormat().format(message.getSentDate());
-      String toText = Address.toFriendly(message.getRecipients(RecipientType.TO));
-      String ccText = Address.toFriendly(message.getRecipients(RecipientType.CC));
-      Log.d(Email.LOG_TAG, ccText);
-      boolean hasAttachments = ((LocalMessage) message).getAttachmentCount() > 0;
-      mHandler.setHeaders(subjectText,
-              fromText,
-              dateText,
-              timeText,
-              toText,
-              ccText,
-              hasAttachments,
-              message.isSet(Flag.FLAGGED),
-              message.isSet(Flag.ANSWERED));
-    }
-
-    class Listener extends MessagingListener {
-
-        @Override
-        public void loadMessageForViewHeadersAvailable(Account account, String folder, String uid,
-                final Message message) {
-            if (!mMessageUid.equals(uid)) {
-                return;
-            }
-
-            MessageView.this.mMessage = message;
-            try {
-                setHeaders(account, folder, uid, message);
-            }
-            catch (MessagingException me) {
-                if (Config.LOGV) {
-                    Log.v(Email.LOG_TAG, "loadMessageForViewHeadersAvailable", me);
-                }
-            }
-        }
-
-        @Override
-        public void loadMessageForViewBodyAvailable(Account account, String folder, String uid,
-            Message message) {
-            if (!mMessageUid.equals(uid)) {
-                return;
-            }
-            
-            MessageView.this.mMessage = message;
-            try {
-                String text;
-                Part part = MimeUtility.findFirstPartByMimeType(mMessage, "text/html");
-                if (part == null) {
-                    part = MimeUtility.findFirstPartByMimeType(mMessage, "text/plain");
-                    if (part == null) {
-                        text = null;
-                    }
-                    else {
-                        LocalTextBody body = (LocalTextBody)part.getBody();
-                        if (body == null) {
-                            text = null;
-                        }
-                        else {
-                            text = body.getBodyForDisplay();
-                        }
-                    }
-                }
-                else {
-                    text = MimeUtility.getTextFromPart(part);
-                }
-
-                if (text != null) {
-                    /*
-                     * TODO this should be smarter, change to regex for img, but consider how to
-                     * get background images and a million other things that HTML allows.
-                     */
-                    mMessageContentView.loadDataWithBaseURL("email://", text, "text/html", "utf-8", null);
-                    mHandler.showShowPictures(text.contains("<img"));
-                }
-                else {
-                    mMessageContentView.loadUrl("file:///android_asset/empty.html");
-                }
-
-                renderAttachments(mMessage, 0);
-            }
-            catch (Exception e) {
-                     if (Config.LOGV) {
-                          Log.v(Email.LOG_TAG, "loadMessageForViewBodyAvailable", e);
-                }
-            }
-        }//loadMessageForViewBodyAvailable
-
-
-        @Override
-        public void loadMessageForViewFailed(Account account, String folder, String uid,
-                final String message) {
-            if (!mMessageUid.equals(uid)) {
-                return;
-            }
-
-            mHandler.post(new Runnable() {
-                public void run() {
-                    setProgressBarIndeterminateVisibility(false);
-                    mHandler.networkError();
-                    mMessageContentView.loadUrl("file:///android_asset/empty.html");
-                }
-            });
-        }
-
-        @Override
-        public void loadMessageForViewFinished(Account account, String folder, String uid,
-                Message message) {
-            if (!mMessageUid.equals(uid)) {
-                return;
-            }
-
-            mHandler.post(new Runnable() {
-                public void run() {
-                    setProgressBarIndeterminateVisibility(false);
-                }
-            });
-        }
-
-        @Override
-        public void loadMessageForViewStarted(Account account, String folder, String uid) {
-            if (!mMessageUid.equals(uid)) {
-                return;
-            }
-
-            mHandler.post(new Runnable() {
-                public void run() {
-                    mMessageContentView.loadUrl("file:///android_asset/loading.html");
-                    setProgressBarIndeterminateVisibility(true);
-                }
-            });
-        }
-
-        @Override
-        public void loadAttachmentStarted(Account account, Message message,
-                Part part, Object tag, boolean requiresDownload) {
-            if (mMessage!=message) {
-                return;
-            }
-
-            mHandler.setAttachmentsEnabled(false);
-            mHandler.progress(true);
-            if (requiresDownload) {
-                mHandler.fetchingAttachment();
-            }
-        }
-
-        @Override
-        public void loadAttachmentFinished(Account account, Message message,
-                Part part, Object tag) {
-            if (mMessage!=message) {
-                return;
-            }
-
-            mHandler.setAttachmentsEnabled(true);
-            mHandler.progress(false);
-
-            Object[] params = (Object[]) tag;
-            boolean download = (Boolean) params[0];
-            Attachment attachment = (Attachment) params[1];
-
-            if (download) {
-                try {
-                    File file = createUniqueFile(Environment.getExternalStorageDirectory(),
-                            attachment.name);
-                    Uri uri = AttachmentProvider.getAttachmentUri(
-                            mAccount,
-                            attachment.part.getAttachmentId());
-                    InputStream in = getContentResolver().openInputStream(uri);
-                    OutputStream out = new FileOutputStream(file);
-                    IOUtils.copy(in, out);
-                    out.flush();
-                    out.close();
-                    in.close();
-                    mHandler.attachmentSaved(file.getName());
-                    new MediaScannerNotifier(MessageView.this, file);
-                }
-                catch (IOException ioe) {
-                    mHandler.attachmentNotSaved();
-                }
-            }
-            else {
-                Uri uri = AttachmentProvider.getAttachmentUri(
-                        mAccount,
-                        attachment.part.getAttachmentId());
-                Intent intent = new Intent(Intent.ACTION_VIEW);
-                intent.setData(uri);
-                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
-                startActivity(intent);
-            }
-        }
-
-        @Override
-        public void loadAttachmentFailed(Account account, Message message, Part part,
-                Object tag, String reason) {
-            if (mMessage!=message) {
-                return;
-            }
-
-            mHandler.setAttachmentsEnabled(true);
-            mHandler.progress(false);
-            mHandler.networkError();
-        }
-    }
-
-    class MediaScannerNotifier implements MediaScannerConnectionClient {
-        private MediaScannerConnection mConnection;
-        private File mFile;
-
-        public MediaScannerNotifier(Context context, File file) {
-            mFile = file;
-            mConnection = new MediaScannerConnection(context, this);
-            mConnection.connect();
-        }
-
-        public void onMediaScannerConnected() {
-            mConnection.scanFile(mFile.getAbsolutePath(), null);
-        }
-
-        public void onScanCompleted(String path, Uri uri) {
-            try {
-                if (uri != null) {
-                    Intent intent = new Intent(Intent.ACTION_VIEW);
-                    intent.setData(uri);
-                    startActivity(intent);
-                }
-            } finally {
-                mConnection.disconnect();
-            }
-        }
-    }
-
-}
Index: src/com/android/email/activity/setup/AccountSetupIncoming.java
===================================================================
--- src/com/android/email/activity/setup/AccountSetupIncoming.java	(revision 718)
+++ src/com/android/email/activity/setup/AccountSetupIncoming.java	(working copy)
@@ -1,440 +0,0 @@
-
-package com.android.email.activity.setup;
-
-import java.net.URI;
-import java.net.URISyntaxException;
-import android.app.Activity;
-import com.android.email.K9Activity;
-import android.app.AlertDialog;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.os.Bundle;
-import android.text.Editable;
-import android.text.TextWatcher;
-import android.text.method.DigitsKeyListener;
-import android.util.Log;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.widget.AdapterView;
-import android.widget.ArrayAdapter;
-import android.widget.Button;
-import android.widget.EditText;
-import android.widget.Spinner;
-import android.widget.TextView;
-
-import com.android.email.Account;
-import com.android.email.Email;
-import com.android.email.Preferences;
-import com.android.email.R;
-import com.android.email.Utility;
-import com.android.email.activity.ChooseFolder;
-
-public class AccountSetupIncoming extends K9Activity implements OnClickListener {
-    private static final String EXTRA_ACCOUNT = "account";
-    private static final String EXTRA_MAKE_DEFAULT = "makeDefault";
-    
-    private static final int SELECT_DRAFT_FOLDER = 100;
-    private static final int SELECT_SENT_FOLDER = 101;
-    private static final int SELECT_TRASH_FOLDER = 102;
-    private static final int SELECT_OUTBOX_FOLDER = 103;
-
-    private static final int popPorts[] = {
-            110, 995, 995, 110, 110
-    };
-    private static final String popSchemes[] = {
-            "pop3", "pop3+ssl", "pop3+ssl+", "pop3+tls", "pop3+tls+"
-    };
-    private static final int imapPorts[] = {
-            143, 993, 993, 143, 143
-    };
-    private static final String imapSchemes[] = {
-            "imap", "imap+ssl", "imap+ssl+", "imap+tls", "imap+tls+"
-    };
-    private static final int webdavPorts[] = {
-            80, 443, 443, 443, 443
-    };
-    private static final String webdavSchemes[] = {
-        "webdav", "webdav+ssl", "webdav+ssl+", "webdav+tls", "webdav+tls+"
-    };
-
-    private int mAccountPorts[];
-    private String mAccountSchemes[];
-    private EditText mUsernameView;
-    private EditText mPasswordView;
-    private EditText mServerView;
-    private EditText mPortView;
-    private Spinner mSecurityTypeView;
-    private EditText mImapPathPrefixView;
-    private Button mImapFolderDrafts;
-    private Button mImapFolderSent;
-    private Button mImapFolderTrash;
-    private Button mImapFolderOutbox;
-    private EditText mWebdavPathPrefixView;
-    private EditText mWebdavAuthPathView;
-    private EditText mWebdavMailboxPathView;
-    private Button mNextButton;
-    private Account mAccount;
-    private boolean mMakeDefault;
-
-    public static void actionIncomingSettings(Activity context, Account account, boolean makeDefault) {
-        Intent i = new Intent(context, AccountSetupIncoming.class);
-        i.putExtra(EXTRA_ACCOUNT, account);
-        i.putExtra(EXTRA_MAKE_DEFAULT, makeDefault);
-        context.startActivity(i);
-    }
-
-    public static void actionEditIncomingSettings(Activity context, Account account) {
-        Intent i = new Intent(context, AccountSetupIncoming.class);
-        i.setAction(Intent.ACTION_EDIT);
-        i.putExtra(EXTRA_ACCOUNT, account);
-        context.startActivity(i);
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.account_setup_incoming);
-
-        mUsernameView = (EditText)findViewById(R.id.account_username);
-        mPasswordView = (EditText)findViewById(R.id.account_password);
-        TextView serverLabelView = (TextView) findViewById(R.id.account_server_label);
-        mServerView = (EditText)findViewById(R.id.account_server);
-        mPortView = (EditText)findViewById(R.id.account_port);
-        mSecurityTypeView = (Spinner)findViewById(R.id.account_security_type);
-        mImapPathPrefixView = (EditText)findViewById(R.id.imap_path_prefix);
-        mImapFolderDrafts = (Button)findViewById(R.id.account_imap_folder_drafts);
-        mImapFolderSent = (Button)findViewById(R.id.account_imap_folder_sent);
-        mImapFolderTrash = (Button)findViewById(R.id.account_imap_folder_trash);
-        mImapFolderOutbox = (Button)findViewById(R.id.account_imap_folder_outbox);
-        mWebdavPathPrefixView = (EditText)findViewById(R.id.webdav_path_prefix);
-        mWebdavAuthPathView = (EditText)findViewById(R.id.webdav_auth_path);
-        mWebdavMailboxPathView = (EditText)findViewById(R.id.webdav_mailbox_path);
-        mNextButton = (Button)findViewById(R.id.next);
-
-        mImapFolderDrafts.setOnClickListener(this);
-        mImapFolderSent.setOnClickListener(this);
-        mImapFolderTrash.setOnClickListener(this);
-        mImapFolderOutbox.setOnClickListener(this);
-        mNextButton.setOnClickListener(this);
-
-        SpinnerOption securityTypes[] = {
-                new SpinnerOption(0, getString(R.string.account_setup_incoming_security_none_label)),
-                new SpinnerOption(1,
-                        getString(R.string.account_setup_incoming_security_ssl_optional_label)),
-                new SpinnerOption(2, getString(R.string.account_setup_incoming_security_ssl_label)),
-                new SpinnerOption(3,
-                        getString(R.string.account_setup_incoming_security_tls_optional_label)),
-                new SpinnerOption(4, getString(R.string.account_setup_incoming_security_tls_label)),
-        };
-
-        ArrayAdapter<SpinnerOption> securityTypesAdapter = new ArrayAdapter<SpinnerOption>(this,
-                android.R.layout.simple_spinner_item, securityTypes);
-        securityTypesAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
-        mSecurityTypeView.setAdapter(securityTypesAdapter);
-
-        /*
-         * Updates the port when the user changes the security type. This allows
-         * us to show a reasonable default which the user can change.
-         */
-        mSecurityTypeView.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
-            public void onItemSelected(AdapterView arg0, View arg1, int arg2, long arg3) {
-                updatePortFromSecurityType();
-            }
-
-            public void onNothingSelected(AdapterView<?> arg0) {
-            }
-        });
-
-        /*
-         * Calls validateFields() which enables or disables the Next button
-         * based on the fields' validity.
-         */
-        TextWatcher validationTextWatcher = new TextWatcher() {
-            public void afterTextChanged(Editable s) {
-                validateFields();
-            }
-
-            public void beforeTextChanged(CharSequence s, int start, int count, int after) {
-            }
-
-            public void onTextChanged(CharSequence s, int start, int before, int count) {
-            }
-        };
-        mUsernameView.addTextChangedListener(validationTextWatcher);
-        mPasswordView.addTextChangedListener(validationTextWatcher);
-        mServerView.addTextChangedListener(validationTextWatcher);
-        mPortView.addTextChangedListener(validationTextWatcher);
-
-        /*
-         * Only allow digits in the port field.
-         */
-        mPortView.setKeyListener(DigitsKeyListener.getInstance("0123456789"));
-
-        mAccount = (Account)getIntent().getSerializableExtra(EXTRA_ACCOUNT);
-        mMakeDefault = (boolean)getIntent().getBooleanExtra(EXTRA_MAKE_DEFAULT, false);
-
-        /*
-         * If we're being reloaded we override the original account with the one
-         * we saved
-         */
-        if (savedInstanceState != null && savedInstanceState.containsKey(EXTRA_ACCOUNT)) {
-            mAccount = (Account)savedInstanceState.getSerializable(EXTRA_ACCOUNT);
-        }
-
-        try {
-            URI uri = new URI(mAccount.getStoreUri());
-            String username = null;
-            String password = null;
-            if (uri.getUserInfo() != null) {
-                String[] userInfoParts = uri.getUserInfo().split(":", 2);
-                username = userInfoParts[0];
-                if (userInfoParts.length > 1) {
-                    password = userInfoParts[1];
-                }
-            }
-
-            if (username != null) {
-                mUsernameView.setText(username);
-            }
-
-            if (password != null) {
-                mPasswordView.setText(password);
-            }
-            
-            mImapFolderDrafts.setText(mAccount.getDraftsFolderName());
-            mImapFolderSent.setText(mAccount.getSentFolderName());
-            mImapFolderTrash.setText(mAccount.getTrashFolderName());
-            mImapFolderOutbox.setText(mAccount.getOutboxFolderName());
-
-            if (uri.getScheme().startsWith("pop3")) {
-                serverLabelView.setText(R.string.account_setup_incoming_pop_server_label);
-                mAccountPorts = popPorts;
-                mAccountSchemes = popSchemes;
-
-                findViewById(R.id.imap_path_prefix_section).setVisibility(View.GONE);
-                findViewById(R.id.imap_folder_setup_section).setVisibility(View.GONE);
-                findViewById(R.id.webdav_path_prefix_section).setVisibility(View.GONE);
-                findViewById(R.id.webdav_path_debug_section).setVisibility(View.GONE);
-            } else if (uri.getScheme().startsWith("imap")) {
-                serverLabelView.setText(R.string.account_setup_incoming_imap_server_label);
-                mAccountPorts = imapPorts;
-                mAccountSchemes = imapSchemes;
-
-                if (uri.getPath() != null && uri.getPath().length() > 0) {
-                    mImapPathPrefixView.setText(uri.getPath().substring(1));
-                }
-                findViewById(R.id.webdav_path_prefix_section).setVisibility(View.GONE);
-                findViewById(R.id.webdav_path_debug_section).setVisibility(View.GONE);
-                
-            } else if (uri.getScheme().startsWith("webdav")) {
-                serverLabelView.setText(R.string.account_setup_incoming_webdav_server_label);
-                mAccountPorts = webdavPorts;
-                mAccountSchemes = webdavSchemes;
-
-                /** Hide the unnecessary fields */
-                findViewById(R.id.imap_path_prefix_section).setVisibility(View.GONE);
-                findViewById(R.id.imap_folder_setup_section).setVisibility(View.GONE);
-                if (uri.getPath() != null && uri.getPath().length() > 0) {
-                    String[] pathParts = uri.getPath().split("\\|");
-
-                    for (int i = 0, count = pathParts.length; i < count; i++) {
-                        if (i == 0) {
-                            if (pathParts[0] != null &&
-                                pathParts[0].length() > 1) {
-                                mWebdavPathPrefixView.setText(pathParts[0].substring(1));
-                            }
-                        } else if (i == 1) {
-                            if (pathParts[1] != null &&
-                                pathParts[1].length() > 1) {
-                                mWebdavAuthPathView.setText(pathParts[1]);
-                            }
-                        } else if (i == 2) {
-                            if (pathParts[2] != null &&
-                                pathParts[2].length() > 1) {
-                                mWebdavMailboxPathView.setText(pathParts[2]);
-                            }
-                        }
-                    }
-                }
-            } else {
-                throw new Error("Unknown account type: " + mAccount.getStoreUri());
-            }
-
-            for (int i = 0; i < mAccountSchemes.length; i++) {
-                if (mAccountSchemes[i].equals(uri.getScheme())) {
-                    SpinnerOption.setSpinnerOptionValue(mSecurityTypeView, i);
-                }
-            }
-
-            if (uri.getHost() != null) {
-                mServerView.setText(uri.getHost());
-            }
-
-            if (uri.getPort() != -1) {
-                mPortView.setText(Integer.toString(uri.getPort()));
-            } else {
-                updatePortFromSecurityType();
-            }
-        } catch (URISyntaxException use) {
-            /*
-             * We should always be able to parse our own settings.
-             */
-            throw new Error(use);
-        }
-
-        validateFields();
-    }
-
-    @Override
-    public void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        outState.putSerializable(EXTRA_ACCOUNT, mAccount);
-    }
-
-    private void validateFields() {
-        mNextButton
-                .setEnabled(Utility.requiredFieldValid(mUsernameView)
-                        && Utility.requiredFieldValid(mPasswordView)
-                        && Utility.domainFieldValid(mServerView)
-                        && Utility.requiredFieldValid(mPortView));
-        Utility.setCompoundDrawablesAlpha(mNextButton, mNextButton.isEnabled() ? 255 : 128);
-    }
-
-    private void updatePortFromSecurityType() {
-        int securityType = (Integer)((SpinnerOption)mSecurityTypeView.getSelectedItem()).value;
-        mPortView.setText(Integer.toString(mAccountPorts[securityType]));
-    }
-
-    @Override
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        if (resultCode == RESULT_OK) {
-        	switch (requestCode) {
-        	case SELECT_DRAFT_FOLDER:
-        		mImapFolderDrafts.setText(data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER));
-        		return;
-        	case SELECT_SENT_FOLDER:
-        		mImapFolderSent.setText(data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER));
-        		return;
-        	case SELECT_TRASH_FOLDER:
-        		mImapFolderTrash.setText(data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER));
-        		return;
-        	case SELECT_OUTBOX_FOLDER:
-        		mImapFolderOutbox.setText(data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER));
-        		return;
-        	}
-            if (Intent.ACTION_EDIT.equals(getIntent().getAction())) {
-                mAccount.save(Preferences.getPreferences(this));
-                finish();
-            } else {
-                /*
-                 * Set the username and password for the outgoing settings to the username and
-                 * password the user just set for incoming.
-                 */
-                try {
-                    URI oldUri = new URI(mAccount.getTransportUri());
-                    URI uri = new URI(
-                            oldUri.getScheme(),
-                            mUsernameView.getText() + ":" + mPasswordView.getText(),
-                            oldUri.getHost(),
-                            oldUri.getPort(),
-                            null,
-                            null,
-                            null);
-                    mAccount.setTransportUri(uri.toString());
-                } catch (URISyntaxException use) {
-                    /*
-                     * If we can't set up the URL we just continue. It's only for
-                     * convenience.
-                     */
-                }
-
-
-                AccountSetupOutgoing.actionOutgoingSettings(this, mAccount, mMakeDefault);
-                finish();
-            }
-        }
-    }
-
-    private void onNext() {
-        int securityType = (Integer)((SpinnerOption)mSecurityTypeView.getSelectedItem()).value;
-        try {
-            String path = null;
-            if (mAccountSchemes[securityType].startsWith("imap")) {
-                path = "/" + mImapPathPrefixView.getText();
-            } else if (mAccountSchemes[securityType].startsWith("webdav")) {
-                path = "/" + mWebdavPathPrefixView.getText();
-                path = path + "|" + mWebdavAuthPathView.getText();
-                path = path + "|" + mWebdavMailboxPathView.getText();
-            }
-
-            URI uri = new URI(
-                    mAccountSchemes[securityType],
-                    mUsernameView.getText() + ":" + mPasswordView.getText(),
-                    mServerView.getText().toString(),
-                    Integer.parseInt(mPortView.getText().toString()),
-                    path, // path
-                    null, // query
-                    null);
-            mAccount.setStoreUri(uri.toString());
-        } catch (URISyntaxException use) {
-            /*
-             * It's unrecoverable if we cannot create a URI from components that
-             * we validated to be safe.
-             */
-            throw new Error(use);
-        }
-
-        mAccount.setDraftsFolderName(mImapFolderDrafts.getText().toString());
-        mAccount.setSentFolderName(mImapFolderSent.getText().toString());
-        mAccount.setTrashFolderName(mImapFolderTrash.getText().toString());
-        mAccount.setOutboxFolderName(mImapFolderOutbox.getText().toString());
-        AccountSetupCheckSettings.actionCheckSettings(this, mAccount, true, false);
-    }
-
-    public void onClick(View v) {
-        switch (v.getId()) {
-            case R.id.next:
-                onNext();
-                break;
-            case R.id.account_imap_folder_drafts:
-            	selectImapFolder(SELECT_DRAFT_FOLDER);
-            	break;
-            case R.id.account_imap_folder_sent:
-            	selectImapFolder(SELECT_SENT_FOLDER);
-            	break;
-            case R.id.account_imap_folder_trash:
-            	selectImapFolder(SELECT_TRASH_FOLDER);
-            	break;
-            case R.id.account_imap_folder_outbox:
-            	selectImapFolder(SELECT_OUTBOX_FOLDER);
-            	break;
-        }
-    }
-
-	private void selectImapFolder(int activityCode) {
-		String curFolder = null;
-		switch (activityCode) {
-		case SELECT_DRAFT_FOLDER:
-			curFolder = mImapFolderDrafts.getText().toString();
-			break;
-		case SELECT_SENT_FOLDER:
-			curFolder = mImapFolderSent.getText().toString();
-			break;
-		case SELECT_TRASH_FOLDER:
-			curFolder = mImapFolderTrash.getText().toString();
-			break;
-		case SELECT_OUTBOX_FOLDER:
-			curFolder = mImapFolderOutbox.getText().toString();
-			break;
-		default:
-			throw new IllegalArgumentException(
-					"Cannot select folder for: " + activityCode);	
-		}
-		
-		Intent selectIntent = new Intent(this, ChooseFolder.class);
-		selectIntent.putExtra(ChooseFolder.EXTRA_ACCOUNT, mAccount);
-		selectIntent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, curFolder);
-		selectIntent.putExtra(ChooseFolder.EXTRA_SHOW_CURRENT, "yes");
-	    startActivityForResult(selectIntent, activityCode);
-	}
-}
Index: src/com/android/email/activity/ProgressListener.java
===================================================================
--- src/com/android/email/activity/ProgressListener.java	(revision 718)
+++ src/com/android/email/activity/ProgressListener.java	(working copy)
@@ -1,36 +0,0 @@
-
-package com.android.email.activity;
-
-import android.content.Context;
-
-/**
- * A listener that the user can register for global, persistent progress events.
- */
-public interface ProgressListener {
-    /**
-     * @param context
-     * @param title
-     * @param message
-     * @param currentProgress
-     * @param maxProgress
-     * @param indeterminate
-     */
-    void showProgress(Context context, String title, String message, long currentProgress,
-            long maxProgress, boolean indeterminate);
-
-    /**
-     * @param context
-     * @param title
-     * @param message
-     * @param currentProgress
-     * @param maxProgress
-     * @param indeterminate
-     */
-    void updateProgress(Context context, String title, String message, long currentProgress,
-            long maxProgress, boolean indeterminate);
-
-    /**
-     * @param context
-     */
-    void hideProgress(Context context);
-}
Index: src/com/android/email/mail/store/LocalStore.java
===================================================================
--- src/com/android/email/mail/store/LocalStore.java	(revision 718)
+++ src/com/android/email/mail/store/LocalStore.java	(working copy)
@@ -1,1850 +0,0 @@
-
-package com.android.email.mail.store;
-
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.Serializable;
-import java.io.UnsupportedEncodingException;
-import java.net.URI;
-import java.net.URLEncoder;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.UUID;
-import java.util.regex.Matcher;
-import android.content.SharedPreferences;
-
-import org.apache.commons.io.IOUtils;
-
-import android.app.Application;
-import android.content.ContentValues;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.net.Uri;
-import android.util.Log;
-import android.text.util.Regex;
-import android.text.util.Linkify;
-import android.text.Spannable;
-import android.text.SpannableString;
-
-import com.android.email.Email;
-import com.android.email.Preferences;
-import com.android.email.Utility;
-import com.android.email.codec.binary.Base64OutputStream;
-import com.android.email.mail.Address;
-import com.android.email.mail.Body;
-import com.android.email.mail.FetchProfile;
-import com.android.email.mail.Flag;
-import com.android.email.mail.Folder;
-import com.android.email.mail.Message;
-import com.android.email.mail.MessageRetrievalListener;
-import com.android.email.mail.MessagingException;
-import com.android.email.mail.Part;
-import com.android.email.mail.Store;
-import com.android.email.mail.Folder.FolderClass;
-import com.android.email.mail.Message.RecipientType;
-import com.android.email.mail.internet.MimeBodyPart;
-import com.android.email.mail.internet.MimeHeader;
-import com.android.email.mail.internet.MimeMessage;
-import com.android.email.mail.internet.MimeMultipart;
-import com.android.email.mail.internet.MimeUtility;
-import com.android.email.mail.internet.TextBody;
-import com.android.email.provider.AttachmentProvider;
-import java.io.StringReader;
-
-/**
- * <pre>
- * Implements a SQLite database backed local store for Messages.
- * </pre>
- */
-public class LocalStore extends Store implements Serializable {
-    private static final int DB_VERSION = 26;
-    private static final Flag[] PERMANENT_FLAGS = { Flag.DELETED, Flag.X_DESTROYED, Flag.SEEN };
-
-    private String mPath;
-    private SQLiteDatabase mDb;
-    private File mAttachmentsDir;
-    private Application mApplication;
-    private String uUid = null;
-
-    private static Set<String> HEADERS_TO_SAVE = new HashSet<String>();
-    static
-    {
-        HEADERS_TO_SAVE.add(Email.K9MAIL_IDENTITY);
-    }
-
-    /**
-     * @param uri local://localhost/path/to/database/uuid.db
-     */
-    public LocalStore(String _uri, Application application) throws MessagingException {
-        mApplication = application;
-        URI uri = null;
-        try {
-            uri = new URI(_uri);
-        } catch (Exception e) {
-            throw new MessagingException("Invalid uri for LocalStore");
-        }
-        if (!uri.getScheme().equals("local")) {
-            throw new MessagingException("Invalid scheme");
-        }
-        mPath = uri.getPath();
-
-      
-  			// We need to associate the localstore with the account.  Since we don't have the account
-  			// handy here, we'll take the filename from the DB and use the basename of the filename
-  			// Folders probably should have references to their containing accounts
-      	File dbFile = new File(mPath);
-      	String[] tokens = dbFile.getName().split("\\.");
-      	uUid = tokens[0];
-    
-        File parentDir = new File(mPath).getParentFile();
-        if (!parentDir.exists()) {
-            parentDir.mkdirs();
-        }
-        
-        mAttachmentsDir = new File(mPath + "_att");
-        if (!mAttachmentsDir.exists()) {
-            mAttachmentsDir.mkdirs();
-        }
-        
-        mDb = SQLiteDatabase.openOrCreateDatabase(mPath, null);
-        if (mDb.getVersion() != DB_VERSION) {
-            doDbUpgrade(mDb, application);
-        }
-        
-    }
-
-    
-    private void doDbUpgrade ( SQLiteDatabase mDb, Application application) {
-            Log.i(Email.LOG_TAG, String.format("Upgrading database from version %d to version %d", 
-                mDb.getVersion(), DB_VERSION));
-            
- 
-            AttachmentProvider.clear(application);
-            
-            mDb.execSQL("DROP TABLE IF EXISTS folders");
-            mDb.execSQL("CREATE TABLE folders (id INTEGER PRIMARY KEY, name TEXT, "
-                    + "last_updated INTEGER, unread_count INTEGER, visible_limit INTEGER, status TEXT)");
-
-            mDb.execSQL("CREATE INDEX IF NOT EXISTS folder_name ON folders (name)");
-            mDb.execSQL("DROP TABLE IF EXISTS messages");
-            mDb.execSQL("CREATE TABLE messages (id INTEGER PRIMARY KEY, folder_id INTEGER, uid TEXT, subject TEXT, "
-                    + "date INTEGER, flags TEXT, sender_list TEXT, to_list TEXT, cc_list TEXT, bcc_list TEXT, reply_to_list TEXT, "
-                    + "html_content TEXT, text_content TEXT, attachment_count INTEGER, internal_date INTEGER, message_id TEXT)");
-
-            mDb.execSQL("DROP TABLE IF EXISTS headers");
-            mDb.execSQL("CREATE TABLE headers (id INTEGER PRIMARY KEY, message_id INTEGER, name TEXT, value TEXT)");
-            mDb.execSQL("CREATE INDEX IF NOT EXISTS header_folder ON headers (message_id)");
-            
-            mDb.execSQL("CREATE INDEX IF NOT EXISTS msg_uid ON messages (uid, folder_id)");
-            mDb.execSQL("DROP INDEX IF EXISTS msg_folder_id");
-            mDb.execSQL("CREATE INDEX IF NOT EXISTS msg_folder_id_date ON messages (folder_id,internal_date)");
-            mDb.execSQL("DROP TABLE IF EXISTS attachments");
-            mDb.execSQL("CREATE TABLE attachments (id INTEGER PRIMARY KEY, message_id INTEGER,"
-                    + "store_data TEXT, content_uri TEXT, size INTEGER, name TEXT,"
-                    + "mime_type TEXT)");
-
-            mDb.execSQL("DROP TABLE IF EXISTS pending_commands");
-            mDb.execSQL("CREATE TABLE pending_commands " +
-                    "(id INTEGER PRIMARY KEY, command TEXT, arguments TEXT)");
-
-            mDb.execSQL("DROP TRIGGER IF EXISTS delete_folder");
-            mDb.execSQL("CREATE TRIGGER delete_folder BEFORE DELETE ON folders BEGIN DELETE FROM messages WHERE old.id = folder_id; END;");
-
-            mDb.execSQL("DROP TRIGGER IF EXISTS delete_message");
-            mDb.execSQL("CREATE TRIGGER delete_message BEFORE DELETE ON messages BEGIN DELETE FROM attachments WHERE old.id = message_id; "
-                    + "DELETE FROM headers where old.id = message_id; END;");
-            
-            mDb.setVersion(DB_VERSION);
-            if (mDb.getVersion() != DB_VERSION) {
-                throw new Error("Database upgrade failed!");
-            }
-            
-            try
-            {
-              pruneCachedAttachments(true);
-            }
-            catch (Exception me)
-            {
-              Log.e(Email.LOG_TAG, "Exception while force pruning attachments during DB update", me);
-            }
-        }
-    
-    public long getSize()
-    {
-      long attachmentLength = 0;
-    
-      File[] files = mAttachmentsDir.listFiles();
-      for (File file : files) {
-          if (file.exists()) {
-            attachmentLength += file.length();
-          }
-      }
-      
-      
-      File dbFile = new File(mPath);
-      return dbFile.length() + attachmentLength;
-    }
-    
-    public void compact() throws MessagingException
-    {
-      Log.i(Email.LOG_TAG, "Before prune size = " + getSize());
-      
-      pruneCachedAttachments();
-      Log.i(Email.LOG_TAG, "After prune / before compaction size = " + getSize());
-       
-      mDb.execSQL("VACUUM");
-      Log.i(Email.LOG_TAG, "After compaction size = " + getSize()); 
-    }
-
-    
-    public void clear() throws MessagingException
-    {
-      Log.i(Email.LOG_TAG, "Before prune size = " + getSize());
-      
-      pruneCachedAttachments(true);
-      
-      Log.i(Email.LOG_TAG, "After prune / before compaction size = " + getSize());
-     
-      Log.i(Email.LOG_TAG, "Before clear folder count = " + getFolderCount());
-      Log.i(Email.LOG_TAG, "Before clear message count = " + getMessageCount());
-
-      Log.i(Email.LOG_TAG, "After prune / before clear size = " + getSize());
-      // don't delete messages that are Local, since there is no copy on the server.
-      // Don't delete deleted messages.  They are essentially placeholders for UIDs of messages that have
-      // been deleted locally.  They take up no space, and are indicated with a null date.
-      mDb.execSQL("DELETE FROM messages WHERE date is not null and uid not like 'Local%'"  );
-       
-      compact();
-      Log.i(Email.LOG_TAG, "After clear message count = " + getMessageCount());
-
-      Log.i(Email.LOG_TAG, "After clear size = " + getSize()); 
-    }
-    
-    public int getMessageCount() throws MessagingException {
-        Cursor cursor = null;
-        try {
-            cursor = mDb.rawQuery("SELECT COUNT(*) FROM messages", null);
-            cursor.moveToFirst();
-            int messageCount = cursor.getInt(0);
-            return messageCount;
-        }
-        finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-        }
-    }
-    
-    public int getFolderCount() throws MessagingException {
-      Cursor cursor = null;
-      try {
-          cursor = mDb.rawQuery("SELECT COUNT(*) FROM folders", null);
-          cursor.moveToFirst();
-          int messageCount = cursor.getInt(0);
-          return messageCount;
-      }
-      finally {
-          if (cursor != null) {
-              cursor.close();
-          }
-      }
-  }
-    
-    @Override
-    public LocalFolder getFolder(String name) throws MessagingException {
-        return new LocalFolder(name);
-    }
-
-    // TODO this takes about 260-300ms, seems slow.
-    @Override
-    public LocalFolder[] getPersonalNamespaces() throws MessagingException {
-        ArrayList<LocalFolder> folders = new ArrayList<LocalFolder>();
-        Cursor cursor = null;
-
-
-        try {
-            cursor = mDb.rawQuery("SELECT name, id, unread_count, visible_limit, last_updated, status FROM folders", null);
-            while (cursor.moveToNext()) {
-            	LocalFolder folder = new LocalFolder(cursor.getString(0));
-              folder.open(cursor.getInt(1), cursor.getInt(2), cursor.getInt(3), cursor.getLong(4), cursor.getString(5));
-          
-              folders.add(folder);
-            }
-        }
-        finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-        }
-        return folders.toArray(new LocalFolder[] {});
-    }
-
-    @Override
-    public void checkSettings() throws MessagingException {
-    }
-
-    /**
-     * Delete the entire Store and it's backing database.
-     */
-    public void delete() {
-        try {
-            mDb.close();
-        } catch (Exception e) {
-
-        }
-        try{
-            File[] attachments = mAttachmentsDir.listFiles();
-            for (File attachment : attachments) {
-                if (attachment.exists()) {
-                    attachment.delete();
-                }
-            }
-            if (mAttachmentsDir.exists()) {
-                mAttachmentsDir.delete();
-            }
-        }
-        catch (Exception e) {
-        }
-        try {
-            new File(mPath).delete();
-        }
-        catch (Exception e) {
-
-        }
-    }
-
-    public void pruneCachedAttachments() throws MessagingException {
-      pruneCachedAttachments(false);
-    }
-    
-    /**
-     * Deletes all cached attachments for the entire store.
-     */
-    public void pruneCachedAttachments(boolean force) throws MessagingException {
-
-        if (force)
-        {
-          ContentValues cv = new ContentValues();
-          cv.putNull("content_uri");
-          mDb.update("attachments", cv, null, null);
-        }
-        File[] files = mAttachmentsDir.listFiles();
-        for (File file : files) {
-            if (file.exists()) {
-              if (!force) {
-                Cursor cursor = null;
-                try {
-                  cursor = mDb.query(
-                      "attachments",
-                      new String[] { "store_data" },
-                      "id = ?",
-                      new String[] { file.getName() },
-                      null,
-                      null,
-                      null);
-                  if (cursor.moveToNext()) {
-                      if (cursor.getString(0) == null) {
-                        Log.d(Email.LOG_TAG, "Attachment " + file.getAbsolutePath() + " has no store data, not deleting");
-                          /*
-                           * If the attachment has no store data it is not recoverable, so
-                           * we won't delete it.
-                           */
-                          continue;
-                      }
-                  }
-                }
-                finally {
-                    if (cursor != null) {
-                        cursor.close();
-                    }
-                }
-              }
-              if (!force)
-              {
-                try
-                {
-                  ContentValues cv = new ContentValues();
-                  cv.putNull("content_uri");
-                  mDb.update("attachments", cv, "id = ?", new String[] { file.getName() });
-                }
-                catch (Exception e) {
-                  /*
-                   * If the row has gone away before we got to mark it not-downloaded that's
-                   * okay.
-                   */
-                 }
-              }
-                Log.d(Email.LOG_TAG, "Deleting attachment " + file.getAbsolutePath() + ", which is of size " + file.length());
-                if (!file.delete()) {
-                    file.deleteOnExit();
-                }
-            }
-        }
-    }
-
-    public void resetVisibleLimits() {
-        resetVisibleLimits(Email.DEFAULT_VISIBLE_LIMIT);
-    }
-
-    public void resetVisibleLimits(int visibleLimit) {
-        ContentValues cv = new ContentValues();
-        cv.put("visible_limit", Integer.toString(visibleLimit));
-        mDb.update("folders", cv, null, null);
-    }
-
-    public ArrayList<PendingCommand> getPendingCommands() {
-        Cursor cursor = null;
-        try {
-            cursor = mDb.query("pending_commands",
-                    new String[] { "id", "command", "arguments" },
-                    null,
-                    null,
-                    null,
-                    null,
-                    "id ASC");
-            ArrayList<PendingCommand> commands = new ArrayList<PendingCommand>();
-            while (cursor.moveToNext()) {
-                PendingCommand command = new PendingCommand();
-                command.mId = cursor.getLong(0);
-                command.command = cursor.getString(1);
-                String arguments = cursor.getString(2);
-                command.arguments = arguments.split(",");
-                for (int i = 0; i < command.arguments.length; i++) {
-                    command.arguments[i] = Utility.fastUrlDecode(command.arguments[i]);
-                }
-                commands.add(command);
-            }
-            return commands;
-        }
-        finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-        }
-    }
-
-    public void addPendingCommand(PendingCommand command) {
-        try {
-            for (int i = 0; i < command.arguments.length; i++) {
-                command.arguments[i] = URLEncoder.encode(command.arguments[i], "UTF-8");
-            }
-            ContentValues cv = new ContentValues();
-            cv.put("command", command.command);
-            cv.put("arguments", Utility.combine(command.arguments, ','));
-            mDb.insert("pending_commands", "command", cv);
-        }
-        catch (UnsupportedEncodingException usee) {
-            throw new Error("Aparently UTF-8 has been lost to the annals of history.");
-        }
-    }
-
-    public void removePendingCommand(PendingCommand command) {
-        mDb.delete("pending_commands", "id = ?", new String[] { Long.toString(command.mId) });
-    }
-    
-    public void removePendingCommands() {
-      mDb.delete("pending_commands", null, null);
-  }
-
-    public static class PendingCommand {
-        private long mId;
-        public String command;
-        public String[] arguments;
-
-        @Override
-        public String toString() {
-            StringBuffer sb = new StringBuffer();
-            sb.append(command);
-            sb.append(": ");
-            for (String argument : arguments) {
-                sb.append("  ");
-                sb.append(argument);
-                //sb.append("\n");
-            }
-            return sb.toString();
-        }
-    }
-    
-    public boolean isMoveCapable() {
-      return true;
-    }
-    public boolean isCopyCapable() {
-      return true;
-    }
-    
-  
-
-    public class LocalFolder extends Folder implements Serializable {
-        private String mName;
-        private long mFolderId = -1;
-        private int mUnreadMessageCount = -1;
-        private int mVisibleLimit = -1;
-    		private FolderClass displayClass = FolderClass.NONE;
-    		private FolderClass syncClass = FolderClass.NONE;
-    		private String prefId = null;
-
-        public LocalFolder(String name) {
-            this.mName = name;
-            
-            if (Email.INBOX.equals(getName()))
-            {
-              syncClass =  FolderClass.FIRST_CLASS;
-            }
-     
-        }
-
-        public long getId() {
-            return mFolderId;
-        }
-
-        @Override
-        public void open(OpenMode mode) throws MessagingException {
-          if (isOpen()) {
-            return;
-          }
-          Cursor cursor = null;
-          try {
-            cursor = mDb.rawQuery("SELECT id, unread_count, visible_limit, last_updated, status FROM folders "
-                + "where folders.name = ?",
-                new String[] {
-                    mName
-                });
-
-            if (cursor.moveToFirst()) {
-              int folderId = cursor.getInt(0);
-              if (folderId > 0)
-              {
-                open(cursor.getInt(0), cursor.getInt(1), cursor.getInt(2), cursor.getLong(3), cursor.getString(4));
-              }
-            } else {
-              create(FolderType.HOLDS_MESSAGES);
-              open(mode);
-            }
-          }
-          finally {
-            if (cursor != null) {
-              cursor.close();
-            }
-          }
-        }
-        
-        private void open(int id, int unreadCount, int visibleLimit, long lastChecked, String status) throws MessagingException
-        {
-         	mFolderId = id;
-          mUnreadMessageCount = unreadCount;
-          mVisibleLimit = visibleLimit;
-          super.setStatus(status);
-          // Only want to set the local variable stored in the super class.  This class 
-          // does a DB update on setLastChecked
-          super.setLastChecked(lastChecked);
-        }
-
-        @Override
-        public boolean isOpen() {
-            return mFolderId != -1;
-        }
-
-        @Override
-        public OpenMode getMode() throws MessagingException {
-            return OpenMode.READ_WRITE;
-        }
-
-        @Override
-        public String getName() {
-            return mName;
-        }
-
-        @Override
-        public boolean exists() throws MessagingException {
-            Cursor cursor = null;
-            try {
-                cursor = mDb.rawQuery("SELECT id FROM folders "
-                        + "where folders.name = ?", new String[] { this
-                        .getName() });
-                if (cursor.moveToFirst()) {
-                    int folderId = cursor.getInt(0);
-                    return (folderId > 0) ? true : false;
-                } else {
-                    return false;
-                }
-            } finally {
-                if (cursor != null) {
-                    cursor.close();
-                }
-            }
-        }
-
-        @Override
-        public boolean create(FolderType type) throws MessagingException {
-            if (exists()) {
-                throw new MessagingException("Folder " + mName + " already exists.");
-            }
-            mDb.execSQL("INSERT INTO folders (name, visible_limit) VALUES (?, ?)", new Object[] {
-                mName,
-                Email.DEFAULT_VISIBLE_LIMIT 
-            });
-            return true;
-        }
-
-        public boolean create(FolderType type, int visibleLimit) throws MessagingException {
-            if (exists()) {
-                throw new MessagingException("Folder " + mName + " already exists.");
-            }
-            mDb.execSQL("INSERT INTO folders (name, visible_limit) VALUES (?, ?)", new Object[] {
-                mName,
-                visibleLimit
-            });
-            return true;
-        }
-
-        @Override
-        public void close(boolean expunge) throws MessagingException {
-            if (expunge) {
-                expunge();
-            }
-            mFolderId = -1;
-        }
-
-        @Override
-        public int getMessageCount() throws MessagingException {
-            open(OpenMode.READ_WRITE);
-            Cursor cursor = null;
-            try {
-                cursor = mDb.rawQuery("SELECT COUNT(*) FROM messages WHERE messages.folder_id = ?",
-                        new String[] {
-                            Long.toString(mFolderId)
-                        });
-                cursor.moveToFirst();
-                int messageCount = cursor.getInt(0);
-                return messageCount;
-            }
-            finally {
-                if (cursor != null) {
-                    cursor.close();
-                }
-            }
-        }
-
-        @Override
-        public int getUnreadMessageCount() throws MessagingException {
-            open(OpenMode.READ_WRITE);
-            return mUnreadMessageCount;
-        }
-
-
-        public void setUnreadMessageCount(int unreadMessageCount) throws MessagingException {
-            open(OpenMode.READ_WRITE);
-            mUnreadMessageCount = Math.max(0, unreadMessageCount);
-            mDb.execSQL("UPDATE folders SET unread_count = ? WHERE id = ?",
-                    new Object[] { mUnreadMessageCount, mFolderId });
-        }
-        
-        public void setLastChecked(long lastChecked) throws MessagingException {
-          open(OpenMode.READ_WRITE);
-          super.setLastChecked(lastChecked);
-          mDb.execSQL("UPDATE folders SET last_updated = ? WHERE id = ?",
-                  new Object[] { lastChecked, mFolderId });
-      }
-
-        public int getVisibleLimit() throws MessagingException {
-            open(OpenMode.READ_WRITE);
-            return mVisibleLimit;
-        }
-
-
-        public void setVisibleLimit(int visibleLimit) throws MessagingException {
-            open(OpenMode.READ_WRITE);
-            mVisibleLimit = visibleLimit;
-            mDb.execSQL("UPDATE folders SET visible_limit = ? WHERE id = ?",
-                    new Object[] { mVisibleLimit, mFolderId });
-        }
-        
-        public void setStatus(String status) throws MessagingException
-        {
-        	open(OpenMode.READ_WRITE);
-        	super.setStatus(status);
-          mDb.execSQL("UPDATE folders SET status = ? WHERE id = ?",
-                  new Object[] { status, mFolderId });
-        }
-        @Override
-      	public FolderClass getDisplayClass()
-    		{
-    			return displayClass;
-    		}
-    		
-        @Override
-    		public FolderClass getSyncClass()
-    		{
-    			if (FolderClass.NONE == syncClass)
-    			{
-    				return displayClass;
-    			}
-    			else
-    			{
-    				return syncClass;
-    			}
-    		}
-        
-        public FolderClass getRawSyncClass()
-    		{
-    			
-    			return syncClass;
-    			
-    		}
-
-    		public void setDisplayClass(FolderClass displayClass)
-    		{
-    			this.displayClass = displayClass;
-    		}
-    		
-    		public void setSyncClass(FolderClass syncClass)
-    		{
-    			this.syncClass = syncClass;
-    		}
-    		
-    		private String getPrefId() throws MessagingException
-    		{
-     			open(OpenMode.READ_WRITE);
-   			
-         	if (prefId == null)
-         	{
-         		prefId = uUid + "." + mName;
-         	}
-   
-    			return prefId; 
-    		}
-        
-        public void delete(Preferences preferences) throws MessagingException {
-        	String id = getPrefId();
-          
-        	SharedPreferences.Editor editor = preferences.getPreferences().edit();
-          
-        	editor.remove(id + ".displayMode");
-          editor.remove(id + ".syncMode");
-
-          editor.commit();
-      }
-
-      public void save(Preferences preferences) throws MessagingException {
-      		String id = getPrefId();
-        
-          SharedPreferences.Editor editor = preferences.getPreferences().edit();
-          // there can be a lot of folders.  For the defaults, let's not save prefs, saving space, except for INBOX
-          if (displayClass == FolderClass.NONE && !Email.INBOX.equals(getName()))
-          {
-          	editor.remove(id + ".displayMode");
-          }
-          else
-          {
-           	editor.putString(id + ".displayMode", displayClass.name());
-          }
-          
-          if (syncClass == FolderClass.NONE && !Email.INBOX.equals(getName()))
-          {
-          	editor.remove(id + ".syncMode");
-          }
-          else
-          {
-           	editor.putString(id + ".syncMode", syncClass.name());
-          }
-         
-          editor.commit();
-      }
-      public void refresh(Preferences preferences) throws MessagingException {
-      	
-     		String id = getPrefId();
-      		
-        try
-        {
-        	displayClass = FolderClass.valueOf(preferences.getPreferences().getString(id + ".displayMode", 
-        			FolderClass.NONE.name()));
-        }
-        catch (Exception e)
-        {
-         	Log.e(Email.LOG_TAG, "Unable to load displayMode for " + getName(), e);
-
-        	displayClass = FolderClass.NONE;
-        }
-
-        
-        FolderClass defSyncClass = FolderClass.NONE;
-        if (Email.INBOX.equals(getName()))
-        {
-          defSyncClass =  FolderClass.FIRST_CLASS;
-        }
-        
-        try
-        {
-        	syncClass = FolderClass.valueOf(preferences.getPreferences().getString(id  + ".syncMode", 
-        			defSyncClass.name()));
-        }
-        catch (Exception e)
-        {
-        	Log.e(Email.LOG_TAG, "Unable to load syncMode for " + getName(), e);
-
-        	syncClass = defSyncClass;
-        }
-
-    }
-      
-        @Override
-        public void fetch(Message[] messages, FetchProfile fp, MessageRetrievalListener listener)
-                throws MessagingException {
-            open(OpenMode.READ_WRITE);
-            if (fp.contains(FetchProfile.Item.BODY)) {
-                for (Message message : messages) {
-                    LocalMessage localMessage = (LocalMessage)message;
-                    Cursor cursor = null;
-                    localMessage.setHeader(MimeHeader.HEADER_CONTENT_TYPE, "multipart/mixed");
-                    MimeMultipart mp = new MimeMultipart();
-                    mp.setSubType("mixed");
-                    localMessage.setBody(mp);
-                    try {
-                        cursor = mDb.rawQuery("SELECT html_content, text_content FROM messages "
-                                + "WHERE id = ?",
-                                new String[] { Long.toString(localMessage.mId) });
-                        cursor.moveToNext();
-                        String htmlContent = cursor.getString(0);
-                        String textContent = cursor.getString(1);
-
-                        if (textContent != null) {
-                            LocalTextBody body = new LocalTextBody(textContent, htmlContent);
-                            MimeBodyPart bp = new MimeBodyPart(body, "text/plain");
-                            mp.addBodyPart(bp);
-                        }
-                        else {
-                            TextBody body = new TextBody(htmlContent);
-                            MimeBodyPart bp = new MimeBodyPart(body, "text/html");
-                            mp.addBodyPart(bp);
-                        }
-                    }
-                    finally {
-                        if (cursor != null) {
-                            cursor.close();
-                        }
-                    }
-
-                    try {
-                        cursor = mDb.query(
-                                "attachments",
-                                new String[] {
-                                        "id",
-                                        "size",
-                                        "name",
-                                        "mime_type",
-                                        "store_data",
-                                        "content_uri" },
-                                "message_id = ?",
-                                new String[] { Long.toString(localMessage.mId) },
-                                null,
-                                null,
-                                null);
-
-                        while (cursor.moveToNext()) {
-                            long id = cursor.getLong(0);
-                            int size = cursor.getInt(1);
-                            String name = cursor.getString(2);
-                            String type = cursor.getString(3);
-                            String storeData = cursor.getString(4);
-                            String contentUri = cursor.getString(5);
-                            Body body = null;
-                            if (contentUri != null) {
-                                body = new LocalAttachmentBody(Uri.parse(contentUri), mApplication);
-                            }
-                            MimeBodyPart bp = new LocalAttachmentBodyPart(body, id);
-                            bp.setHeader(MimeHeader.HEADER_CONTENT_TYPE,
-                                    String.format("%s;\n name=\"%s\"",
-                                    type,
-                                    name));
-                            bp.setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, "base64");
-                            bp.setHeader(MimeHeader.HEADER_CONTENT_DISPOSITION,
-                                    String.format("attachment;\n filename=\"%s\";\n size=%d",
-                                    name,
-                                    size));
-
-                            /*
-                             * HEADER_ANDROID_ATTACHMENT_STORE_DATA is a custom header we add to that
-                             * we can later pull the attachment from the remote store if neccesary.
-                             */
-                            bp.setHeader(MimeHeader.HEADER_ANDROID_ATTACHMENT_STORE_DATA, storeData);
-
-                            mp.addBodyPart(bp);
-                        }
-                    }
-                    finally {
-                        if (cursor != null) {
-                            cursor.close();
-                        }
-                    }
-                }
-            }
-        }
-
-        private void populateMessageFromGetMessageCursor(LocalMessage message, Cursor cursor)
-                throws MessagingException{
-            message.setSubject(cursor.getString(0) == null ? "" : cursor.getString(0));
-            Address[] from = Address.unpack(cursor.getString(1));
-            if (from.length > 0) {
-                message.setFrom(from[0]);
-            }
-            message.setInternalSentDate(new Date(cursor.getLong(2)));
-            message.setUid(cursor.getString(3));
-            String flagList = cursor.getString(4);
-            if (flagList != null && flagList.length() > 0) {
-                String[] flags = flagList.split(",");
-                try {
-                    for (String flag : flags) {
-                        message.setFlagInternal(Flag.valueOf(flag), true);
-                    }
-                } catch (Exception e) {
-                }
-            }
-            message.mId = cursor.getLong(5);
-            message.setRecipients(RecipientType.TO, Address.unpack(cursor.getString(6)));
-            message.setRecipients(RecipientType.CC, Address.unpack(cursor.getString(7)));
-            message.setRecipients(RecipientType.BCC, Address.unpack(cursor.getString(8)));
-            message.setReplyTo(Address.unpack(cursor.getString(9)));
-            message.mAttachmentCount = cursor.getInt(10);
-            message.setInternalDate(new Date(cursor.getLong(11)));
-            message.setHeader("Message-ID", cursor.getString(12));
-        }
-
-        @Override
-        public Message[] getMessages(int start, int end, MessageRetrievalListener listener)
-                throws MessagingException {
-            open(OpenMode.READ_WRITE);
-            throw new MessagingException(
-                    "LocalStore.getMessages(int, int, MessageRetrievalListener) not yet implemented");
-        }
-
-        private void populateHeaders(List<LocalMessage> messages)
-        {
-            Cursor cursor = null;
-            if (messages.size() == 0)
-            {
-                return;
-            }
-            try {
-                Map<Long, LocalMessage> popMessages = new HashMap<Long, LocalMessage>();
-                List<String> ids = new ArrayList<String>();
-                StringBuffer questions = new StringBuffer();
-   
-                for (int i = 0; i < messages.size(); i++)
-                {
-                    if (i != 0)
-                    {
-                        questions.append(", ");
-                    }
-                    questions.append("?");
-                    LocalMessage message = messages.get(i);
-                    Long id = message.getId();
-                    ids.add(Long.toString(id));
-                    popMessages.put(id, message);
-                    
-                }
-                
-                cursor = mDb.rawQuery(
-                        "SELECT message_id, name, value "
-                                + "FROM headers " + "WHERE message_id in ( " + questions + ") ",
-                                ids.toArray(new String[] {}));
-                                
-                       
-                while (cursor.moveToNext()) {
-                    Long id = cursor.getLong(0);
-                    String name = cursor.getString(1);
-                    String value = cursor.getString(2);
-                    //Log.i(Email.LOG_TAG, "Retrieved header name= " + name + ", value = " + value + " for message " + id);
-                    popMessages.get(id).addHeader(name, value);
-                }
-            }
-            finally
-            {
-                if (cursor != null) {
-                    cursor.close();
-                }
-            }
-        }
-
-        @Override
-        public Message getMessage(String uid) throws MessagingException {
-            open(OpenMode.READ_WRITE);
-            LocalMessage message = new LocalMessage(uid, this);
-            Cursor cursor = null;
-            try {
-                cursor = mDb.rawQuery(
-                        "SELECT subject, sender_list, date, uid, flags, id, to_list, cc_list, "
-                        + "bcc_list, reply_to_list, attachment_count, internal_date, message_id "
-                                + "FROM messages " + "WHERE uid = ? " + "AND folder_id = ?",
-                        new String[] {
-                                message.getUid(), Long.toString(mFolderId)
-                        });
-                if (!cursor.moveToNext()) {
-                    return null;
-                }
-                populateMessageFromGetMessageCursor(message, cursor);
-                ArrayList<LocalMessage> messages = new ArrayList<LocalMessage>();
-                messages.add(message);
-                populateHeaders(messages);
-            }
-            finally {
-                if (cursor != null) {
-                    cursor.close();
-                }
-            }
-            return message;
-        }
-
-        @Override
-        public Message[] getMessages(MessageRetrievalListener listener) throws MessagingException {
-            open(OpenMode.READ_WRITE);
-            ArrayList<LocalMessage> messages = new ArrayList<LocalMessage>();
-            Cursor cursor = null;
-            try {
-                 // pull out messages most recent first, since that's what the default sort is
-                cursor = mDb.rawQuery(
-                        "SELECT subject, sender_list, date, uid, flags, id, to_list, cc_list, "
-                        + "bcc_list, reply_to_list, attachment_count, internal_date, message_id "
-                                + "FROM messages " + "WHERE folder_id = ? ORDER BY date DESC"
-                                , new String[] {
-                            Long.toString(mFolderId)
-                        });
-
-
-                int i = 0;
-                ArrayList<LocalMessage> messagesForHeaders = new ArrayList<LocalMessage>();
-                while (cursor.moveToNext()) {
-                    LocalMessage message = new LocalMessage(null, this);
-                    populateMessageFromGetMessageCursor(message, cursor);
-                    
-                    messages.add(message);
-                    messagesForHeaders.add(message);
-                    if (messagesForHeaders.size() >= 50)
-                    {
-                        populateHeaders(messagesForHeaders);
-                        messagesForHeaders.clear();
-                    }
-                    if (listener != null) {
-                        listener.messageFinished(message, i, -1);
-                    }
-                    i++;
-                }
-                populateHeaders(messagesForHeaders);
-                
-            }
-            finally {
-                if (cursor != null) {
-                    cursor.close();
-                }
-            }
-
-            return messages.toArray(new Message[] {});
-        }
-
-        @Override
-        public Message[] getMessages(String[] uids, MessageRetrievalListener listener)
-                throws MessagingException {
-            open(OpenMode.READ_WRITE);
-            if (uids == null) {
-                return getMessages(listener);
-            }
-            ArrayList<Message> messages = new ArrayList<Message>();
-            for (String uid : uids) {
-                messages.add(getMessage(uid));
-            }
-            return messages.toArray(new Message[] {});
-        }
-
-        @Override
-        public void copyMessages(Message[] msgs, Folder folder) throws MessagingException {
-            if (!(folder instanceof LocalFolder)) {
-                throw new MessagingException("copyMessages called with incorrect Folder");
-            }
-            ((LocalFolder) folder).appendMessages(msgs, true);
-        }
-        
-        @Override
-        public void moveMessages(Message[] msgs, Folder destFolder) throws MessagingException {
-            if (!(destFolder instanceof LocalFolder)) {
-              throw new MessagingException("copyMessages called with non-LocalFolder");
-            }
-
-            LocalFolder lDestFolder = (LocalFolder)destFolder;
-            lDestFolder.open(OpenMode.READ_WRITE);
-            for (Message message : msgs)
-            {
-              LocalMessage lMessage = (LocalMessage)message;
-                   
-              if (!message.isSet(Flag.SEEN)) {
-                if (getUnreadMessageCount() > 0) {
-                  setUnreadMessageCount(getUnreadMessageCount() - 1);
-                }
-                lDestFolder.setUnreadMessageCount(lDestFolder.getUnreadMessageCount() + 1);
-              }
-              
-              String oldUID = message.getUid();
-  
-              Log.d(Email.LOG_TAG, "Updating folder_id to " + lDestFolder.getId() + " for message with UID "
-                  + message.getUid() + ", id " + lMessage.getId() + " currently in folder " + getName());
-  
-              message.setUid(Email.LOCAL_UID_PREFIX + UUID.randomUUID().toString());          
-              
-              mDb.execSQL("UPDATE messages " + "SET folder_id = ?, uid = ? " + "WHERE id = ?", new Object[] {
-                  lDestFolder.getId(), 
-                  message.getUid(),
-                  lMessage.getId() });
-              
-              LocalMessage placeHolder = new LocalMessage(oldUID, this);
-              placeHolder.setFlagInternal(Flag.DELETED, true);
-              appendMessages(new Message[] { placeHolder });
-            }
-            
-        }
-
-        /**
-         * The method differs slightly from the contract; If an incoming message already has a uid
-         * assigned and it matches the uid of an existing message then this message will replace the
-         * old message. It is implemented as a delete/insert. This functionality is used in saving
-         * of drafts and re-synchronization of updated server messages.
-         */
-        @Override
-        public void appendMessages(Message[] messages) throws MessagingException {
-            appendMessages(messages, false);
-        }
-
-        /**
-         * The method differs slightly from the contract; If an incoming message already has a uid
-         * assigned and it matches the uid of an existing message then this message will replace the
-         * old message. It is implemented as a delete/insert. This functionality is used in saving
-         * of drafts and re-synchronization of updated server messages.
-         */
-        public void appendMessages(Message[] messages, boolean copy) throws MessagingException {
-            open(OpenMode.READ_WRITE);
-            for (Message message : messages) {
-                if (!(message instanceof MimeMessage)) {
-                    throw new Error("LocalStore can only store Messages that extend MimeMessage");
-                }
-
-                String uid = message.getUid();
-                if (uid == null) {
-                    message.setUid(Email.LOCAL_UID_PREFIX + UUID.randomUUID().toString());
-                }
-                else {
-                    /*
-                     * The message may already exist in this Folder, so delete it first.
-                     */
-                    deleteAttachments(message.getUid());
-                    mDb.execSQL("DELETE FROM messages WHERE folder_id = ? AND uid = ?",
-                            new Object[] { mFolderId, message.getUid() });
-                }
-
-                ArrayList<Part> viewables = new ArrayList<Part>();
-                ArrayList<Part> attachments = new ArrayList<Part>();
-                MimeUtility.collectParts(message, viewables, attachments);
-
-                StringBuffer sbHtml = new StringBuffer();
-                StringBuffer sbText = new StringBuffer();
-                for (Part viewable : viewables) {
-                    try {
-                        String text = MimeUtility.getTextFromPart(viewable);
-                        /*
-                         * Anything with MIME type text/html will be stored as such. Anything
-                         * else will be stored as text/plain.
-                         */
-                        if (viewable.getMimeType().equalsIgnoreCase("text/html")) {
-                            sbHtml.append(text);
-                        }
-                        else {
-                            sbText.append(text);
-                        }
-                    } catch (Exception e) {
-                        throw new MessagingException("Unable to get text for message part", e);
-                    }
-                }
-
-                String text = sbText.toString();
-                String html = markupContent(text, sbHtml.toString());
-
-                try {
-                    ContentValues cv = new ContentValues();
-                    cv.put("uid", message.getUid());
-                    cv.put("subject", message.getSubject());
-                    cv.put("sender_list", Address.pack(message.getFrom()));
-                    cv.put("date", message.getSentDate() == null
-                            ? System.currentTimeMillis() : message.getSentDate().getTime());
-                    cv.put("flags", Utility.combine(message.getFlags(), ',').toUpperCase());
-                    cv.put("folder_id", mFolderId);
-                    cv.put("to_list", Address.pack(message.getRecipients(RecipientType.TO)));
-                    cv.put("cc_list", Address.pack(message.getRecipients(RecipientType.CC)));
-                    cv.put("bcc_list", Address.pack(message.getRecipients(RecipientType.BCC)));
-                    cv.put("html_content", html.length() > 0 ? html : null);
-                    cv.put("text_content", text.length() > 0 ? text : null);
-                    cv.put("reply_to_list", Address.pack(message.getReplyTo()));
-                    cv.put("attachment_count", attachments.size());
-                    cv.put("internal_date",  message.getInternalDate() == null
-                            ? System.currentTimeMillis() : message.getInternalDate().getTime());
-                    String[] mHeaders = message.getHeader("Message-ID");
-                    if (mHeaders != null && mHeaders.length > 0)
-                    {
-                    	cv.put("message_id", mHeaders[0]);
-                    }
-                    long messageId = mDb.insert("messages", "uid", cv);
-                    for (Part attachment : attachments) {
-                        saveAttachment(messageId, attachment, copy);
-                    }
-                    saveHeaders(messageId, (MimeMessage)message);
-                } catch (Exception e) {
-                    throw new MessagingException("Error appending message", e);
-                }
-            }
-        }
-
-        /**
-         * Update the given message in the LocalStore without first deleting the existing
-         * message (contrast with appendMessages). This method is used to store changes
-         * to the given message while updating attachments and not removing existing
-         * attachment data.
-         * TODO In the future this method should be combined with appendMessages since the Message
-         * contains enough data to decide what to do.
-         * @param message
-         * @throws MessagingException
-         */
-        public void updateMessage(LocalMessage message) throws MessagingException {
-            open(OpenMode.READ_WRITE);
-            ArrayList<Part> viewables = new ArrayList<Part>();
-            ArrayList<Part> attachments = new ArrayList<Part>();
-            MimeUtility.collectParts(message, viewables, attachments);
-
-            StringBuffer sbHtml = new StringBuffer();
-            StringBuffer sbText = new StringBuffer();
-            for (int i = 0, count = viewables.size(); i < count; i++)  {
-                Part viewable = viewables.get(i);
-                try {
-                    String text = MimeUtility.getTextFromPart(viewable);
-                    /*
-                     * Anything with MIME type text/html will be stored as such. Anything
-                     * else will be stored as text/plain.
-                     */
-                    if (viewable.getMimeType().equalsIgnoreCase("text/html")) {
-                        sbHtml.append(text);
-                    }
-                    else {
-                        sbText.append(text);
-                    }
-                } catch (Exception e) {
-                    throw new MessagingException("Unable to get text for message part", e);
-                }
-            }
-
-            String text = sbText.toString();
-            String html = markupContent(text, sbHtml.toString());
-
-            try {
-                mDb.execSQL("UPDATE messages SET "
-                        + "uid = ?, subject = ?, sender_list = ?, date = ?, flags = ?, "
-                        + "folder_id = ?, to_list = ?, cc_list = ?, bcc_list = ?, "
-                        + "html_content = ?, text_content = ?, reply_to_list = ?, "
-                        + "attachment_count = ? WHERE id = ?",
-                        new Object[] {
-                                message.getUid(),
-                                message.getSubject(),
-                                Address.pack(message.getFrom()),
-                                message.getSentDate() == null ? System
-                                        .currentTimeMillis() : message.getSentDate()
-                                        .getTime(),
-                                Utility.combine(message.getFlags(), ',').toUpperCase(),
-                                mFolderId,
-                                Address.pack(message
-                                        .getRecipients(RecipientType.TO)),
-                                Address.pack(message
-                                        .getRecipients(RecipientType.CC)),
-                                Address.pack(message
-                                        .getRecipients(RecipientType.BCC)),
-                                html.length() > 0 ? html : null,
-                                text.length() > 0 ? text : null,
-                                Address.pack(message.getReplyTo()),
-                                attachments.size(),
-                                message.mId
-                                });
-
-                for (int i = 0, count = attachments.size(); i < count; i++) {
-                    Part attachment = attachments.get(i);
-                    saveAttachment(message.mId, attachment, false);
-                }
-                saveHeaders(message.getId(), message);
-            } catch (Exception e) {
-                throw new MessagingException("Error appending message", e);
-            }
-        }
-
-        private void saveHeaders(long id, MimeMessage message)
-        {
-            deleteHeaders(id);
-            for (String name : message.getHeaderNames())
-            {
-                if (HEADERS_TO_SAVE.contains(name))
-                {
-                    String[] values = message.getHeader(name);
-                    for (String value : values)
-                    {
-                        ContentValues cv = new ContentValues();
-                        cv.put("message_id", id);
-                        cv.put("name", name);
-                        cv.put("value", value);
-                        //Log.i(Email.LOG_TAG, "Saving header name = " + name + ", value = " + value);
-                        mDb.insert("headers", "name", cv);
-                    }
-                }
-            }
-        }
-        
-        private void deleteHeaders(long id)
-        {
-            mDb.execSQL("DELETE FROM headers WHERE id = ?",
-                    new Object[] {
-                            id
-                    });
-        }
-
-        /**
-         * @param messageId
-         * @param attachment
-         * @param attachmentId -1 to create a new attachment or >= 0 to update an existing
-         * @throws IOException
-         * @throws MessagingException
-         */
-        private void saveAttachment(long messageId, Part attachment, boolean saveAsNew)
-                throws IOException, MessagingException {
-            long attachmentId = -1;
-            Uri contentUri = null;
-            int size = -1;
-            File tempAttachmentFile = null;
-
-            if ((!saveAsNew) && (attachment instanceof LocalAttachmentBodyPart)) {
-                attachmentId = ((LocalAttachmentBodyPart) attachment).getAttachmentId();
-            }
-
-            if (attachment.getBody() != null) {
-                Body body = attachment.getBody();
-                if (body instanceof LocalAttachmentBody) {
-                    contentUri = ((LocalAttachmentBody) body).getContentUri();
-                }
-                else {
-                    /*
-                     * If the attachment has a body we're expected to save it into the local store
-                     * so we copy the data into a cached attachment file.
-                     */
-                    InputStream in = attachment.getBody().getInputStream();
-                    tempAttachmentFile = File.createTempFile("att", null, mAttachmentsDir);
-                    FileOutputStream out = new FileOutputStream(tempAttachmentFile);
-                    size = IOUtils.copy(in, out);
-                    in.close();
-                    out.close();
-                }
-            }
-
-            if (size == -1) {
-                /*
-                 * If the attachment is not yet downloaded see if we can pull a size
-                 * off the Content-Disposition.
-                 */
-                String disposition = attachment.getDisposition();
-                if (disposition != null) {
-                    String s = MimeUtility.getHeaderParameter(disposition, "size");
-                    if (s != null) {
-                        size = Integer.parseInt(s);
-                    }
-                }
-            }
-            if (size == -1) {
-                size = 0;
-            }
-
-            String storeData =
-                Utility.combine(attachment.getHeader(
-                        MimeHeader.HEADER_ANDROID_ATTACHMENT_STORE_DATA), ',');
-
-            String name = MimeUtility.getHeaderParameter(attachment.getContentType(), "name");
-            String contentDisposition = MimeUtility.unfoldAndDecode(attachment.getDisposition());
-            if (name == null && contentDisposition != null)
-            {
-              name = MimeUtility.getHeaderParameter(contentDisposition, "filename");
-            }
-            if (attachmentId == -1) {
-                ContentValues cv = new ContentValues();
-                cv.put("message_id", messageId);
-                cv.put("content_uri", contentUri != null ? contentUri.toString() : null);
-                cv.put("store_data", storeData);
-                cv.put("size", size);
-                cv.put("name", name);
-                cv.put("mime_type", attachment.getMimeType());
-
-                attachmentId = mDb.insert("attachments", "message_id", cv);
-            }
-            else {
-                ContentValues cv = new ContentValues();
-                cv.put("content_uri", contentUri != null ? contentUri.toString() : null);
-                cv.put("size", size);
-                mDb.update(
-                        "attachments",
-                        cv,
-                        "id = ?",
-                        new String[] { Long.toString(attachmentId) });
-            }
-
-            if (tempAttachmentFile != null) {
-                File attachmentFile = new File(mAttachmentsDir, Long.toString(attachmentId));
-                tempAttachmentFile.renameTo(attachmentFile);
-                contentUri = AttachmentProvider.getAttachmentUri(
-                        new File(mPath).getName(),
-                        attachmentId);
-                attachment.setBody(new LocalAttachmentBody(contentUri, mApplication));
-                ContentValues cv = new ContentValues();
-                cv.put("content_uri", contentUri != null ? contentUri.toString() : null);
-                mDb.update(
-                        "attachments",
-                        cv,
-                        "id = ?",
-                        new String[] { Long.toString(attachmentId) });
-            }
-
-            if (attachment instanceof LocalAttachmentBodyPart) {
-                ((LocalAttachmentBodyPart) attachment).setAttachmentId(attachmentId);
-            }
-        }
-
-        /**
-         * Changes the stored uid of the given message (using it's internal id as a key) to
-         * the uid in the message.
-         * @param message
-         */
-        public void changeUid(LocalMessage message) throws MessagingException {
-            open(OpenMode.READ_WRITE);
-            ContentValues cv = new ContentValues();
-            cv.put("uid", message.getUid());
-            mDb.update("messages", cv, "id = ?", new String[] { Long.toString(message.mId) });
-        }
-
-        @Override
-        public void setFlags(Message[] messages, Flag[] flags, boolean value)
-                throws MessagingException {
-            open(OpenMode.READ_WRITE);
-            for (Message message : messages) {
-                message.setFlags(flags, value);
-            }
-        }
-        
-        @Override
-        public void setFlags(Flag[] flags, boolean value)
-                throws MessagingException {
-            open(OpenMode.READ_WRITE);
-            for (Message message : getMessages(null)) {
-                message.setFlags(flags, value);
-            }
-        }
-
-        @Override
-        public String getUidFromMessageId(Message message) throws MessagingException
-        {
-        	throw new MessagingException("Cannot call getUidFromMessageId on LocalFolder");
-        }
-        @Override
-        public Message[] expunge() throws MessagingException {
-            open(OpenMode.READ_WRITE);
-            ArrayList<Message> expungedMessages = new ArrayList<Message>();
-            /*
-             * epunge() doesn't do anything because deleted messages are saved for their uids
-             * and really, really deleted messages are "Destroyed" and removed immediately.
-             */
-            return expungedMessages.toArray(new Message[] {});
-        }
-        
-        public void deleteMessagesOlderThan(long cutoff) throws MessagingException
-        {
-        	open(OpenMode.READ_ONLY);
-        	mDb.execSQL("DELETE FROM messages WHERE folder_id = ? and date < ?", new Object[] {
-              Long.toString(mFolderId), new Long(cutoff) } );	
-        }
-
-        @Override
-        public void delete(boolean recurse) throws MessagingException {
-            // We need to open the folder first to make sure we've got it's id
-            open(OpenMode.READ_ONLY);
-            Message[] messages = getMessages(null);
-            for (Message message : messages) {
-                deleteAttachments(message.getUid());
-            }
-            mDb.execSQL("DELETE FROM folders WHERE id = ?", new Object[] {
-                Long.toString(mFolderId),
-            });
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (o instanceof LocalFolder) {
-                return ((LocalFolder)o).mName.equals(mName);
-            }
-            return super.equals(o);
-        }
-
-        @Override
-        public Flag[] getPermanentFlags() throws MessagingException {
-            return PERMANENT_FLAGS;
-        }
-
-        private void deleteAttachments(String uid) throws MessagingException {
-            open(OpenMode.READ_WRITE);
-            Cursor messagesCursor = null;
-            try {
-                messagesCursor = mDb.query(
-                        "messages",
-                        new String[] { "id" },
-                        "folder_id = ? AND uid = ?",
-                        new String[] { Long.toString(mFolderId), uid },
-                        null,
-                        null,
-                        null);
-                while (messagesCursor.moveToNext()) {
-                    long messageId = messagesCursor.getLong(0);
-                    Cursor attachmentsCursor = null;
-                    try {
-                        attachmentsCursor = mDb.query(
-                                "attachments",
-                                new String[] { "id" },
-                                "message_id = ?",
-                                new String[] { Long.toString(messageId) },
-                                null,
-                                null,
-                                null);
-                        while (attachmentsCursor.moveToNext()) {
-                            long attachmentId = attachmentsCursor.getLong(0);
-                            try{
-                                File file = new File(mAttachmentsDir, Long.toString(attachmentId));
-                                if (file.exists()) {
-                                    file.delete();
-                                }
-                            }
-                            catch (Exception e) {
-
-                            }
-                        }
-                    }
-                    finally {
-                        if (attachmentsCursor != null) {
-                            attachmentsCursor.close();
-                        }
-                    }
-                }
-            }
-            finally {
-                if (messagesCursor != null) {
-                    messagesCursor.close();
-                }
-            }
-        }
-        
-
-        public String markupContent(String text, String html) {
-            if (text.length() > 0 && html.length() == 0) {
-                html = htmlifyString(text);
-            }
-
-            if (html.indexOf("cid:") != -1) {
-                return html.replaceAll("cid:", "http://cid/");
-            }
-            else {
-                return html;
-            }
-        }
-        
-        public String htmlifyString(String text) {
-            StringReader reader = new StringReader(text);
-            StringBuilder buff = new StringBuilder(text.length() + 512);
-            int c = 0;
-            try {
-                while ((c = reader.read()) != -1) {
-                    switch (c) {
-                        case '&':
-                            buff.append("&amp;");
-                            break;
-                        case '<':
-                            buff.append("&lt;");
-                            break;
-                        case '>':
-                            buff.append("&gt;");
-                            break;
-                        case '\r':
-                            break;
-                        default:
-                            buff.append((char)c);
-                    }//switch
-                }
-            } catch (IOException e) {
-                //Should never happen
-                Log.e(Email.LOG_TAG, null, e);
-            }
-            text = buff.toString();
-
-            Matcher m = Regex.WEB_URL_PATTERN.matcher(text);
-            StringBuffer sb = new StringBuffer(text.length() + 512);
-            sb.append("<html><body><pre style=\"white-space: pre-wrap;\">");
-            while (m.find()) {
-                int start = m.start();
-                if (start == 0 || (start != 0 && text.charAt(start - 1) != '@')) {
-                    m.appendReplacement(sb, "<a href=\"$0\">$0</a>");
-                } else {
-                    m.appendReplacement(sb, "$0");
-                }
-            }
-            m.appendTail(sb);
-            sb.append("</pre></body></html>");
-            text = sb.toString();
-
-            return text;
-        }
-    }
-
-    public class LocalTextBody extends TextBody {
-        private String mBodyForDisplay;
-
-        public LocalTextBody(String body) {
-            super(body);
-        }
-
-        public LocalTextBody(String body, String bodyForDisplay) throws MessagingException {
-            super(body);
-            this.mBodyForDisplay = bodyForDisplay;
-        }
-
-        public String getBodyForDisplay() {
-            return mBodyForDisplay;
-        }
-
-        public void setBodyForDisplay(String mBodyForDisplay) {
-            this.mBodyForDisplay = mBodyForDisplay;
-        }
-
-    }//LocalTextBody
-
-    public class LocalMessage extends MimeMessage {
-        private long mId;
-        private int mAttachmentCount;
-    
-        public LocalMessage() {
-        }
-
-        LocalMessage(String uid, Folder folder) throws MessagingException {
-            this.mUid = uid;
-            this.mFolder = folder;
-        }
-   
-        public int getAttachmentCount() {
-            return mAttachmentCount;
-        }
-
-        public void parse(InputStream in) throws IOException, MessagingException {
-            super.parse(in);
-        }
-
-    public void setFrom(Address from) throws MessagingException {
-        if (from != null) {
-            addHeader("From", from.toString());
-            this.mFrom = new Address[] {
-                    from
-                };
-        } else {
-            this.mFrom = null;
-        }
-    }
-
-    /*
-     * For performance reasons, we add headers instead of setting them (see super implementation)
-     * which removes (expensive) them before adding them
-     */
-    @Override
-    public void setRecipients(RecipientType type, Address[] addresses) throws MessagingException {
-        if (type == RecipientType.TO) {
-            if (addresses == null || addresses.length == 0) {
-                removeHeader("To");
-                this.mTo = null;
-            } else {
-                addHeader("To", Address.toString(addresses));
-                this.mTo = addresses;
-            }
-        } else if (type == RecipientType.CC) {
-            if (addresses == null || addresses.length == 0) {
-                removeHeader("CC");
-                this.mCc = null;
-            } else {
-                addHeader("CC", Address.toString(addresses));
-                this.mCc = addresses;
-            }
-        } else if (type == RecipientType.BCC) {
-            if (addresses == null || addresses.length == 0) {
-                removeHeader("BCC");
-                this.mBcc = null;
-            } else {
-                addHeader("BCC", Address.toString(addresses));
-                this.mBcc = addresses;
-            }
-        } else {
-            throw new MessagingException("Unrecognized recipient type.");
-        }
-    }
-
-        public void setFlagInternal(Flag flag, boolean set) throws MessagingException {
-            super.setFlag(flag, set);
-        }
-
-        public long getId() {
-            return mId;
-        }
-
-        public void setFlag(Flag flag, boolean set) throws MessagingException {
-            if (flag == Flag.DELETED && set) {
-                /*
-                 * If a message is being marked as deleted we want to clear out it's content
-                 * and attachments as well. Delete will not actually remove the row since we need
-                 * to retain the uid for synchronization purposes.
-                 */
-
-                /*
-                 * Delete all of the messages' content to save space.
-                 */
-              ((LocalFolder) mFolder).deleteAttachments(getUid());
-
-              mDb.execSQL(
-                        "UPDATE messages SET " +
-                        "subject = NULL, " +
-                        "sender_list = NULL, " +
-                        "date = NULL, " +
-                        "to_list = NULL, " +
-                        "cc_list = NULL, " +
-                        "bcc_list = NULL, " +
-                        "html_content = NULL, " +
-                        "text_content = NULL, " +
-                        "reply_to_list = NULL " +
-                        "WHERE id = ?",
-                        new Object[] {
-                                mId
-                        });
- 
-                /*
-                 * Delete all of the messages' attachments to save space.
-                 */
-                mDb.execSQL("DELETE FROM attachments WHERE id = ?",
-                        new Object[] {
-                                mId
-                        });
-                
-                ((LocalFolder)mFolder).deleteHeaders(mId);
-
-            }
-            else if (flag == Flag.X_DESTROYED && set) {
-                ((LocalFolder) mFolder).deleteAttachments(getUid());
-                mDb.execSQL("DELETE FROM messages WHERE id = ?",
-                        new Object[] { mId });
-                ((LocalFolder)mFolder).deleteHeaders(mId);
-            }
-
-            /*
-             * Update the unread count on the folder.
-             */
-            try {
-                if (flag == Flag.DELETED || flag == Flag.X_DESTROYED || flag == Flag.SEEN) {
-                    LocalFolder folder = (LocalFolder)mFolder;
-                    if (set && !isSet(Flag.SEEN)) {
-                        folder.setUnreadMessageCount(folder.getUnreadMessageCount() - 1);
-                    }
-                    else if (!set && isSet(Flag.SEEN)) {
-                        folder.setUnreadMessageCount(folder.getUnreadMessageCount() + 1);
-                    }
-                }
-            }
-            catch (MessagingException me) {
-                Log.e(Email.LOG_TAG, "Unable to update LocalStore unread message count",
-                        me);
-                throw new RuntimeException(me);
-            }
-
-            super.setFlag(flag, set);
-            /*
-             * Set the flags on the message.
-             */
-            mDb.execSQL("UPDATE messages " + "SET flags = ? " + "WHERE id = ?", new Object[] {
-                    Utility.combine(getFlags(), ',').toUpperCase(), mId
-            });
-        }
-    }
-
-    public class LocalAttachmentBodyPart extends MimeBodyPart {
-        private long mAttachmentId = -1;
-
-        public LocalAttachmentBodyPart(Body body, long attachmentId) throws MessagingException {
-            super(body);
-            mAttachmentId = attachmentId;
-        }
-
-        /**
-         * Returns the local attachment id of this body, or -1 if it is not stored.
-         * @return
-         */
-        public long getAttachmentId() {
-            return mAttachmentId;
-        }
-
-        public void setAttachmentId(long attachmentId) {
-            mAttachmentId = attachmentId;
-        }
-
-        public String toString() {
-            return "" + mAttachmentId;
-        }
-    }
-
-    public static class LocalAttachmentBody implements Body {
-        private Application mApplication;
-        private Uri mUri;
-
-        public LocalAttachmentBody(Uri uri, Application application) {
-            mApplication = application;
-            mUri = uri;
-        }
-
-        public InputStream getInputStream() throws MessagingException {
-            try {
-                return mApplication.getContentResolver().openInputStream(mUri);
-            }
-            catch (FileNotFoundException fnfe) {
-                /*
-                 * Since it's completely normal for us to try to serve up attachments that
-                 * have been blown away, we just return an empty stream.
-                 */
-                return new ByteArrayInputStream(new byte[0]);
-            }
-            catch (IOException ioe) {
-                throw new MessagingException("Invalid attachment.", ioe);
-            }
-        }
-
-        public void writeTo(OutputStream out) throws IOException, MessagingException {
-            InputStream in = getInputStream();
-            Base64OutputStream base64Out = new Base64OutputStream(out);
-            IOUtils.copy(in, base64Out);
-            base64Out.close();
-        }
-
-        public Uri getContentUri() {
-            return mUri;
-        }
-    }
-}
Index: src/com/android/email/activity/setup/AccountSetupComposition.java
===================================================================
--- src/com/android/email/activity/setup/AccountSetupComposition.java	(revision 718)
+++ src/com/android/email/activity/setup/AccountSetupComposition.java	(working copy)
@@ -1,109 +0,0 @@
-package com.android.email.activity.setup;
-import android.app.Activity;
-import com.android.email.K9Activity;
-import android.content.Intent;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.KeyEvent;
-import android.widget.EditText;
-
-import android.widget.RadioButton;
-import com.android.email.Account;
-import com.android.email.Email;
-import com.android.email.Preferences;
-import com.android.email.R;
-
-public class AccountSetupComposition extends K9Activity {
-
-    private static final String EXTRA_ACCOUNT = "account";
-
-    private Account mAccount;
-
-    private EditText mAccountSignature;
-    private EditText mAccountEmail;
-    private EditText mAccountAlwaysBcc;
-    private EditText mAccountName;
-    private RadioButton mAccountSignatureBeforeLocation;
-    private RadioButton mAccountSignatureAfterLocation;
-    
-
-    public static void actionEditCompositionSettings(Activity context, Account account) {
-        Intent i = new Intent(context, AccountSetupComposition.class);
-        i.setAction(Intent.ACTION_EDIT);
-        i.putExtra(EXTRA_ACCOUNT, account);
-        context.startActivity(i);
-    }
-
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        mAccount = (Account)getIntent().getSerializableExtra(EXTRA_ACCOUNT);
-
-        setContentView(R.layout.account_setup_composition);
-
-        /*
-         * If we're being reloaded we override the original account with the one
-         * we saved
-         */
-        if (savedInstanceState != null && savedInstanceState.containsKey(EXTRA_ACCOUNT)) {
-            mAccount = (Account)savedInstanceState.getSerializable(EXTRA_ACCOUNT);
-        }
-
-        mAccountName = (EditText)findViewById(R.id.account_name);
-        mAccountName.setText(mAccount.getName());
-        
-        mAccountEmail = (EditText)findViewById(R.id.account_email);
-        mAccountEmail.setText(mAccount.getEmail());
-
-        mAccountAlwaysBcc = (EditText)findViewById(R.id.account_always_bcc);
-        mAccountAlwaysBcc.setText(mAccount.getAlwaysBcc());
-
-        mAccountSignature = (EditText)findViewById(R.id.account_signature);
-        mAccountSignature.setText(mAccount.getSignature());
-
-        mAccountSignatureBeforeLocation = (RadioButton)findViewById(R.id.account_signature_location_before_quoted_text);
-        mAccountSignatureAfterLocation = (RadioButton)findViewById(R.id.account_signature_location_after_quoted_text);
-        boolean isSignatureBeforeQuotedText = mAccount.isSignatureBeforeQuotedText();
-        mAccountSignatureBeforeLocation.setChecked(isSignatureBeforeQuotedText);
-        mAccountSignatureAfterLocation.setChecked(!isSignatureBeforeQuotedText);
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        mAccount.refresh(Preferences.getPreferences(this));
-    }
-
-    private void saveSettings() {
-        mAccount.setEmail(mAccountEmail.getText().toString());
-        mAccount.setAlwaysBcc(mAccountAlwaysBcc.getText().toString()); 
-        mAccount.setName(mAccountName.getText().toString());
-        mAccount.setSignature(mAccountSignature.getText().toString());
-        boolean isSignatureBeforeQuotedText = mAccountSignatureBeforeLocation.isChecked();
-        mAccount.setSignatureBeforeQuotedText(isSignatureBeforeQuotedText);
-
-        mAccount.save(Preferences.getPreferences(this));
-    }
-
-    @Override
-    public boolean onKeyDown(int keyCode, KeyEvent event) {
-        if (keyCode == KeyEvent.KEYCODE_BACK) {
-            saveSettings();
-        }
-        return super.onKeyDown(keyCode, event);
-    }
-
-    @Override
-    public void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        outState.putSerializable(EXTRA_ACCOUNT, mAccount);
-    }
-
-    @Override
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
-                mAccount.save(Preferences.getPreferences(this));
-                finish();
-    }
-}
Index: src/com/android/email/activity/setup/Prefs.java
===================================================================
--- src/com/android/email/activity/setup/Prefs.java	(revision 718)
+++ src/com/android/email/activity/setup/Prefs.java	(working copy)
@@ -1,79 +0,0 @@
-package com.android.email.activity.setup;
-
-import android.content.Context;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.os.Bundle;
-import android.view.KeyEvent;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.widget.Button;
-import android.preference.EditTextPreference;
-import android.preference.ListPreference;
-import android.preference.CheckBoxPreference;
-import android.preference.Preference;
-import android.preference.PreferenceScreen;
-import android.preference.RingtonePreference;
-import android.preference.Preference.OnPreferenceClickListener;
-
-import com.android.email.K9PreferenceActivity;
-import com.android.email.Account;
-import com.android.email.Email;
-import com.android.email.Preferences;
-import com.android.email.R;
-
-public class Prefs extends K9PreferenceActivity {
-
-    private static final String PREFERENCE_TOP_CATERGORY = "preferences";
-    private static final String PREFERENCE_THEME = "theme";
-
-    private ListPreference mTheme;
-
-    public static void actionPrefs(Context context) {
-        Intent i = new Intent(context, Prefs.class);
-        context.startActivity(i);
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-
-        addPreferencesFromResource(R.xml.global_preferences);
-
-        Preference category = findPreference(PREFERENCE_TOP_CATERGORY);
-
-
-        mTheme = (ListPreference) findPreference(PREFERENCE_THEME);
-        mTheme.setValue(String.valueOf(Preferences.getPreferences(this).getTheme() == android.R.style.Theme ? "dark" : "light"));
-        mTheme.setSummary(mTheme.getEntry());
-        mTheme.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
-            public boolean onPreferenceChange(Preference preference, Object newValue) {
-                final String summary = newValue.toString();
-                int index = mTheme.findIndexOfValue(summary);
-                mTheme.setSummary(mTheme.getEntries()[index]);
-                mTheme.setValue(summary);
-                return false;
-            }
-        });
-        
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-    }
-
-    private void saveSettings() {
-        Preferences.getPreferences(this).setTheme(mTheme.getValue().equals("dark") ? android.R.style.Theme : android.R.style.Theme_Light);
-    }
-    
-    @Override
-    public boolean onKeyDown(int keyCode, KeyEvent event) {
-        if (keyCode == KeyEvent.KEYCODE_BACK) {
-            saveSettings();
-        }
-        return super.onKeyDown(keyCode, event);
-    }
-
-}
Index: src/com/android/email/mail/transport/WebDavTransport.java
===================================================================
--- src/com/android/email/mail/transport/WebDavTransport.java	(revision 718)
+++ src/com/android/email/mail/transport/WebDavTransport.java	(working copy)
@@ -1,183 +0,0 @@
-
-package com.android.email.mail.transport;
-
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.UnsupportedEncodingException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.net.SocketAddress;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URLEncoder;
-import java.security.GeneralSecurityException;
-import java.security.KeyManagementException;
-import java.security.NoSuchAlgorithmException;
-import java.security.SecureRandom;
-
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.SSLException;
-import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.SAXParserFactory;
-
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.client.CookieStore;
-import org.apache.http.entity.StringEntity;
-import org.apache.http.impl.client.DefaultHttpClient;
-import org.xml.sax.InputSource;
-import org.xml.sax.SAXException;
-import org.xml.sax.XMLReader;
-
-import android.util.Config;
-import android.util.Log;
-
-import com.android.email.Email;
-import com.android.email.PeekableInputStream;
-import com.android.email.codec.binary.Base64;
-import com.android.email.mail.Address;
-import com.android.email.mail.AuthenticationFailedException;
-import com.android.email.mail.Folder;
-import com.android.email.mail.Message;
-import com.android.email.mail.MessagingException;
-import com.android.email.mail.Transport;
-import com.android.email.mail.CertificateValidationException;
-import com.android.email.mail.Message.RecipientType;
-import com.android.email.mail.store.TrustManagerFactory;
-import com.android.email.mail.store.WebDavStore;
-import com.android.email.mail.store.WebDavStore.HttpGeneric;
-import com.android.email.mail.store.WebDavStore.DataSet;
-import com.android.email.mail.store.WebDavStore.WebDavHandler;
-
-public class WebDavTransport extends Transport {
-    public static final int CONNECTION_SECURITY_NONE = 0;
-    public static final int CONNECTION_SECURITY_TLS_OPTIONAL = 1;
-    public static final int CONNECTION_SECURITY_TLS_REQUIRED = 2;
-    public static final int CONNECTION_SECURITY_SSL_REQUIRED = 3;
-    public static final int CONNECTION_SECURITY_SSL_OPTIONAL = 4;
-
-    String host;
-    int mPort;
-    private int mConnectionSecurity;
-    private String mUsername; /* Stores the username for authentications */
-    private String mPassword; /* Stores the password for authentications */
-    private String mUrl;      /* Stores the base URL for the server */
-
-    boolean mSecure;
-    Socket mSocket;
-    PeekableInputStream mIn;
-    OutputStream mOut;
-	private WebDavStore store;
-
-    /**
-     * webdav://user:password@server:port CONNECTION_SECURITY_NONE
-     * webdav+tls://user:password@server:port CONNECTION_SECURITY_TLS_OPTIONAL
-     * webdav+tls+://user:password@server:port CONNECTION_SECURITY_TLS_REQUIRED
-     * webdav+ssl+://user:password@server:port CONNECTION_SECURITY_SSL_REQUIRED
-     * webdav+ssl://user:password@server:port CONNECTION_SECURITY_SSL_OPTIONAL
-     *
-     * @param _uri
-     */
-    public WebDavTransport(String _uri) throws MessagingException {
-    	store = new WebDavStore(_uri);
-        Log.d(Email.LOG_TAG, ">>> New WebDavTransport creation complete");
-    }
-
-    public void open() throws MessagingException {
-        Log.d(Email.LOG_TAG, ">>> open called on WebDavTransport ");
-        store.getHttpClient();
-    }
-
-//    public void sendMessage(Message message) throws MessagingException {
-//        Address[] from = message.getFrom();
-//        
-//    }
-    
-    public void close() {
-    }
-    
-    public String generateTempURI(String subject) {
-    	String encodedSubject = URLEncoder.encode(subject);
-    	return store.getUrl()  + "/drafts/" + encodedSubject + ".eml";
-    }
-    public String generateSendURI() {
-    	return store.getUrl() +  "/##DavMailSubmissionURI##/";
-    }
-    
-    public void sendMessage(Message message) throws MessagingException {
-        Log.d(Email.LOG_TAG, ">>> sendMessage called.");
-
-        DefaultHttpClient httpclient;
-        httpclient = store.getHttpClient();
-        HttpGeneric httpmethod;
-        HttpResponse response;
-        StringEntity bodyEntity;
-        int statusCode;
-        String subject;
-        ByteArrayOutputStream out;
-        try {
-        	try {
-        		subject = message.getSubject();
-        	} catch (MessagingException e) {
-        		Log.e(Email.LOG_TAG, "MessagingException while retrieving Subject: " + e);
-        		subject = "";
-        	}
-        	try {
-        		out = new ByteArrayOutputStream(message.getSize());
-        	} catch (MessagingException e) {
-        		Log.e(Email.LOG_TAG, "MessagingException while getting size of message: " + e);
-        		out = new ByteArrayOutputStream();
-        	}
-        	open();
-        	message.writeTo(
-        			new EOLConvertingOutputStream(
-        					new BufferedOutputStream(out, 1024)));
-
-        	bodyEntity = new StringEntity(out.toString(), "UTF-8");
-        	bodyEntity.setContentType("message/rfc822");
-
-        	httpmethod = store.new HttpGeneric(generateTempURI(subject));
-        	httpmethod.setMethod("PUT");
-        	httpmethod.setEntity(bodyEntity);
-
-        	response = httpclient.execute(httpmethod);
-        	statusCode = response.getStatusLine().getStatusCode();
-
-        	if (statusCode < 200 ||
-        			statusCode > 300) {
-    			throw new IOException("Sending Message: Error while trying to upload to drafts folder: "+
-    					response.getStatusLine().toString()+ "\n\n"+
-    					WebDavStore.getHttpRequestResponse(bodyEntity, response.getEntity()));
-        	}
-        	
-            httpmethod = store.new HttpGeneric(generateTempURI(subject));
-        	httpmethod.setMethod("MOVE");
-        	httpmethod.setHeader("Destination", generateSendURI());
-
-        	response = httpclient.execute(httpmethod);
-        	statusCode = response.getStatusLine().getStatusCode();
-
-        	if (statusCode < 200 ||
-        			statusCode > 300) {
-    			throw new IOException("Sending Message: Error while trying to move finished draft to Outbox: "+
-    					response.getStatusLine().toString()+ "\n\n"+
-    					WebDavStore.getHttpRequestResponse(null, response.getEntity()));
-        	}
-
-        } catch (UnsupportedEncodingException uee) {
-        	Log.e(Email.LOG_TAG, "UnsupportedEncodingException in sendMessage() " + uee);
-        } catch (IOException ioe) {
-        	Log.e(Email.LOG_TAG, "IOException in sendMessage() " + ioe);
-        	throw new MessagingException("Unable to send message"+ioe.getMessage(), ioe);
-        }
-        Log.d(Email.LOG_TAG, ">>> getMessageCount finished");
-    }
-
-}
Index: src/com/android/email/activity/setup/FolderSettings.java
===================================================================
--- src/com/android/email/activity/setup/FolderSettings.java	(revision 718)
+++ src/com/android/email/activity/setup/FolderSettings.java	(working copy)
@@ -1,136 +0,0 @@
-
-package com.android.email.activity.setup;
-
-import android.content.Context;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.KeyEvent;
-import com.android.email.K9PreferenceActivity;
-import android.preference.EditTextPreference;
-import android.preference.ListPreference;
-import android.preference.CheckBoxPreference;
-import android.preference.Preference;
-import android.preference.RingtonePreference;
-
-import com.android.email.Account;
-import com.android.email.Email;
-import com.android.email.Preferences;
-import com.android.email.R;
-import com.android.email.mail.Folder;
-import com.android.email.mail.MessagingException;
-import com.android.email.mail.Store;
-import com.android.email.mail.Folder.FolderClass;
-import com.android.email.mail.store.LocalStore.LocalFolder;
-
-public class FolderSettings extends K9PreferenceActivity {
-	
-    private static final String EXTRA_FOLDER_NAME = "com.android.email.folderName";
-    private static final String EXTRA_ACCOUNT = "com.android.email.account";
-    
-    private static final String PREFERENCE_TOP_CATERGORY = "folder_settings";
-    private static final String PREFERENCE_DISPLAY_CLASS = "folder_settings_folder_display_mode";
-    private static final String PREFERENCE_SYNC_CLASS = "folder_settings_folder_sync_mode";
-
-    private LocalFolder mFolder;
-    
-    private ListPreference mDisplayClass;
-    private ListPreference mSyncClass;
-
-    public static void actionSettings(Context context, Account account, String folderName) {
-        Intent i = new Intent(context, FolderSettings.class);
-        i.putExtra(EXTRA_FOLDER_NAME, folderName);
-        i.putExtra(EXTRA_ACCOUNT, account);
-        context.startActivity(i);
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        String folderName = (String)getIntent().getSerializableExtra(EXTRA_FOLDER_NAME);
-        Account mAccount = (Account)getIntent().getSerializableExtra(EXTRA_ACCOUNT);
-        
-				try
-				{
-					Store localStore = Store.getInstance(mAccount.getLocalStoreUri(),
-							getApplication());
-					mFolder = (LocalFolder) localStore.getFolder(folderName);
-					mFolder.refresh(Preferences.getPreferences(this));
-				}
-				catch (MessagingException me)
-				{
-					Log.e(Email.LOG_TAG, "Unable to edit folder " + folderName + " preferences", me);
-					return;
-				}
-
-        addPreferencesFromResource(R.xml.folder_settings_preferences);
-
-        Preference category = findPreference(PREFERENCE_TOP_CATERGORY);
-        category.setTitle(folderName);
-       
-        mDisplayClass = (ListPreference) findPreference(PREFERENCE_DISPLAY_CLASS);
-        mDisplayClass.setValue(mFolder.getDisplayClass().name());
-        mDisplayClass.setSummary(mDisplayClass.getEntry());
-        mDisplayClass.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
-            public boolean onPreferenceChange(Preference preference, Object newValue) {
-                final String summary = newValue.toString();
-                int index = mDisplayClass.findIndexOfValue(summary);
-                mDisplayClass.setSummary(mDisplayClass.getEntries()[index]);
-                mDisplayClass.setValue(summary);
-                return false;
-            }
-        });
-
-        mSyncClass = (ListPreference) findPreference(PREFERENCE_SYNC_CLASS);
-        mSyncClass.setValue(mFolder.getRawSyncClass().name());
-        mSyncClass.setSummary(mSyncClass.getEntry());
-        mSyncClass.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
-            public boolean onPreferenceChange(Preference preference, Object newValue) {
-                final String summary = newValue.toString();
-                int index = mSyncClass.findIndexOfValue(summary);
-                mSyncClass.setSummary(mSyncClass.getEntries()[index]);
-                mSyncClass.setValue(summary);
-                return false;
-            }
-        });
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        try
-        {
-        	mFolder.refresh(Preferences.getPreferences(this));
-        }
-        catch (MessagingException me)
-        {
-        	Log.e(Email.LOG_TAG, "Could not refresh folder preferences for folder " + mFolder.getName(), me);
-        }
-    }
-
-    private void saveSettings() {
-    	mFolder.setDisplayClass(FolderClass.valueOf(mDisplayClass.getValue()));
-     	mFolder.setSyncClass(FolderClass.valueOf(mSyncClass.getValue()));
-        	
-     	try
-     	{
-     		mFolder.save(Preferences.getPreferences(this));
-     	}
-      catch (MessagingException me)
-      {
-      	Log.e(Email.LOG_TAG, "Could not refresh folder preferences for folder " + mFolder.getName(), me);
-      }
-    }
-
-    @Override
-    public boolean onKeyDown(int keyCode, KeyEvent event) {
-        if (keyCode == KeyEvent.KEYCODE_BACK) {
-            saveSettings();
-        }
-        return super.onKeyDown(keyCode, event);
-    }
-
- 
-}
Index: src/com/android/email/activity/MessageList.java
===================================================================
--- src/com/android/email/activity/MessageList.java	(revision 718)
+++ src/com/android/email/activity/MessageList.java	(working copy)
@@ -1,1763 +0,0 @@
-package com.android.email.activity;
-//import android.os.Debug;
-import java.text.DateFormat;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Date;
-import java.util.Iterator;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import android.app.AlertDialog;
-import android.app.Dialog;
-import android.app.NotificationManager;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.graphics.Typeface;
-import android.graphics.drawable.Drawable;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Process;
-import android.util.Config;
-import android.util.Log;
-import android.view.ContextMenu;
-import android.view.KeyEvent;
-import android.view.LayoutInflater;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.Window;
-import android.view.ContextMenu.ContextMenuInfo;
-import android.widget.BaseAdapter;
-import android.widget.ListView;
-import android.widget.AdapterView;
-import android.widget.ProgressBar;
-import android.widget.TextView;
-import android.widget.Toast;
-import android.widget.AdapterView.AdapterContextMenuInfo;
-import android.widget.AdapterView.OnItemClickListener;
-
-import com.android.email.K9ListActivity;
-import com.android.email.Account;
-import com.android.email.Email;
-import com.android.email.MessagingController;
-import com.android.email.MessagingListener;
-import com.android.email.R;
-import com.android.email.Utility;
-import com.android.email.MessagingController.SORT_TYPE;
-import com.android.email.activity.MessageList.MessageInfoHolder;
-import com.android.email.activity.setup.FolderSettings;
-import com.android.email.mail.Address;
-import com.android.email.mail.Flag;
-import com.android.email.mail.Folder;
-import com.android.email.mail.Message;
-import com.android.email.mail.MessagingException;
-import com.android.email.mail.Store;
-import com.android.email.mail.Message.RecipientType;
-import com.android.email.mail.store.LocalStore;
-import com.android.email.mail.store.LocalStore.LocalFolder;
-import com.android.email.mail.store.LocalStore.LocalMessage;
-
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-
-
-
-/**
- * MessageList is the primary user interface for the program. This
- * Activity shows a two level list of the Account's folders and each folder's
- * messages. From this Activity the user can perform all standard message
- * operations.
- *
- *
- * TODO Break out seperate functions for: refresh local folders refresh remote
- * folders refresh open folder local messages refresh open folder remote
- * messages
- *
- * And don't refresh remote folders ever unless the user runs a refresh. Maybe
- * not even then.
- */
-
-public class MessageList extends K9ListActivity {
-
-    private static final String INTENT_DATA_PATH_SUFFIX = "/accounts";
-
-    private static final int DIALOG_MARK_ALL_AS_READ = 1;
-
-    private static final int ACTIVITY_CHOOSE_FOLDER_MOVE = 1;
-
-    private static final int ACTIVITY_CHOOSE_FOLDER_COPY = 2;
-
-
-    private static final boolean FORCE_REMOTE_SYNC = true;
-
-    private static final String EXTRA_ACCOUNT = "account";
-    private static final String EXTRA_STARTUP = "startup";
-
-    private static final String EXTRA_CLEAR_NOTIFICATION = "clearNotification";
-
-    private static final String EXTRA_FOLDER = "folder";
-    private static final String STATE_KEY_LIST = "com.android.email.activity.messagelist_state";
-
-    private static final String STATE_CURRENT_FOLDER = "com.android.email.activity.messagelist_folder";
-    private static final String STATE_KEY_SELECTION = "com.android.email.activity.messagelist_selection";
-
-    private static final int[] colorChipResIds = new int[] {
-                R.drawable.appointment_indicator_leftside_1,
-                R.drawable.appointment_indicator_leftside_2,
-                R.drawable.appointment_indicator_leftside_3,
-                R.drawable.appointment_indicator_leftside_4,
-                R.drawable.appointment_indicator_leftside_5,
-                R.drawable.appointment_indicator_leftside_6,
-                R.drawable.appointment_indicator_leftside_7,
-                R.drawable.appointment_indicator_leftside_8,
-                R.drawable.appointment_indicator_leftside_9,
-                R.drawable.appointment_indicator_leftside_10,
-                R.drawable.appointment_indicator_leftside_11,
-                R.drawable.appointment_indicator_leftside_12,
-                R.drawable.appointment_indicator_leftside_13,
-                R.drawable.appointment_indicator_leftside_14,
-                R.drawable.appointment_indicator_leftside_15,
-                R.drawable.appointment_indicator_leftside_16,
-                R.drawable.appointment_indicator_leftside_17,
-                R.drawable.appointment_indicator_leftside_18,
-                R.drawable.appointment_indicator_leftside_19,
-                R.drawable.appointment_indicator_leftside_20,
-                R.drawable.appointment_indicator_leftside_21,
-            };
-
-    private ListView mListView;
-
-    private int colorChipResId;
-
-    private MessageListAdapter mAdapter;
-
-    private FolderInfoHolder mCurrentFolder;
-
-    private LayoutInflater mInflater;
-
-    private Account mAccount;
-
-
-    /**
-    * Stores the name of the folder that we want to open as soon as possible
-    * after load. It is set to null once the folder has been opened once.
-     */
-    private String mFolderName;
-
-
-    private boolean mRestoringState;
-
-    private boolean mRefreshRemote;
-
-    private MessageListHandler mHandler = new MessageListHandler();
-
-    private DateFormat dateFormat = null;
-
-    private DateFormat timeFormat = null;
-
-    private SORT_TYPE sortType = SORT_TYPE.SORT_DATE;
-
-    private boolean sortAscending = true;
-
-    private boolean sortDateAscending = false;
-
-    private boolean mStartup = false;
-
-    private static final ThreadPoolExecutor threadPool = new ThreadPoolExecutor(1, 1, 120000L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());
-
-    private DateFormat getDateFormat() {
-        if (dateFormat == null) {
-            String dateFormatS = android.provider.Settings.System.getString(getContentResolver(),
-                                 android.provider.Settings.System.DATE_FORMAT);
-
-            if (dateFormatS != null) {
-                dateFormat = new java.text.SimpleDateFormat(dateFormatS);
-            } else {
-                dateFormat = new java.text.SimpleDateFormat(Email.BACKUP_DATE_FORMAT);
-            }
-        }
-
-        return dateFormat;
-    }
-
-    private DateFormat getTimeFormat() {
-
-        if (timeFormat == null) {
-            String timeFormatS = android.provider.Settings.System.getString(getContentResolver(),
-                                 android.provider.Settings.System.TIME_12_24);
-            boolean b24 =  !(timeFormatS == null || timeFormatS.equals("12"));
-            timeFormat = new java.text.SimpleDateFormat(b24 ? Email.TIME_FORMAT_24 : Email.TIME_FORMAT_12);
-        }
-
-        return timeFormat;
-    }
-
-    private void clearFormats() {
-        dateFormat = null;
-        timeFormat = null;
-    }
-
-
-
-    class MessageListHandler extends Handler {
-
-        private static final int MSG_PROGRESS = 2;
-
-        private static final int MSG_DATA_CHANGED = 3;
-
-        private static final int MSG_FOLDER_LOADING = 7;
-
-        private static final int MSG_REMOVE_MESSAGE = 11;
-
-        private static final int MSG_SYNC_MESSAGES = 13;
-
-        private static final int MSG_FOLDER_SYNCING = 18;
-
-        private static final int MSG_SENDING_OUTBOX = 19;
-
-        @Override
-        public void handleMessage(android.os.Message msg) {
-            switch (msg.what) {
-            case MSG_PROGRESS:
-                showProgressIndicator(msg.arg1 != 0 );
-                break;
-
-            case MSG_DATA_CHANGED:
-                mAdapter.notifyDataSetChanged();
-
-                break;
-
-            case MSG_REMOVE_MESSAGE: {
-                FolderInfoHolder folder = (FolderInfoHolder)((Object[]) msg.obj)[0];
-                MessageInfoHolder message = (MessageInfoHolder)((Object[]) msg.obj)[1];
-                folder.messages.remove(message);
-                mAdapter.notifyDataSetChanged();
-                break;
-            }
-
-            case MSG_SYNC_MESSAGES: {
-                FolderInfoHolder folder = (FolderInfoHolder)((Object[]) msg.obj)[0];
-                Message[] messages = (Message[])((Object[]) msg.obj)[1];
-
-                for(MessageInfoHolder message : mAdapter.messages) {
-                    message.dirty = true;
-                }
-
-                for (Message message : messages) {
-                    mAdapter.addOrUpdateMessage(folder, message, true, false);
-                    mAdapter.notifyDataSetChanged();
-                }
-                mAdapter.removeDirtyMessages();                
-                break;
-            }
-
-            case MSG_FOLDER_SYNCING: {
-                String folderName = (String)((Object[]) msg.obj)[0];
-                String dispString;
-                dispString = mAccount.getDescription();
-
-                if (folderName != null) {
-                    dispString += " (" + getString(R.string.status_loading)
-                                  + folderName + ")";
-                }
-
-                setTitle(dispString);
-
-                break;
-            }
-
-            case MSG_SENDING_OUTBOX: {
-                boolean sending = (msg.arg1 != 0);
-                String dispString;
-                dispString = mAccount.getDescription();
-
-                if (sending) {
-                    dispString += " (" + getString(R.string.status_sending) + ")";
-                }
-
-                setTitle(dispString);
-
-                break;
-            }
-
-            default:
-                super.handleMessage(msg);
-            }
-        }
-
-        public void synchronizeMessages(FolderInfoHolder folder, Message[] messages) {
-            android.os.Message msg = new android.os.Message();
-            msg.what = MSG_SYNC_MESSAGES;
-            msg.obj = new Object[] { folder, messages };
-            sendMessage(msg);
-        }
-
-
-        public void removeMessage(MessageInfoHolder message) {
-            android.os.Message msg = new android.os.Message();
-            msg.what = MSG_REMOVE_MESSAGE;
-            msg.obj = new Object[] { message.folder, message };
-            sendMessage(msg);
-        }
-
-        public void folderLoading(String folder, boolean loading) {
-            android.os.Message msg = new android.os.Message();
-            msg.what = MSG_FOLDER_LOADING;
-            msg.arg1 = loading ? 1 : 0;
-            msg.obj = folder;
-            sendMessage(msg);
-        }
-
-        public void progress(boolean progress) {
-            android.os.Message msg = new android.os.Message();
-            msg.what = MSG_PROGRESS;
-            msg.arg1 = progress ? 1 : 0;
-            sendMessage(msg);
-        }
-
-        public void dataChanged() {
-            sendEmptyMessage(MSG_DATA_CHANGED);
-        }
-
-        public void folderSyncing(String folder) {
-            android.os.Message msg = new android.os.Message();
-            msg.what = MSG_FOLDER_SYNCING;
-            msg.obj = new String[]
-                      { folder };
-            sendMessage(msg);
-        }
-
-        public void sendingOutbox(boolean sending) {
-            android.os.Message msg = new android.os.Message();
-            msg.what = MSG_SENDING_OUTBOX;
-            msg.arg1 = sending ? 1 : 0;
-            sendMessage(msg);
-        }
-    }
-
-    /**
-    * This class is responsible for reloading the list of local messages for a
-    * given folder, notifying the adapter that the message have been loaded and
-    * queueing up a remote update of the folder.
-     */
-
-    public static void actionHandleFolder(Context context, Account account, String folder, boolean startup) {
-        Intent intent = new Intent(context, MessageList.class);
-        intent.putExtra(EXTRA_ACCOUNT, account);
-        intent.putExtra(EXTRA_STARTUP, startup);
-
-        if (folder != null) {
-            intent.putExtra(EXTRA_FOLDER, folder);
-        }
-
-        context.startActivity(intent);
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        //Debug.startMethodTracing("k9");
-        super.onCreate(savedInstanceState);
-
-        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
-
-        mListView = getListView();
-        mListView.setScrollBarStyle(View.SCROLLBARS_OUTSIDE_INSET);
-        mListView.setLongClickable(true);
-        //mListView.setFastScrollEnabled(true); // XXX TODO - reenable when we switch to 1.5
-        mListView.setScrollingCacheEnabled(true);
-
-        registerForContextMenu(mListView);
-
-        /*
-        * We manually save and restore the list's state because our adapter is
-        * slow.
-         */
-        mListView.setSaveEnabled(false);
-
-        mInflater = getLayoutInflater();
-
-        Intent intent = getIntent();
-        mAccount = (Account)intent.getSerializableExtra(EXTRA_ACCOUNT);
-        mStartup = (boolean)intent.getBooleanExtra(EXTRA_STARTUP, false);
-
-        // Take the initial folder into account only if we are *not* restoring the
-        // activity already
-
-        if (savedInstanceState == null) {
-            mFolderName = intent.getStringExtra(EXTRA_FOLDER);
-
-            if (mFolderName == null) {
-                mFolderName = mAccount.getAutoExpandFolderName();
-            }
-        } else {
-            mFolderName = savedInstanceState.getString(STATE_CURRENT_FOLDER);
-        }
-
-        mListView.setOnItemClickListener(new OnItemClickListener() {
-            public void onItemClick(AdapterView parent, View v, int itemPosition, long id){
-                    if ((itemPosition+1) == (mAdapter.getCount() )) {
-                        onRefresh(FORCE_REMOTE_SYNC);
-                        return;
-                    } else { 
-                        MessageInfoHolder message = (MessageInfoHolder) mAdapter.getItem( itemPosition);
-                        onOpenMessage( message);
-                    }
-            }
-
-
-        });
-
-        /*
-        * Since the color chip is always the same color for a given account we just
-        * cache the id of the chip right here.
-         */
-        colorChipResId = colorChipResIds[mAccount.getAccountNumber() % colorChipResIds.length];
-
-        mAdapter = new MessageListAdapter();
-
-        mCurrentFolder = mAdapter.getFolder(mFolderName);
-
-        setListAdapter(mAdapter);
-
-        if (savedInstanceState != null) {
-            mRestoringState = true;
-            onRestoreListState(savedInstanceState);
-            mRestoringState = false;
-        }
-
-        setTitle(
-                    mAccount.getDescription()
-                    + " - " +
-                    mCurrentFolder.displayName
-                    
-                    );
-    }
-
-    private void onRestoreListState(Bundle savedInstanceState) {
-            String currentFolder = savedInstanceState.getString(STATE_CURRENT_FOLDER);
-            int selectedChild = savedInstanceState.getInt( STATE_KEY_SELECTION, -1);
-
-            if (selectedChild != 0 ){
-                mListView.setSelection(selectedChild);
-            }
-            if (currentFolder != null ) { 
-                mCurrentFolder = mAdapter.getFolder(currentFolder);
-            }
-
-
-        mListView.onRestoreInstanceState(savedInstanceState.getParcelable(STATE_KEY_LIST));
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-        //Debug.stopMethodTracing();
-        MessagingController.getInstance(getApplication()).removeListener( mAdapter.mListener);
-    }
-
-    /**
-    * On resume we refresh 
-    * messages for any folder that is currently open. This guarantees that things
-    * like unread message count and read status are updated.
-     */
-    @Override
-    public void onResume() {
-        super.onResume();
-        clearFormats();
-        sortType = MessagingController.getInstance(getApplication()).getSortType();
-        sortAscending = MessagingController.getInstance(getApplication()).isSortAscending(sortType);
-        sortDateAscending = MessagingController.getInstance(getApplication()).isSortAscending(SORT_TYPE.SORT_DATE);
-
-        MessagingController.getInstance(getApplication()).addListener( mAdapter.mListener);
-
-        onRefresh(!FORCE_REMOTE_SYNC);
-
-        NotificationManager notifMgr = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
-        notifMgr.cancel(mAccount.getAccountNumber());
-        notifMgr.cancel(-1000 - mAccount.getAccountNumber());
-
-    }
-
-    @Override
-    public void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        outState.putParcelable(STATE_KEY_LIST, mListView.onSaveInstanceState());
-        outState.putInt(STATE_KEY_SELECTION, mListView .getSelectedItemPosition());
-        outState.putString(STATE_CURRENT_FOLDER, mCurrentFolder.name);
-    }
-
-
-
-
-
-    @Override
-    public boolean onKeyDown(int keyCode, KeyEvent event) {
-        //Shortcuts that work no matter what is selected
-
-        switch (keyCode) {
-        case KeyEvent.KEYCODE_C: { onCompose(); return true;}
-
-        case KeyEvent.KEYCODE_Q: { onShowFolderList(); return true; }
-
-        case KeyEvent.KEYCODE_O: { onCycleSort(); return true; }
-
-        case KeyEvent.KEYCODE_I: { onToggleSortAscending(); return true; }
-
-        case KeyEvent.KEYCODE_H: {
-            Toast toast = Toast.makeText(this, R.string.message_list_help_key, Toast.LENGTH_LONG);
-            toast.show();
-            return true;
-        }
-        }//switch
-
-        int position = mListView.getSelectedItemPosition();
-        try {
-               if (position >= 0 ) {
-                MessageInfoHolder message = (MessageInfoHolder) mAdapter.getItem(position);
-
-                if (message != null) {
-                    switch (keyCode) {
-                    case KeyEvent.KEYCODE_DEL: { onDelete(message, position); return true;}
-
-                    case KeyEvent.KEYCODE_D: { onDelete(message, position); return true;}
-
-                    case KeyEvent.KEYCODE_F: { onForward(message); return true;}
-
-                    case KeyEvent.KEYCODE_A: { onReplyAll(message); return true; }
-
-                    case KeyEvent.KEYCODE_R: { onReply(message); return true; }
-
-                    case KeyEvent.KEYCODE_G: { onToggleFlag(message); return true; }
-
-                    case KeyEvent.KEYCODE_M: { onMove(message); return true; }
-
-                    case KeyEvent.KEYCODE_Y: { onCopy(message); return true; }
-
-                    case KeyEvent.KEYCODE_Z: { onToggleRead(message); return true; }
-                    }
-                }
-            }
-        } finally {
-            return super.onKeyDown(keyCode, event);
-        }
-    }//onKeyDown
-
-
-
-
-    private void onRefresh(final boolean forceRemote) {
-        if (forceRemote) {
-            mRefreshRemote = true;
-        }
-
-        new Thread() {
-
-            public void run() {
-                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
-                if (forceRemote) {
-                    MessagingController.getInstance(getApplication()).synchronizeMailbox( mAccount, mFolderName, mAdapter.mListener);
-                    MessagingController.getInstance(getApplication()).sendPendingMessages(mAccount, null);
-                }
-                MessagingController.getInstance(getApplication()).listLocalMessages(mAccount, mFolderName,  mAdapter.mListener);
-
-            }
-        }
-
-        .start();
-    }
-
-    private void onOpenMessage( MessageInfoHolder message) {
-        /*
-        * We set read=true here for UI performance reasons. The actual value will
-        * get picked up on the refresh when the Activity is resumed but that may
-        * take a second or so and we don't want this to show and then go away. I've
-        * gone back and forth on this, and this gives a better UI experience, so I
-        * am putting it back in.
-         */
-
-        if (!message.read) {
-            message.read = true;
-            mHandler.dataChanged();
-        }
-
-        if (message.folder.name.equals(mAccount.getDraftsFolderName())) {
-            MessageCompose.actionEditDraft(this, mAccount, message.message);
-        } else {
-            ArrayList<String> folderUids = new ArrayList<String>();
-
-            for (MessageInfoHolder holder : mAdapter.messages) {
-                folderUids.add(holder.uid);
-            }
-
-            MessageView.actionView(this, mAccount, message.folder.name, message.uid, folderUids);
-        }
-    }
-
-    private void onShowFolderList() {
-        // If we're a child activity (say because Welcome dropped us straight to the message list
-        // we won't have a parent activity and we'll need to get back to it
-        if (mStartup
-            || isTaskRoot()) {
-            FolderList.actionHandleAccount(this, mAccount, false);
-        }
-        finish();
-    }
-
-    private void onCompose() {
-        MessageCompose.actionCompose(this, mAccount);
-    }
-
-    private void changeSort(SORT_TYPE newSortType) {
-        sortType = newSortType;
-        MessagingController.getInstance(getApplication()).setSortType(sortType);
-        sortAscending = MessagingController.getInstance(getApplication()).isSortAscending(sortType);
-        sortDateAscending = MessagingController.getInstance(getApplication()).isSortAscending(SORT_TYPE.SORT_DATE);
-        reSort();
-    }
-
-    private void reSort() {
-        int toastString = sortType.getToast(sortAscending);
-
-        Toast toast = Toast.makeText(this, toastString, Toast.LENGTH_SHORT);
-        toast.show();
-
-        Collections.sort(mAdapter.messages);
-
-        mAdapter.notifyDataSetChanged();
-
-    }
-
-
-    private void onCycleSort() {
-        SORT_TYPE[] sorts = SORT_TYPE.values();
-        int curIndex = 0;
-
-        for (int i = 0; i < sorts.length; i++) {
-            if (sorts[i] == sortType) {
-                curIndex = i;
-                break;
-            }
-        }
-
-        curIndex++;
-
-        if (curIndex == sorts.length) {
-            curIndex = 0;
-        }
-
-        changeSort(sorts[curIndex]);
-    }
-
-    private void onToggleSortAscending() {
-        MessagingController.getInstance(getApplication()).setSortAscending(sortType, !sortAscending);
-
-        sortAscending = MessagingController.getInstance(getApplication()).isSortAscending(sortType);
-        sortDateAscending = MessagingController.getInstance(getApplication()).isSortAscending(SORT_TYPE.SORT_DATE);
-
-        reSort();
-    }
-
-    private void onDelete(MessageInfoHolder holder, int position) {
-        if (holder.read == false && holder.folder.unreadMessageCount > 0) {
-            holder.folder.unreadMessageCount--;
-        }
-
-        FolderInfoHolder trashHolder = mAdapter.getFolder(mAccount.getTrashFolderName());
-
-        if (trashHolder != null) {
-            trashHolder.needsRefresh = true;
-        }
-
-        mAdapter.removeMessage(holder);
-        mListView.setSelection(position);
-        MessagingController.getInstance(getApplication()).deleteMessage(mAccount, holder.message.getFolder().getName(), holder.message, null);
-
-    }
-
-
-    private void onMove(MessageInfoHolder holder) {
-        if (MessagingController.getInstance(getApplication()).isMoveCapable(mAccount) == false) {
-            return;
-        }
-
-        if (MessagingController.getInstance(getApplication()).isMoveCapable(holder.message) == false) {
-            Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
-            toast.show();
-            return;
-        }
-
-        Intent intent = new Intent(this, ChooseFolder.class);
-
-        intent.putExtra(ChooseFolder.EXTRA_ACCOUNT, mAccount);
-        intent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, holder.folder.name);
-        intent.putExtra(ChooseFolder.EXTRA_MESSAGE_UID, holder.message.getUid());
-        startActivityForResult(intent, ACTIVITY_CHOOSE_FOLDER_MOVE);
-    }
-
-    private void onCopy(MessageInfoHolder holder) {
-        if (MessagingController.getInstance(getApplication()).isCopyCapable(mAccount) == false) {
-            return;
-        }
-
-        if (MessagingController.getInstance(getApplication()).isCopyCapable(holder.message) == false) {
-            Toast toast = Toast.makeText(this, R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);
-            toast.show();
-            return;
-        }
-
-        Intent intent = new Intent(this, ChooseFolder.class);
-
-        intent.putExtra(ChooseFolder.EXTRA_ACCOUNT, mAccount);
-        intent.putExtra(ChooseFolder.EXTRA_CUR_FOLDER, holder.folder.name);
-        intent.putExtra(ChooseFolder.EXTRA_MESSAGE_UID, holder.message.getUid());
-        startActivityForResult(intent, ACTIVITY_CHOOSE_FOLDER_COPY);
-    }
-
-    @Override
-    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
-        if (resultCode != RESULT_OK)
-            return;
-
-        switch (requestCode) {
-        case ACTIVITY_CHOOSE_FOLDER_MOVE:
-        case ACTIVITY_CHOOSE_FOLDER_COPY:
-            if (data == null)
-                return;
-
-            String destFolderName = data.getStringExtra(ChooseFolder.EXTRA_NEW_FOLDER);
-
-            String srcFolderName = data.getStringExtra(ChooseFolder.EXTRA_CUR_FOLDER);
-
-            String uid = data.getStringExtra(ChooseFolder.EXTRA_MESSAGE_UID);
-
-            FolderInfoHolder srcHolder = mAdapter.getFolder(srcFolderName);
-
-            FolderInfoHolder destHolder = mAdapter.getFolder(destFolderName);
-
-            if (srcHolder != null && destHolder != null) {
-                MessageInfoHolder m = mAdapter.getMessage( uid);
-
-                if (m != null) {
-                    switch (requestCode) {
-                    case ACTIVITY_CHOOSE_FOLDER_MOVE:
-                        onMoveChosen(m, destHolder);
-
-                        break;
-
-                    case ACTIVITY_CHOOSE_FOLDER_COPY:
-                        onCopyChosen(m, destHolder);
-
-                        break;
-                    }
-                }
-            }
-        }
-    }
-
-
-    private void onMoveChosen(MessageInfoHolder holder, FolderInfoHolder folder) {
-        if (MessagingController.getInstance(getApplication()).isMoveCapable(mAccount) == false) {
-            return;
-        }
-
-//    String destFolderName = folder.name;
-//    FolderInfoHolder destHolder = mAdapter.getFolder(destFolderName);
-//
-        if (folder == null) {
-            return;
-        }
-
-        if (holder.read == false) {
-            if (holder.folder.unreadMessageCount > 0) {
-                holder.folder.unreadMessageCount--;
-            }
-
-            folder.unreadMessageCount++;
-        }
-
-        folder.needsRefresh = true;
-
-        mAdapter.removeMessage(holder);
-        MessagingController.getInstance(getApplication()).moveMessage(mAccount, holder.message.getFolder().getName(), holder.message, folder.name, null);
-
-    }
-
-
-    private void onCopyChosen(MessageInfoHolder holder, FolderInfoHolder folder) {
-        if (MessagingController.getInstance(getApplication()).isCopyCapable(mAccount) == false) {
-            return;
-        }
-
-        if (folder == null) {
-            return;
-        }
-
-        if (holder.read == false) {
-            folder.unreadMessageCount++;
-        }
-
-        folder.needsRefresh = true;
-
-        MessagingController.getInstance(getApplication()).copyMessage(mAccount,
-                holder.message.getFolder().getName(), holder.message, folder.name, null);
-    }
-
-
-    private void onReply(MessageInfoHolder holder) {
-        MessageCompose.actionReply(this, mAccount, holder.message, false);
-    }
-
-    private void onReplyAll(MessageInfoHolder holder) {
-        MessageCompose.actionReply(this, mAccount, holder.message, true);
-    }
-
-    private void onForward(MessageInfoHolder holder) {
-        MessageCompose.actionForward(this, mAccount, holder.message);
-    }
-
-
-    private Account mSelectedContextAccount = null;
-    private FolderInfoHolder mSelectedContextFolder = null;
-    private void onMarkAllAsRead(final Account account, final FolderInfoHolder folder) {
-        mSelectedContextAccount = account;
-        mSelectedContextFolder = folder;
-        showDialog(DIALOG_MARK_ALL_AS_READ);
-    }
-
-    @Override
-    public Dialog onCreateDialog(int id) {
-        switch (id) {
-        case DIALOG_MARK_ALL_AS_READ:
-            return createMarkAllAsReadDialog();
-        }
-
-        return super.onCreateDialog(id);
-    }
-
-    public void onPrepareDialog(int id, Dialog dialog) {
-        switch (id) {
-        case DIALOG_MARK_ALL_AS_READ:
-            ((AlertDialog)dialog).setMessage(getString(R.string.mark_all_as_read_dlg_instructions_fmt,
-                                             mSelectedContextFolder.displayName));
-
-            break;
-
-        default:
-            super.onPrepareDialog(id, dialog);
-        }
-    }
-
-    private Dialog createMarkAllAsReadDialog() {
-        return new AlertDialog.Builder(this)
-               .setTitle(R.string.mark_all_as_read_dlg_title)
-               .setMessage(getString(R.string.mark_all_as_read_dlg_instructions_fmt,
-                                     mSelectedContextFolder.displayName))
-               .setPositiveButton(R.string.okay_action, new DialogInterface.OnClickListener() {
-                                      public void onClick(DialogInterface dialog, int whichButton) {
-                                          dismissDialog(DIALOG_MARK_ALL_AS_READ);
-
-                                          try {
-
-                                              MessagingController.getInstance(getApplication()).markAllMessagesRead(mSelectedContextAccount, mSelectedContextFolder.name);
-
-                                              for (MessageInfoHolder holder : mSelectedContextFolder.messages) {
-                                                  holder.read = true;
-                                              }
-
-                                              mSelectedContextFolder.unreadMessageCount = 0;
-
-                                              mHandler.dataChanged();
-
-
-                                          } catch (Exception e) {
-                                              // Ignore
-                                          }
-                                      }
-                                  })
-
-               .setNegativeButton(R.string.cancel_action, new DialogInterface.OnClickListener() {
-                                      public void onClick(DialogInterface dialog, int whichButton) {
-                                          dismissDialog(DIALOG_MARK_ALL_AS_READ);
-                                      }
-                                  })
-
-               .create();
-    }
-
-    private void onToggleRead(MessageInfoHolder holder) {
-
-        holder.folder.unreadMessageCount += (holder.read ? 1 : -1);
-
-        if (holder.folder.unreadMessageCount < 0) {
-            holder.folder.unreadMessageCount = 0;
-        }
-
-        MessagingController.getInstance(getApplication()).markMessageRead(mAccount, holder.message.getFolder().getName(), holder.uid, !holder.read);
-        holder.read = !holder.read;
-        mHandler.dataChanged();
-    }
-
-    private void onToggleFlag(MessageInfoHolder holder) {
-
-        MessagingController.getInstance(getApplication()).setMessageFlag(mAccount, holder.message.getFolder().getName(), holder.uid, Flag.FLAGGED, !holder.flagged);
-        holder.flagged = !holder.flagged;
-        mHandler.dataChanged();
-    }
-
-//    private void checkMail(final Account account) {
-//        MessagingController.getInstance(getApplication()).checkMail(this, account, true, true, mAdapter.mListener);
-//    }
-
-    private void checkMail(Account account, String folderName) {
-        MessagingController.getInstance(getApplication()).synchronizeMailbox( account, folderName, mAdapter.mListener);
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        switch (item.getItemId()) {
-        case R.id.check_mail:
-            checkMail(mAccount, mFolderName);
-            return true;
-
-        case R.id.compose:
-            onCompose();
-
-            return true;
-
-        case R.id.set_sort_date:
-            changeSort(SORT_TYPE.SORT_DATE);
-
-            return true;
-
-        case R.id.set_sort_subject:
-            changeSort(SORT_TYPE.SORT_SUBJECT);
-
-            return true;
-
-        case R.id.set_sort_sender:
-            changeSort(SORT_TYPE.SORT_SENDER);
-
-            return true;
-
-        case R.id.set_sort_flag:
-            changeSort(SORT_TYPE.SORT_FLAGGED);
-
-            return true;
-
-        case R.id.set_sort_unread:
-            changeSort(SORT_TYPE.SORT_UNREAD);
-
-            return true;
-
-        case R.id.set_sort_attach:
-            changeSort(SORT_TYPE.SORT_ATTACHMENT);
-
-            return true;
-
-        case R.id.reverse_sort:
-            onToggleSortAscending();
-
-            return true;
-
-        case R.id.list_folders:
-            onShowFolderList();
-            
-            return true;
-
-        case R.id.mark_all_as_read:
-            MessagingController.getInstance(getApplication()).markAllMessagesRead(mAccount, mFolderName);
-
-            return true;
-
-        case R.id.folder_settings:
-            FolderSettings.actionSettings(this, mAccount, mFolderName);
-
-            return true;
-
-        default:
-            return super.onOptionsItemSelected(item);
-        }
-    }
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        super.onCreateOptionsMenu(menu);
-        getMenuInflater().inflate(R.menu.message_list_option, menu);
-        return true;
-    }
-
-    @Override
-    public boolean onContextItemSelected(MenuItem item) {
-        AdapterContextMenuInfo info = (AdapterContextMenuInfo) item .getMenuInfo();
-        MessageInfoHolder holder = (MessageInfoHolder) mAdapter.getItem(info.position);
-
-            switch (item.getItemId()) {
-            case R.id.open:
-                onOpenMessage(holder);
-
-                break;
-
-            case R.id.delete:
-                onDelete(holder, info.position);
-
-                break;
-
-            case R.id.reply:
-                onReply(holder);
-
-                break;
-
-            case R.id.reply_all:
-                onReplyAll(holder);
-
-                break;
-
-            case R.id.forward:
-                onForward(holder);
-
-                break;
-
-            case R.id.mark_as_read:
-                onToggleRead(holder);
-
-                break;
-
-            case R.id.flag:
-                onToggleFlag(holder);
-
-                break;
-
-            case R.id.move:
-                onMove(holder);
-
-                break;
-
-            case R.id.copy:
-                onCopy(holder);
-
-                break;
-
-            case R.id.send_alternate:
-                onSendAlternate(mAccount, holder);
-
-                break;
-
-            }
-
-        return super.onContextItemSelected(item);
-    }
-
-    public void onSendAlternate(Account account, MessageInfoHolder holder) {
-        MessagingController.getInstance(getApplication()).sendAlternate(this, account, holder.message);
-    }
-
-    public void showProgressIndicator(boolean status) {
-        setProgressBarIndeterminateVisibility(status);
-        ProgressBar bar = (ProgressBar)mListView.findViewById( R.id.message_list_progress);
-        if (bar == null) {
-            return;
-        }   
-
-        bar.setIndeterminate(true);
-        if (status) {
-            bar.setVisibility(bar.VISIBLE);
-        } else {
-            bar.setVisibility(bar.INVISIBLE);
-
-        }
-    }
-
-    @Override public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
-        super.onCreateContextMenu(menu, v, menuInfo);
-    
-    
-        AdapterContextMenuInfo info = (AdapterContextMenuInfo) menuInfo;
-        MessageInfoHolder message = (MessageInfoHolder) mAdapter.getItem(info.position );
-    
-        if (message == null) {
-            return;
-        }
-
-        getMenuInflater().inflate(R.menu.message_list_context, menu);
-   
-        menu.setHeaderTitle((CharSequence) message.subject);
-
-        if (message.read) {
-            menu.findItem(R.id.mark_as_read).setTitle( R.string.mark_as_unread_action);
-        }
-    
-        if (message.flagged) {
-            menu.findItem(R.id.flag).setTitle( R.string.unflag_action);
-        }
-    
-        if (MessagingController.getInstance(getApplication()).isCopyCapable(mAccount) == false) {
-            menu.findItem(R.id.copy).setVisible(false);
-        }
-    
-        if (MessagingController.getInstance(getApplication()).isMoveCapable(mAccount) == false) {
-            menu.findItem(R.id.move).setVisible(false);
-        }
-    }
-    
-    private String truncateStatus(String mess) {
-        if (mess != null && mess.length() > 27) {
-            mess = mess.substring(0, 27);
-        }
-
-        return mess;
-    }
-
-    class MessageListAdapter extends BaseAdapter {
-        private ArrayList<MessageInfoHolder> messages = new ArrayList<MessageInfoHolder>();
-
-        private MessagingListener mListener = new MessagingListener() {
-
-            @Override
-			public void synchronizeMailboxStarted(Account account, String folder) {
-				if (!account.equals(mAccount) || !folder.equals(mFolderName)) {
-                    return;
-                }
-
-                mHandler.progress(true);
-            }
-
-            @Override
-			public void synchronizeMailboxNewMessage(Account account, String folder, Message message) {
-				if (!account.equals(mAccount) || !folder.equals(mFolderName)) {
-                    return;
-                }
-
-                addOrUpdateMessage(folder, message, true, true);
-            }
-            
-            @Override
-            public void synchronizeMailboxRemovedMessage(Account account, String folder,Message message) {
-                removeMessage(getMessage( message.getUid()));
-            }
-
-            @Override
-            public void synchronizeMailboxFinished(Account account, String folder,
-                int totalMessagesInMailbox, int numNewMessages)  {
-				if (!account.equals(mAccount) || !folder.equals(mFolderName)) {
-                    return;
-                }
-
-                mHandler.progress(false);
-            }
-
-            @Override
-            public void synchronizeMailboxFailed(Account account, String folder, String message) {
-				if (!account.equals(mAccount) || !folder.equals(mFolderName)) {
-                    return;
-                }
-
-                Toast.makeText(MessageList.this, message, Toast.LENGTH_LONG).show();
-            }
-
-            @Override
-			public void listLocalMessagesStarted(Account account, String folder) {
-				if (!account.equals(mAccount)) {
-                    return;
-                }
-                mHandler.progress(true);
-                mHandler.folderLoading(folder, true);
-            }
-
-            @Override
-			public void listLocalMessagesFailed(Account account, String folder, String message) {
-				if (!account.equals(mAccount)) {
-                    return;
-                }
-              
-                Collections.sort(mAdapter.messages);
-                mHandler.dataChanged();
-                mHandler.progress(false);
-                mHandler.folderLoading(folder, false);
-            }
-
-            @Override
-			public void listLocalMessagesFinished(Account account, String folder) {
-				if (!account.equals(mAccount)) {
-                    return;
-                }
-
-                Collections.sort(mAdapter.messages);
-                mHandler.dataChanged();
-
-                mHandler.progress(false);
-                mHandler.folderLoading(folder, false);
-            }
-
-            @Override
-			public void listLocalMessages(Account account, String folder, Message[] messages) {
-				if (!account.equals(mAccount)) {
-                    return;
-                }
-        
-                if (folder != mFolderName) {
-                    return;
-                }
-                
-                //synchronizeMessages(folder, messages);
-            }
-            @Override
-            public void listLocalMessagesRemoveMessage(Account account, String folder,Message message) {
-				if (!account.equals(mAccount) || !folder.equals(mFolderName)) {
-                    return;
-                }
-                MessageInfoHolder holder = getMessage(message.getUid());
-                if (holder != null ) {
-                    removeMessage(getMessage( message.getUid()));
-                }
-            } 
-
-
-            @Override
-			public void listLocalMessagesAddMessage(Account account, String folder, Message message) {
-				if (!account.equals(mAccount) || !folder.equals(mFolderName)) {
-                    return;
-                }
-
-                addOrUpdateMessage(folder, message, false, false);//true, true);
-                if (mAdapter.messages.size() % 10 == 0 ) { 
-                    Collections.sort(mAdapter.messages);
-                    mHandler.dataChanged();
-                }
-
-            }
-            
-            @Override
-			public void listLocalMessagesUpdateMessage(Account account, String folder, Message message) {
-				if (!account.equals(mAccount) || !folder.equals(mFolderName)) {
-                    return;
-                }
-
-                addOrUpdateMessage(folder, message, false, true);
-            }
-
-        };
-        
-        private Drawable mAttachmentIcon;
-        private Drawable mAnsweredIcon;
-        private View footerView = null;
-
-        MessageListAdapter() {
-            mAttachmentIcon = getResources().getDrawable( R.drawable.ic_mms_attachment_small);
-            mAnsweredIcon = getResources().getDrawable( R.drawable.ic_mms_answered_small);
-        }
-
-        public void removeDirtyMessages() {
-            Iterator<MessageInfoHolder> iter = messages.iterator();
-                while(iter.hasNext()) {
-                    MessageInfoHolder message = iter.next();
-                    if (message.dirty) {
-                        iter.remove();
-                }
-            }
-            notifyDataSetChanged();
-         }
-
-        public void removeMessage(MessageInfoHolder holder) {
-            if (holder.folder == null) {
-                return;
-            }
-
-
-            if (holder == null) {
-                return;
-            }
-
-            mAdapter.messages.remove(holder);
-            mHandler.removeMessage(holder);
-            Collections.sort(mAdapter.messages);
-            mHandler.dataChanged();
-
-        }
-
-        public void synchronizeMessages(String folder, Message[] messages) {
-            FolderInfoHolder f = getFolder(folder);
-
-            if (f == null) {
-                return;
-            }
-
-            mHandler.synchronizeMessages(f, messages);
-        }
-
-        public void addOrUpdateMessage(String folder, Message message) {
-            addOrUpdateMessage(folder, message, true, true);
-        }
-
-        private void addOrUpdateMessage(FolderInfoHolder folder, Message message, boolean sort, boolean notify) {
-
-            MessageInfoHolder m = getMessage( message.getUid());
-
-            if (m == null) {
-                m = new MessageInfoHolder(message, folder);
-                mAdapter.messages.add(m);
-            } else {
-                m.populate(message, folder);
-            }
-
-            if (sort) {
-                Collections.sort(mAdapter.messages);
-            }
-
-            if (notify) {
-                mHandler.dataChanged();
-            }
-        }
-
-        private void addOrUpdateMessage(String folder, Message message, boolean sort, boolean notify) {
-            FolderInfoHolder f = getFolder(folder);
-
-            if (f == null) {
-                return;
-            }
-
-            addOrUpdateMessage(f, message, sort, notify);
-        }
-
-        // XXX TODO - make this not use a for loop
-        public MessageInfoHolder getMessage( String messageUid) {
-            MessageInfoHolder searchHolder = new MessageInfoHolder();
-            searchHolder.uid = messageUid;
-            int index = mAdapter.messages.indexOf((Object) searchHolder);
-            if (index >= 0) {
-                return (MessageInfoHolder)mAdapter.messages.get( index );
-            } 
-            return null;
-        }
-
-        public FolderInfoHolder getFolder(String folder) {
-           try {
-             LocalStore localStore = (LocalStore)Store.getInstance( mAccount.getLocalStoreUri(), getApplication());
-            LocalFolder local_folder = localStore.getFolder(folder);
-            FolderInfoHolder holder =   new FolderInfoHolder ((Folder)local_folder);
-                     return holder;
-            } catch (Exception e) {
-                Log.e(Email.LOG_TAG, "getFolder(" + folder + ") goes boom: ",e);
-                return null;
-        }
-        }
-
-        private static final int NON_MESSAGE_ITEMS = 1;
-        public int getCount() {
-            if (mAdapter.messages == null || mAdapter.messages.size() == 0) {
-                return NON_MESSAGE_ITEMS ;
-            }
-
-            return mAdapter.messages.size() +NON_MESSAGE_ITEMS  ;
-        }
-
-        public long getItemId(int position) {
-                try {
-                    MessageInfoHolder messageHolder =(MessageInfoHolder) getItem(position);
-                    if (messageHolder != null) {
-                        return ((LocalStore.LocalMessage)  messageHolder.message).getId();
-                     }
-                } catch ( Exception e) {
-                    Log.i(Email.LOG_TAG,"getItemId("+position+") ",e);
-                }
-            return -1;
-        }
-
-        public Object getItem(long position) {
-            return getItem((int)position);
-        }
-
-        public Object getItem(int position) {
-            try {
-                if (position < mAdapter.messages.size())  {
-                    return mAdapter.messages.get(position);
-                }
-            } catch (Exception e) {
-                Log.e(Email.LOG_TAG, "getItem(" + position + "), but folder.messages.size() = " + mAdapter.messages.size(), e);
-            }
-                return null;
-        }
-
-         public View getView(int position, View convertView, ViewGroup parent) {
-            
-            if (position == mAdapter.messages.size()  ) {
-                return getFooterView(position, convertView, parent);
-            } else { 
-               return  getItemView(position, convertView, parent);
-            }
-        }
-       
-
-       public View getItemView(int position, View convertView, ViewGroup parent) {
-            MessageInfoHolder message = (MessageInfoHolder) getItem(position);
-            View view;
-           
-            if ((convertView != null) && (convertView.getId() == R.layout.message_list_item)) {
-                view = convertView;
-            } else {
-                view = mInflater.inflate(R.layout.message_list_item, parent, false);
-                view.setId(R.layout.message_list_item);
-            }
-            
-            
-            MessageViewHolder holder = (MessageViewHolder) view.getTag();
-
-            if (holder == null) {
-                holder = new MessageViewHolder();
-                holder.subject = (TextView) view.findViewById(R.id.subject);
-                holder.from = (TextView) view.findViewById(R.id.from);
-                holder.date = (TextView) view.findViewById(R.id.date);
-                holder.chip = view.findViewById(R.id.chip);
-                holder.chip.setBackgroundResource(colorChipResId);
-                view.setTag(holder);
-            }
-
-            if (message != null) {
-                holder.chip.getBackground().setAlpha(message.read ? 0 : 255);
-                holder.subject.setTypeface(null, message.read && !message.flagged ? Typeface.NORMAL  : Typeface.BOLD);
-
-                int subjectColor = holder.from.getCurrentTextColor();  // Get from another field that never changes color 
-
-                if (message.flagged) {
-                    subjectColor = Email.FLAGGED_COLOR;
-                } 
-
-                if (message.downloaded) {
-                    holder.chip.getBackground().setAlpha(message.read ? 0 : 127);
-                    view.getBackground().setAlpha(0);
-                } else {
-                    view.getBackground().setAlpha(127);
-                }
-
-                holder.subject.setTextColor( 0xff000000 | subjectColor);
-                holder.subject.setText(message.subject);
-
-                holder.from.setText(message.sender);
-                holder.from.setTypeface(null, message.read ? Typeface.NORMAL : Typeface.BOLD);
-                holder.date.setText(message.date);
-                holder.subject.setCompoundDrawablesWithIntrinsicBounds(
-                    message.answered ? mAnsweredIcon : null, // left
-                    null, // top
-                    message.hasAttachments ? mAttachmentIcon : null, // right
-                    null); // bottom
-            } else {
-                holder.chip.getBackground().setAlpha(0);
-                holder.subject.setText("No subject");
-                holder.subject.setTypeface(null, Typeface.NORMAL);
-                holder.from.setText("No sender");
-                holder.from.setTypeface(null, Typeface.NORMAL);
-                holder.date.setText("No date");
-                holder.from.setCompoundDrawablesWithIntrinsicBounds(null, null, null, null);
-            }
-            return view;
-        }
-
-        public View getFooterView(int position, View convertView, ViewGroup parent) {
-            if (footerView == null) {
-                footerView = mInflater.inflate(R.layout.message_list_item_footer, parent, false);
-                footerView.setId(R.layout.message_list_item_footer);
-                FooterViewHolder holder = new FooterViewHolder();
-                holder.progress = (ProgressBar)footerView.findViewById(R.id.message_list_progress);
-                holder.main = (TextView)footerView.findViewById(R.id.main_text);
-                footerView.setTag(holder);
-            }
-
-            FooterViewHolder holder = (FooterViewHolder)footerView.getTag();
-            if (mCurrentFolder.loading) {
-                holder.main.setText(getString(R.string.status_loading_more));
-                mHandler.progress(true);
-            } else {
-                if (mCurrentFolder.lastCheckFailed == false) {
-                    holder.main.setText(String.format(getString(R.string.load_more_messages_fmt).toString(), mAccount.getDisplayCount()));
-                } else {
-                    holder.main.setText(getString(R.string.status_loading_more_failed));
-                }
-            }
-
-            return footerView;
-        }
-
-        public boolean hasStableIds() {
-            return true;
-        }
-
-        public boolean isItemSelectable(int position) {
-            if ( position < mAdapter.messages.size() ) {
-                return true;
-            } else {
-                return false;
-            }
-        }
-
-    }
-
-        public class MessageInfoHolder implements Comparable<MessageInfoHolder> {
-            public String subject;
-
-            public String date;
-
-            public Date compareDate;
-
-            public String compareSubject;
-
-            public String sender;
-
-            public String compareCounterparty;
-
-            public String[] recipients;
-
-            public boolean hasAttachments;
-
-            public String uid;
-
-            public boolean read;
-
-            public boolean dirty;
-
-            public boolean answered;
-
-            public boolean flagged;
-
-            public boolean downloaded;
-
-            public boolean partially_downloaded;
-
-            public Message message;
-
-            public FolderInfoHolder folder;
-
-
-            // Empty constructor for comparison
-            public MessageInfoHolder() {}
-
-            public MessageInfoHolder(Message m, FolderInfoHolder folder) {
-                populate(m, folder);
-            }
-
-            public void populate(Message m, FolderInfoHolder folder) {
-                try {
-                    LocalMessage message = (LocalMessage) m;
-                    Date date = message.getSentDate();
-                    this.compareDate = date;
-                    this.folder = folder;
-
-                    this.dirty = false;
-
-
-                    if (Utility.isDateToday(date)) {
-                        this.date = getTimeFormat().format(date);
-                    } else {
-                        this.date = getDateFormat().format(date);
-                    }
-
-                    this.hasAttachments = message.getAttachmentCount() > 0;
-
-                    this.read = message.isSet(Flag.SEEN);
-                    this.answered = message.isSet(Flag.ANSWERED);
-                    this.flagged = message.isSet(Flag.FLAGGED);
-                    this.downloaded = message.isSet(Flag.X_DOWNLOADED_FULL);
-                    this.partially_downloaded = message.isSet(Flag.X_DOWNLOADED_PARTIAL);
-
-                    Address[] addrs = message.getFrom();
-
-                    if (addrs.length > 0 && mAccount.isAnIdentity(addrs[0])) {
-                        this.compareCounterparty = Address.toFriendly(message .getRecipients(RecipientType.TO));
-                        this.sender = String.format(getString(R.string.message_list_to_fmt), this.compareCounterparty);
-                    } else {
-                        this.sender = Address.toFriendly(addrs);
-                        this.compareCounterparty = this.sender;
-                    }
-
-                    this.subject = message.getSubject();
-
-                    this.uid = message.getUid();
-                    this.message = m;
-                } catch (MessagingException me) {
-                    if (Config.LOGV) {
-                        Log.v(Email.LOG_TAG, "Unable to load message info", me);
-                    }
-                }
-            }
-            
-            public boolean equals(Object o) {
-                if (this.uid.equals(((MessageInfoHolder)o).uid)) {
-                    return true;
-                } else {
-                    return false;
-                }
-            }
-
-
-            public int compareTo(MessageInfoHolder o) {
-                int ascender = (sortAscending ? 1 : -1);
-                int comparison = 0;
-
-                if (sortType == SORT_TYPE.SORT_SUBJECT) {
-                    if (compareSubject == null) {
-                        compareSubject = stripPrefixes(subject).toLowerCase();
-                    }
-
-                    if (o.compareSubject == null) {
-                        o.compareSubject = stripPrefixes(o.subject).toLowerCase();
-                    }
-
-                    comparison = this.compareSubject.compareTo(o.compareSubject);
-                } else if (sortType == SORT_TYPE.SORT_SENDER) {
-                    comparison = this.compareCounterparty.toLowerCase().compareTo(o.compareCounterparty.toLowerCase());
-                } else if (sortType == SORT_TYPE.SORT_FLAGGED) {
-                    comparison = (this.flagged ? 0 : 1) - (o.flagged ? 0 : 1);
-
-                } else if (sortType == SORT_TYPE.SORT_UNREAD) {
-                    comparison = (this.read ? 1 : 0) - (o.read ? 1 : 0);
-                } else if (sortType == SORT_TYPE.SORT_ATTACHMENT) {
-                    comparison = (this.hasAttachments ? 0 : 1) - (o.hasAttachments ? 0 : 1);
-
-                }
-
-                if (comparison != 0) {
-                    return comparison * ascender;
-                }
-
-                int dateAscender = (sortDateAscending ? 1 : -1);
-
-
-                return this.compareDate.compareTo(o.compareDate) * dateAscender;
-            }
-
-            Pattern pattern = null;
-            String patternString = "^ *(re|fw|fwd): *";
-            private String stripPrefixes(String in) {
-                synchronized (patternString) {
-                    if (pattern == null) {
-                        pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);
-                    }
-                }
-
-                Matcher matcher = pattern.matcher(in);
-
-                int lastPrefix = -1;
-
-                while (matcher.find()) {
-                    lastPrefix = matcher.end();
-                }
-
-                if (lastPrefix > -1 && lastPrefix < in.length() - 1) {
-                    return in.substring(lastPrefix);
-                } else {
-                    return in;
-                }
-            }
-
-        }
-
-        class MessageViewHolder {
-            public TextView subject;
-            public TextView preview;
-            public TextView from;
-            public TextView date;
-            public View chip;
-        }
-
-        class FooterViewHolder {
-            public ProgressBar progress;
-            public TextView main;
-        }
-
-      /* THERE IS NO FUCKING REASON THIS IS CLONED HERE */
-    public class FolderInfoHolder implements Comparable<FolderInfoHolder> {
-            public String name;
-
-            public String displayName;
-
-            public ArrayList<MessageInfoHolder> messages;
-
-            public long lastChecked;
-
-            public int unreadMessageCount;
-
-            public boolean loading;
-
-            public String status;
-
-            public boolean lastCheckFailed;
-
-            public boolean needsRefresh = false;
-
-            /**
-             * Outbox is handled differently from any other folder.
-             */
-            public boolean outbox;
-
-            public int compareTo(FolderInfoHolder o) {
-                String s1 = this.name;
-                String s2 = o.name;
-
-                if (Email.INBOX.equalsIgnoreCase(s1)) {
-                    return -1;
-                } else if (Email.INBOX.equalsIgnoreCase(s2)) {
-                    return 1;
-                } else
-                    return s1.compareToIgnoreCase(s2);
-            }
-           
-             public FolderInfoHolder(Folder folder) {
-                    populate(folder);
-             }
-             public void populate (Folder folder) {  
-                      int unreadCount = 0;
-    
-                      try {
-                          folder.open(Folder.OpenMode.READ_WRITE);
-                          unreadCount = folder.getUnreadMessageCount();
-                      } catch (MessagingException me) {
-                          Log.e(Email.LOG_TAG, "Folder.getUnreadMessageCount() failed", me);
-                      }
-    
-                      this.name = folder.getName();
-    
-                      if (this.name.equalsIgnoreCase(Email.INBOX)) {
-                          this.displayName = getString(R.string.special_mailbox_name_inbox);
-                      } else {
-                          this.displayName = folder.getName();
-                      }
-    
-                      if (this.name.equals(mAccount.getOutboxFolderName())) {
-                          this.displayName = String.format( getString(R.string.special_mailbox_name_outbox_fmt), this.name);
-                          this.outbox = true;
-                      }
-    
-                      if (this.name.equals(mAccount.getDraftsFolderName())) {
-                          this.displayName = String.format( getString(R.string.special_mailbox_name_drafts_fmt), this.name);
-                      }
-    
-                      if (this.name.equals(mAccount.getTrashFolderName())) {
-                          this.displayName = String.format( getString(R.string.special_mailbox_name_trash_fmt), this.name);
-                      }
-    
-                      if (this.name.equals(mAccount.getSentFolderName())) {
-                          this.displayName = String.format( getString(R.string.special_mailbox_name_sent_fmt), this.name);
-                      }
-    
-                      if (this.messages == null) {
-                          this.messages = new ArrayList<MessageInfoHolder>();
-                      }
-    
-                      this.lastChecked = folder.getLastChecked();
-    
-                      String mess = truncateStatus(folder.getStatus());
-    
-                      this.status = mess;
-    
-                      this.unreadMessageCount = unreadCount;
-    
-                      try {
-                          folder.close(false);
-                      } catch (MessagingException me) {
-                          Log.e(Email.LOG_TAG, "Folder.close() failed", me);
-                      }
-                  }
-        }
-
-}
Index: src/com/android/email/mail/Store.java
===================================================================
--- src/com/android/email/mail/Store.java	(revision 718)
+++ src/com/android/email/mail/Store.java	(working copy)
@@ -6,9 +6,6 @@
 import android.app.Application;
 
 import com.android.email.mail.store.ImapStore;
-import com.android.email.mail.store.LocalStore;
-import com.android.email.mail.store.Pop3Store;
-import com.android.email.mail.store.WebDavStore;
 
 /**
  * Store is the access point for an email message store. It's location can be
@@ -52,15 +49,8 @@
         if (store == null) {
             if (uri.startsWith("imap")) {
                 store = new ImapStore(uri);
-            } else if (uri.startsWith("pop3")) {
-                store = new Pop3Store(uri);
-            } else if (uri.startsWith("local")) {
-                store = new LocalStore(uri, application);
-            } else if (uri.startsWith("webdav")) {
-                store = new WebDavStore(uri);
             }
 
-
             if (store != null) {
                 mStores.put(uri, store);
             }
Index: src/com/android/email/K9Activity.java
===================================================================
--- src/com/android/email/K9Activity.java	(revision 718)
+++ src/com/android/email/K9Activity.java	(working copy)
@@ -1,17 +0,0 @@
-package com.android.email;
-
-import com.android.email.Preferences;
-
-import android.app.Activity;
-import android.os.Bundle;
-
-
-public class K9Activity extends Activity {
-    @Override
-    public void onCreate(Bundle icicle) {
-        setTheme(Preferences.getPreferences(this).getTheme());
-        super.onCreate(icicle);
-    }
-
-
-}
Index: src/com/android/email/service/MailService.java
===================================================================
--- src/com/android/email/service/MailService.java	(revision 718)
+++ src/com/android/email/service/MailService.java	(working copy)
@@ -1,325 +0,0 @@
-
-package com.android.email.service;
-
-import java.util.Date;
-import java.util.HashMap;
-
-import android.app.AlarmManager;
-import android.app.Notification;
-import android.app.NotificationManager;
-import android.app.PendingIntent;
-import android.app.Service;
-import android.content.Context;
-import android.content.Intent;
-import android.os.IBinder;
-import android.os.PowerManager;
-import android.os.PowerManager.WakeLock;
-import android.os.SystemClock;
-import android.util.Config;
-import android.util.Log;
-import android.text.TextUtils;
-import android.net.Uri;
-
-import com.android.email.Account;
-import com.android.email.Email;
-import com.android.email.MessagingController;
-import com.android.email.MessagingListener;
-import com.android.email.Preferences;
-import com.android.email.R;
-import com.android.email.activity.Accounts;
-import com.android.email.activity.FolderList;
-import com.android.email.mail.Folder;
-import com.android.email.mail.MessagingException;
-import com.android.email.mail.Store;
-
-/**
- */
-public class MailService extends Service {
-    private static final String ACTION_CHECK_MAIL = "com.android.email.intent.action.MAIL_SERVICE_WAKEUP";
-    private static final String ACTION_RESCHEDULE = "com.android.email.intent.action.MAIL_SERVICE_RESCHEDULE";
-    private static final String ACTION_CANCEL = "com.android.email.intent.action.MAIL_SERVICE_CANCEL";
-
-    private Listener mListener = new Listener();
-
-    private int mStartId;
-
-    public static void actionReschedule(Context context) {
-        Intent i = new Intent();
-        i.setClass(context, MailService.class);
-        i.setAction(MailService.ACTION_RESCHEDULE);
-        context.startService(i);
-    }
-
-    public static void actionCancel(Context context)  {
-        Intent i = new Intent();
-        i.setClass(context, MailService.class);
-        i.setAction(MailService.ACTION_CANCEL);
-        context.startService(i);
-    }
-
-    @Override
-    public void onCreate() {
-    	super.onCreate();
-    	Log.v(Email.LOG_TAG, "***** MailService *****: onCreate");
-    }
-
-    @Override
-    public void onStart(Intent intent, int startId) {
-    	setForeground(true);  // if it gets killed once, it'll never restart
-    		Log.v(Email.LOG_TAG, "***** MailService *****: onStart(" + intent + ", " + startId + ")");
-        super.onStart(intent, startId);
-        this.mStartId = startId;
-
-       // MessagingController.getInstance(getApplication()).addListener(mListener);
-        if (ACTION_CHECK_MAIL.equals(intent.getAction())) {
-            //if (Config.LOGV) {
-          MessagingController.getInstance(getApplication()).log("***** MailService *****: checking mail");
-                Log.v(Email.LOG_TAG, "***** MailService *****: checking mail");
-            //}
-
-            MessagingController controller = MessagingController.getInstance(getApplication());
-            Listener listener = (Listener)controller.getCheckMailListener();
-            if (listener == null)
-            {
-              MessagingController.getInstance(getApplication()).log("***** MailService *****: starting new check");
-
-              mListener.wakeLockAcquire();
-              controller.setCheckMailListener(mListener);
-              controller.checkMail(this, null, false, false, mListener);
-            }
-            else
-            {
-              MessagingController.getInstance(getApplication()).log("***** MailService *****: renewing WakeLock");
-
-              listener.wakeLockAcquire();
-            }
-
-            reschedule();
-	    //            stopSelf(startId);
-        }
-        else if (ACTION_CANCEL.equals(intent.getAction())) {
-            if (Config.LOGV) {
-                Log.v(Email.LOG_TAG, "***** MailService *****: cancel");
-            }
-            MessagingController.getInstance(getApplication()).log("***** MailService *****: cancel");
-
-            cancel();
-	    //            stopSelf(startId);
-        }
-        else if (ACTION_RESCHEDULE.equals(intent.getAction())) {
-            if (Config.LOGV) {
-                Log.v(Email.LOG_TAG, "***** MailService *****: reschedule");
-            }
-            MessagingController.getInstance(getApplication()).log("***** MailService *****: reschedule");
-            reschedule();
-	    //            stopSelf(startId);
-        }
-    }
-
-    @Override
-    public void onDestroy() {
-    		Log.v(Email.LOG_TAG, "***** MailService *****: onDestroy()");
-        super.onDestroy();
-   //     MessagingController.getInstance(getApplication()).removeListener(mListener);
-    }
-
-    private void cancel() {
-        AlarmManager alarmMgr = (AlarmManager)getSystemService(Context.ALARM_SERVICE);
-        Intent i = new Intent();
-        i.setClassName(getApplication().getPackageName(), "com.android.email.service.MailService");
-        i.setAction(ACTION_CHECK_MAIL);
-        PendingIntent pi = PendingIntent.getService(this, 0, i, 0);
-        alarmMgr.cancel(pi);
-    }
-
-    private void reschedule() {
-        AlarmManager alarmMgr = (AlarmManager)getSystemService(Context.ALARM_SERVICE);
-        Intent i = new Intent();
-        i.setClassName(getApplication().getPackageName(), "com.android.email.service.MailService");
-        i.setAction(ACTION_CHECK_MAIL);
-        PendingIntent pi = PendingIntent.getService(this, 0, i, 0);
-
-        int shortestInterval = -1;
-
-        for (Account account : Preferences.getPreferences(this).getAccounts()) {
-            if (account.getAutomaticCheckIntervalMinutes() != -1
-                    && (account.getAutomaticCheckIntervalMinutes() < shortestInterval || shortestInterval == -1)) {
-                shortestInterval = account.getAutomaticCheckIntervalMinutes();
-            }
-        }
-
-        if (shortestInterval == -1) {
-        		Log.v(Email.LOG_TAG, "No next check scheduled for package " + getApplication().getPackageName());
-            alarmMgr.cancel(pi);
-            stopSelf(mStartId);
-        }
-        else
-        {
-	        long delay = (shortestInterval * (60 * 1000));
-
-	        long nextTime = System.currentTimeMillis() + delay;
-	        try
-	        {
-	          String checkString = "Next check for package " + getApplication().getPackageName() + " scheduled for " + new Date(nextTime);
-	          Log.v(Email.LOG_TAG, checkString);
-	          MessagingController.getInstance(getApplication()).log(checkString);
-	        }
-	        catch (Exception e)
-	        {
-	          // I once got a NullPointerException deep in new Date();
-	          Log.e(Email.LOG_TAG, "Exception while logging", e);
-	        }
-	        
-	        alarmMgr.set(AlarmManager.RTC_WAKEUP, nextTime, pi);
-        }
-
-    }
-
-    public IBinder onBind(Intent intent) {
-        return null;
-    }
-
-    class Listener extends MessagingListener {
-        HashMap<String, Integer> accountsChecked = new HashMap<String, Integer>();
-        private WakeLock wakeLock = null;
-
-        // wakelock strategy is to be very conservative.  If there is any reason to release, then release
-        // don't want to take the chance of running wild
-        public synchronized void wakeLockAcquire()
-        {
-          WakeLock oldWakeLock = wakeLock;
-
-         	PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
-        	wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "Email");
-        	wakeLock.setReferenceCounted(false);
-         	wakeLock.acquire(Email.WAKE_LOCK_TIMEOUT);
-
-         	if (oldWakeLock != null)
-         	{
-         	  oldWakeLock.release();
-         	}
-
-        }
-        public synchronized void wakeLockRelease()
-        {
-        	if (wakeLock != null)
-        	{
-        		wakeLock.release();
-        		wakeLock = null;
-        	}
-        }
-        @Override
-        public void checkMailStarted(Context context, Account account) {
-            accountsChecked.clear();
-        }
-
-        @Override
-        public void checkMailFailed(Context context, Account account, String reason) {
-            release();
-        }
-
-        @Override
-        public void synchronizeMailboxFinished(
-                Account account,
-                String folder,
-                int totalMessagesInMailbox,
-                int numNewMessages) {
-            if (account.isNotifyNewMail()) {
-              Integer existingNewMessages = accountsChecked.get(account.getUuid());
-              if (existingNewMessages == null)
-              {
-                existingNewMessages = 0;
-              }
-              accountsChecked.put(account.getUuid(), existingNewMessages + numNewMessages);
-            }
-        }
-
-        private void checkMailDone(Context context, Account doNotUseaccount)
-        {
-            if (accountsChecked.isEmpty())
-            {
-                return;
-            }
-
-            NotificationManager notifMgr =
-                (NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
-
-            int index = 0;
-            for (Account thisAccount : Preferences.getPreferences(context).getAccounts()) {
-                Integer newMailCount = accountsChecked.get(thisAccount.getUuid());
-                int unreadMessageCount = -1;
-                if (newMailCount != null)
-                {
-                    try
-                    {
-                        unreadMessageCount = thisAccount.getUnreadMessageCount(context, getApplication());
-                        if (unreadMessageCount > 0 && newMailCount > 0)
-                        {
-                            String notice = getString(R.string.notification_new_one_account_fmt, unreadMessageCount,
-                            thisAccount.getDescription());
-                            Notification notif = new Notification(R.drawable.stat_notify_email_generic,
-                                getString(R.string.notification_new_title), System.currentTimeMillis() + (index*1000));
-                          
-                            notif.number = unreadMessageCount;
-                    
-                            Intent i = FolderList.actionHandleAccountIntent(context, thisAccount);
-        
-                            PendingIntent pi = PendingIntent.getActivity(context, 0, i, 0);
-        
-                            notif.setLatestEventInfo(context, getString(R.string.notification_new_title), notice, pi);
-
-                            // JRV XXX TODO - Do we also need to notify the messagelist here?
-
-
-                            String ringtone = thisAccount.getRingtone();
-                            notif.sound = TextUtils.isEmpty(ringtone) ? null : Uri.parse(ringtone);
-        
-                            if (thisAccount.isVibrate()) {
-                                notif.defaults |= Notification.DEFAULT_VIBRATE;
-                            }
-        
-                            notif.flags |= Notification.FLAG_SHOW_LIGHTS;
-                            notif.ledARGB = Email.NOTIFICATION_LED_COLOR;
-                            notif.ledOnMS = Email.NOTIFICATION_LED_ON_TIME;
-                            notif.ledOffMS = Email.NOTIFICATION_LED_OFF_TIME;
-        
-                            notifMgr.notify(thisAccount.getAccountNumber(), notif);
-                        }
-                        else if (unreadMessageCount == 0)
-                        {
-                          notifMgr.cancel(thisAccount.getAccountNumber());
-                        }
-                    }
-                    catch (MessagingException me)
-                    {
-                        Log.e(Email.LOG_TAG, "***** MailService *****: couldn't get unread count for account " +
-                            thisAccount.getDescription(), me);
-                    }
-                }
-            }//for accounts
-        }//checkMailDone
-
-        private void release()
-        {
-          MessagingController controller = MessagingController.getInstance(getApplication());
-          controller.setCheckMailListener(null);
-          reschedule();
-          wakeLockRelease();
-	  //          stopSelf(mStartId);
-        }
-
-        @Override
-        public void checkMailFinished(Context context, Account account) {
-
-        	Log.v(Email.LOG_TAG, "***** MailService *****: checkMailFinished");
-        	try
-        	{
-        		checkMailDone(context, account);
-        	}
-        	finally
-        	{
-        	  release();
-        	}
-        }
-    }
-}
Index: src/com/android/email/K9ListActivity.java
===================================================================
--- src/com/android/email/K9ListActivity.java	(revision 718)
+++ src/com/android/email/K9ListActivity.java	(working copy)
@@ -1,17 +0,0 @@
-package com.android.email;
-
-import com.android.email.Preferences;
-
-import android.app.ListActivity;
-import android.os.Bundle;
-
-
-public class K9ListActivity extends ListActivity {
-    @Override
-    public void onCreate(Bundle icicle) {
-        setTheme(Preferences.getPreferences(this).getTheme());
-        super.onCreate(icicle);
-    }
-
-
-}
Index: src/com/android/email/activity/setup/AccountSetupOptions.java
===================================================================
--- src/com/android/email/activity/setup/AccountSetupOptions.java	(revision 718)
+++ src/com/android/email/activity/setup/AccountSetupOptions.java	(working copy)
@@ -1,132 +0,0 @@
-
-package com.android.email.activity.setup;
-
-import com.android.email.K9Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.os.Bundle;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.widget.ArrayAdapter;
-import android.widget.CheckBox;
-import android.widget.Spinner;
-
-import com.android.email.Account;
-import com.android.email.Email;
-import com.android.email.Preferences;
-import com.android.email.R;
-
-public class AccountSetupOptions extends K9Activity implements OnClickListener {
-    private static final String EXTRA_ACCOUNT = "account";
-
-    private static final String EXTRA_MAKE_DEFAULT = "makeDefault";
-
-    private Spinner mCheckFrequencyView;
-
-    private Spinner mDisplayCountView;
-    
-    private CheckBox mDefaultView;
-
-    private CheckBox mNotifyView;
-    private CheckBox mNotifySyncView;
-
-    private Account mAccount;
-
-    public static void actionOptions(Context context, Account account, boolean makeDefault) {
-        Intent i = new Intent(context, AccountSetupOptions.class);
-        i.putExtra(EXTRA_ACCOUNT, account);
-        i.putExtra(EXTRA_MAKE_DEFAULT, makeDefault);
-        context.startActivity(i);
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.account_setup_options);
-
-        mCheckFrequencyView = (Spinner)findViewById(R.id.account_check_frequency);
-        mDisplayCountView = (Spinner)findViewById(R.id.account_display_count);
-        mDefaultView = (CheckBox)findViewById(R.id.account_default);
-        mNotifyView = (CheckBox)findViewById(R.id.account_notify);
-        mNotifySyncView = (CheckBox)findViewById(R.id.account_notify_sync);
-
-        findViewById(R.id.next).setOnClickListener(this);
-
-        SpinnerOption checkFrequencies[] = {
-                new SpinnerOption(-1,
-                        getString(R.string.account_setup_options_mail_check_frequency_never)),
-                new SpinnerOption(1,
-                        getString(R.string.account_setup_options_mail_check_frequency_1min)),
-                new SpinnerOption(5,
-                        getString(R.string.account_setup_options_mail_check_frequency_5min)),
-                new SpinnerOption(10,
-                        getString(R.string.account_setup_options_mail_check_frequency_10min)),
-                new SpinnerOption(15,
-                        getString(R.string.account_setup_options_mail_check_frequency_15min)),
-                new SpinnerOption(30,
-                        getString(R.string.account_setup_options_mail_check_frequency_30min)),
-                new SpinnerOption(60,
-                        getString(R.string.account_setup_options_mail_check_frequency_1hour)),
-        };
-
-        ArrayAdapter<SpinnerOption> checkFrequenciesAdapter = new ArrayAdapter<SpinnerOption>(this,
-                android.R.layout.simple_spinner_item, checkFrequencies);
-        checkFrequenciesAdapter
-                .setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
-        mCheckFrequencyView.setAdapter(checkFrequenciesAdapter);
-
-        SpinnerOption displayCounts[] = {
-            new SpinnerOption(10,
-                              getString(R.string.account_setup_options_mail_display_count_10)),
-            new SpinnerOption(25,
-                              getString(R.string.account_setup_options_mail_display_count_25)),
-            new SpinnerOption(50,
-                              getString(R.string.account_setup_options_mail_display_count_50)),
-            new SpinnerOption(100,
-                              getString(R.string.account_setup_options_mail_display_count_100)),
-        };
-
-        ArrayAdapter<SpinnerOption> displayCountsAdapter = new ArrayAdapter<SpinnerOption>(this,
-                android.R.layout.simple_spinner_item, displayCounts);
-        displayCountsAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
-        mDisplayCountView.setAdapter(displayCountsAdapter);
-        
-        mAccount = (Account)getIntent().getSerializableExtra(EXTRA_ACCOUNT);
-        boolean makeDefault = getIntent().getBooleanExtra(EXTRA_MAKE_DEFAULT, false);
-
-        if (mAccount.equals(Preferences.getPreferences(this).getDefaultAccount()) || makeDefault) {
-            mDefaultView.setChecked(true);
-        }
-        mNotifyView.setChecked(mAccount.isNotifyNewMail());
-        mNotifySyncView.setChecked(mAccount.isShowOngoing());
-        SpinnerOption.setSpinnerOptionValue(mCheckFrequencyView, mAccount
-                .getAutomaticCheckIntervalMinutes());
-        SpinnerOption.setSpinnerOptionValue(mDisplayCountView, mAccount
-                .getDisplayCount());
-    }
-
-    private void onDone() {
-        mAccount.setDescription(mAccount.getEmail());
-        mAccount.setNotifyNewMail(mNotifyView.isChecked());
-        mAccount.setShowOngoing(mNotifySyncView.isChecked());
-        mAccount.setAutomaticCheckIntervalMinutes((Integer)((SpinnerOption)mCheckFrequencyView
-                .getSelectedItem()).value);
-        mAccount.setDisplayCount((Integer)((SpinnerOption)mDisplayCountView
-                .getSelectedItem()).value);
-        mAccount.save(Preferences.getPreferences(this));
-        if (mDefaultView.isChecked()) {
-            Preferences.getPreferences(this).setDefaultAccount(mAccount);
-        }
-        Email.setServicesEnabled(this);
-        AccountSetupNames.actionSetNames(this, mAccount);
-        finish();
-    }
-
-    public void onClick(View v) {
-        switch (v.getId()) {
-            case R.id.next:
-                onDone();
-                break;
-        }
-    }
-}
Index: src/com/android/email/activity/setup/AccountSetupAccountType.java
===================================================================
--- src/com/android/email/activity/setup/AccountSetupAccountType.java	(revision 718)
+++ src/com/android/email/activity/setup/AccountSetupAccountType.java	(working copy)
@@ -1,109 +0,0 @@
-
-package com.android.email.activity.setup;
-
-import java.net.URI;
-import java.net.URISyntaxException;
-
-import com.android.email.K9Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.os.Bundle;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.widget.Button;
-
-import com.android.email.Account;
-import com.android.email.R;
-
-/**
- * Prompts the user to select an account type. The account type, along with the
- * passed in email address, password and makeDefault are then passed on to the
- * AccountSetupIncoming activity.
- */
-public class AccountSetupAccountType extends K9Activity implements OnClickListener {
-    private static final String EXTRA_ACCOUNT = "account";
-
-    private static final String EXTRA_MAKE_DEFAULT = "makeDefault";
-
-    private Account mAccount;
-
-    private boolean mMakeDefault;
-
-    public static void actionSelectAccountType(Context context, Account account, boolean makeDefault) {
-        Intent i = new Intent(context, AccountSetupAccountType.class);
-        i.putExtra(EXTRA_ACCOUNT, account);
-        i.putExtra(EXTRA_MAKE_DEFAULT, makeDefault);
-        context.startActivity(i);
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.account_setup_account_type);
-        ((Button)findViewById(R.id.pop)).setOnClickListener(this);
-        ((Button)findViewById(R.id.imap)).setOnClickListener(this);
-        ((Button)findViewById(R.id.webdav)).setOnClickListener(this);
-
-        mAccount = (Account)getIntent().getSerializableExtra(EXTRA_ACCOUNT);
-        mMakeDefault = (boolean)getIntent().getBooleanExtra(EXTRA_MAKE_DEFAULT, false);
-    }
-
-    private void onPop() {
-        try {
-            URI uri = new URI(mAccount.getStoreUri());
-            uri = new URI("pop3", uri.getUserInfo(), uri.getHost(), uri.getPort(), null, null, null);
-            mAccount.setStoreUri(uri.toString());
-        } catch (URISyntaxException use) {
-            /*
-             * This should not happen.
-             */
-            throw new Error(use);
-        }
-        AccountSetupIncoming.actionIncomingSettings(this, mAccount, mMakeDefault);
-        finish();
-    }
-
-    private void onImap() {
-        try {
-            URI uri = new URI(mAccount.getStoreUri());
-            uri = new URI("imap", uri.getUserInfo(), uri.getHost(), uri.getPort(), null, null, null);
-            mAccount.setStoreUri(uri.toString());
-        } catch (URISyntaxException use) {
-            /*
-             * This should not happen.
-             */
-            throw new Error(use);
-        }
-        AccountSetupIncoming.actionIncomingSettings(this, mAccount, mMakeDefault);
-        finish();
-    }
-
-    private void onWebDav() {
-        try {
-            URI uri = new URI(mAccount.getStoreUri());
-            uri = new URI("webdav", uri.getUserInfo(), uri.getHost(), uri.getPort(), null, null, null);
-            mAccount.setStoreUri(uri.toString());
-        } catch (URISyntaxException use) {
-            /*
-             * This should not happen.
-             */
-            throw new Error(use);
-        }
-        AccountSetupIncoming.actionIncomingSettings(this, mAccount, mMakeDefault);
-        finish();
-    }
-    
-    public void onClick(View v) {
-        switch (v.getId()) {
-            case R.id.pop:
-                onPop();
-                break;
-            case R.id.imap:
-                onImap();
-                break;
-            case R.id.webdav:
-                onWebDav();
-                break;
-        }
-    }
-}
Index: src/com/android/email/mail/transport/SmtpTransport.java
===================================================================
--- src/com/android/email/mail/transport/SmtpTransport.java	(revision 718)
+++ src/com/android/email/mail/transport/SmtpTransport.java	(working copy)
@@ -1,399 +0,0 @@
-
-package com.android.email.mail.transport;
-
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.net.SocketAddress;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.security.GeneralSecurityException;
-import java.security.SecureRandom;
-
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.SSLException;
-
-import android.util.Config;
-import android.util.Log;
-
-import com.android.email.Email;
-import com.android.email.PeekableInputStream;
-import com.android.email.codec.binary.Base64;
-import com.android.email.mail.Address;
-import com.android.email.mail.AuthenticationFailedException;
-import com.android.email.mail.Message;
-import com.android.email.mail.MessagingException;
-import com.android.email.mail.Store;
-import com.android.email.mail.Transport;
-import com.android.email.mail.CertificateValidationException;
-import com.android.email.mail.Message.RecipientType;
-import com.android.email.mail.store.TrustManagerFactory;
-
-public class SmtpTransport extends Transport {
-    public static final int CONNECTION_SECURITY_NONE = 0;
-
-    public static final int CONNECTION_SECURITY_TLS_OPTIONAL = 1;
-
-    public static final int CONNECTION_SECURITY_TLS_REQUIRED = 2;
-
-    public static final int CONNECTION_SECURITY_SSL_REQUIRED = 3;
-
-    public static final int CONNECTION_SECURITY_SSL_OPTIONAL = 4;
-
-    String mHost;
-
-    int mPort;
-
-    String mUsername;
-
-    String mPassword;
-
-    int mConnectionSecurity;
-
-    boolean mSecure;
-
-    Socket mSocket;
-
-    PeekableInputStream mIn;
-
-    OutputStream mOut;
-
-    /**
-     * smtp://user:password@server:port CONNECTION_SECURITY_NONE
-     * smtp+tls://user:password@server:port CONNECTION_SECURITY_TLS_OPTIONAL
-     * smtp+tls+://user:password@server:port CONNECTION_SECURITY_TLS_REQUIRED
-     * smtp+ssl+://user:password@server:port CONNECTION_SECURITY_SSL_REQUIRED
-     * smtp+ssl://user:password@server:port CONNECTION_SECURITY_SSL_OPTIONAL
-     *
-     * @param _uri
-     */
-    public SmtpTransport(String _uri) throws MessagingException {
-        URI uri;
-        try {
-            uri = new URI(_uri);
-        } catch (URISyntaxException use) {
-            throw new MessagingException("Invalid SmtpTransport URI", use);
-        }
-
-        String scheme = uri.getScheme();
-        if (scheme.equals("smtp")) {
-            mConnectionSecurity = CONNECTION_SECURITY_NONE;
-            mPort = 25;
-        } else if (scheme.equals("smtp+tls")) {
-            mConnectionSecurity = CONNECTION_SECURITY_TLS_OPTIONAL;
-            mPort = 25;
-        } else if (scheme.equals("smtp+tls+")) {
-            mConnectionSecurity = CONNECTION_SECURITY_TLS_REQUIRED;
-            mPort = 25;
-        } else if (scheme.equals("smtp+ssl+")) {
-            mConnectionSecurity = CONNECTION_SECURITY_SSL_REQUIRED;
-            mPort = 465;
-        } else if (scheme.equals("smtp+ssl")) {
-            mConnectionSecurity = CONNECTION_SECURITY_SSL_OPTIONAL;
-            mPort = 465;
-        } else {
-            throw new MessagingException("Unsupported protocol");
-        }
-
-        mHost = uri.getHost();
-
-        if (uri.getPort() != -1) {
-            mPort = uri.getPort();
-        }
-
-        if (uri.getUserInfo() != null) {
-            String[] userInfoParts = uri.getUserInfo().split(":", 2);
-            mUsername = userInfoParts[0];
-            if (userInfoParts.length > 1) {
-                mPassword = userInfoParts[1];
-            }
-        }
-    }
-
-    public void open() throws MessagingException {
-        try {
-            SocketAddress socketAddress = new InetSocketAddress(mHost, mPort);
-            if (mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED ||
-                    mConnectionSecurity == CONNECTION_SECURITY_SSL_OPTIONAL) {
-                SSLContext sslContext = SSLContext.getInstance("TLS");
-                boolean secure = mConnectionSecurity == CONNECTION_SECURITY_SSL_REQUIRED;
-                sslContext.init(null, new TrustManager[] {
-                        TrustManagerFactory.get(mHost, secure)
-                }, new SecureRandom());
-                mSocket = sslContext.getSocketFactory().createSocket();
-                mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
-                mSecure = true;
-            } else {
-                mSocket = new Socket();
-                mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
-            }
-
-            // RFC 1047
-            mSocket.setSoTimeout(SOCKET_READ_TIMEOUT);
-            
-            mIn = new PeekableInputStream(new BufferedInputStream(mSocket.getInputStream(), 1024));
-            mOut = mSocket.getOutputStream();
-
-            // Eat the banner
-            executeSimpleCommand(null);
-
-            String localHost = "localhost.localdomain";
-            try {
-                InetAddress localAddress = InetAddress.getLocalHost();
-                if (! localAddress.isLoopbackAddress()) {
-                    // The loopback address will resolve to 'localhost'
-                    // some mail servers only accept qualified hostnames, so make sure 
-                    // never to override "localhost.localdomain" with "localhost"
-                    // TODO - this is a hack. but a better hack than what was there before
-                    localHost = localAddress.getHostName();
-                }
-            } catch (Exception e) {
-                if (Config.LOGD) {
-                    if (Email.DEBUG) {
-                        Log.d(Email.LOG_TAG, "Unable to look up localhost");
-                    }
-                }
-            }
-
-            String result = executeSimpleCommand("EHLO " + localHost);
-
-            /*
-             * TODO may need to add code to fall back to HELO I switched it from
-             * using HELO on non STARTTLS connections because of AOL's mail
-             * server. It won't let you use AUTH without EHLO.
-             * We should really be paying more attention to the capabilities
-             * and only attempting auth if it's available, and warning the user
-             * if not.
-             */
-            if (mConnectionSecurity == CONNECTION_SECURITY_TLS_OPTIONAL
-                    || mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED) {
-                if (result.contains("-STARTTLS")) {
-                    executeSimpleCommand("STARTTLS");
-
-                    SSLContext sslContext = SSLContext.getInstance("TLS");
-                    boolean secure = mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED;
-                    sslContext.init(null, new TrustManager[] {
-                            TrustManagerFactory.get(mHost, secure)
-                    }, new SecureRandom());
-                    mSocket = sslContext.getSocketFactory().createSocket(mSocket, mHost, mPort,
-                            true);
-                    mIn = new PeekableInputStream(new BufferedInputStream(mSocket.getInputStream(),
-                            1024));
-                    mOut = mSocket.getOutputStream();
-                    mSecure = true;
-                    /*
-                     * Now resend the EHLO. Required by RFC2487 Sec. 5.2, and more specifically,
-                     * Exim.
-                     */
-                    result = executeSimpleCommand("EHLO " + localHost);
-                } else if (mConnectionSecurity == CONNECTION_SECURITY_TLS_REQUIRED) {
-                    throw new MessagingException("TLS not supported but required");
-                }
-            }
-
-            /*
-             * result contains the results of the EHLO in concatenated form
-             */
-            boolean authLoginSupported = result.matches(".*AUTH.*LOGIN.*$");
-            boolean authPlainSupported = result.matches(".*AUTH.*PLAIN.*$");
-
-            if (mUsername != null && mUsername.length() > 0 && mPassword != null
-                    && mPassword.length() > 0) {
-                if (authPlainSupported) {
-                    saslAuthPlain(mUsername, mPassword);
-                }
-                else if (authLoginSupported) {
-                    saslAuthLogin(mUsername, mPassword);
-                }
-                else {
-                    throw new MessagingException("No valid authentication mechanism found.");
-                }
-            }
-        } catch (SSLException e) {
-            throw new CertificateValidationException(e.getMessage(), e);
-        } catch (GeneralSecurityException gse) {
-            throw new MessagingException(
-                    "Unable to open connection to SMTP server due to security error.", gse);
-        } catch (IOException ioe) {
-            throw new MessagingException("Unable to open connection to SMTP server.", ioe);
-        }
-    }
-
-    public void sendMessage(Message message) throws MessagingException {
-        close();
-        open();
-        Address[] from = message.getFrom();
-        boolean possibleSend = false;
-        try {
-            executeSimpleCommand("MAIL FROM: " + "<" + from[0].getAddress() + ">");
-            for (Address address : message.getRecipients(RecipientType.TO)) {
-                executeSimpleCommand("RCPT TO: " + "<" + address.getAddress() + ">");
-            }
-            for (Address address : message.getRecipients(RecipientType.CC)) {
-                executeSimpleCommand("RCPT TO: " + "<" + address.getAddress() + ">");
-            }
-            for (Address address : message.getRecipients(RecipientType.BCC)) {
-                executeSimpleCommand("RCPT TO: " + "<" + address.getAddress() + ">");
-            }
-            message.setRecipients(RecipientType.BCC, null);
-            executeSimpleCommand("DATA");
-            // TODO byte stuffing
-            message.writeTo(
-                    new EOLConvertingOutputStream(
-                            new BufferedOutputStream(mOut, 1024)));
- 
-            possibleSend = true; // After the "\r\n." is attempted, we may have sent the message
-            executeSimpleCommand("\r\n.");
-        } catch (Exception e) {
-          MessagingException me = new MessagingException("Unable to send message", e);
-          me.setPermanentFailure(possibleSend);
-          throw me;
-        }
-        finally
-        {
-        	close();
-        }
-        
-        
-      
-    }
-
-    public void close() {
-        try {
-            mIn.close();
-        } catch (Exception e) {
-
-        }
-        try {
-            mOut.close();
-        } catch (Exception e) {
-
-        }
-        try {
-            mSocket.close();
-        } catch (Exception e) {
-
-        }
-        mIn = null;
-        mOut = null;
-        mSocket = null;
-    }
-
-    private String readLine() throws IOException {
-        StringBuffer sb = new StringBuffer();
-        int d;
-        while ((d = mIn.read()) != -1) {
-            if (((char)d) == '\r') {
-                continue;
-            } else if (((char)d) == '\n') {
-                break;
-            } else {
-                sb.append((char)d);
-            }
-        }
-        String ret = sb.toString();
-        if (true || Config.LOGD) {
-            if (Email.DEBUG) {
-                Log.d(Email.LOG_TAG, "<<< " + ret);
-            }
-        }
-        return ret;
-    }
-
-    private void writeLine(String s) throws IOException {
-        if (true || Config.LOGD) {
-            if (Email.DEBUG) {
-                Log.d(Email.LOG_TAG, ">>> " + s);
-            }
-        }
-        mOut.write(s.getBytes());
-        mOut.write('\r');
-        mOut.write('\n');
-        mOut.flush();
-    }
-
-    private void checkLine(String line) throws MessagingException
-    {
-	if (line.length() < 1)
-	{
-	   throw new MessagingException("SMTP response is 0 length");
-	}
-        char c = line.charAt(0);
-        if ((c == '4') || (c == '5')) {
-            throw new MessagingException(line);
-        }
-    }
-
-    private String executeSimpleCommand(String command) throws IOException, MessagingException {
-        if (command != null) {
-            writeLine(command);
-        }
-
-        String line = readLine();
-        checkLine(line);
-
-        String result = line;
-
-        while (line.length() >= 4 && line.charAt(3) == '-') {
-            line = readLine();
-            checkLine(line);
-            result += line.substring(3);
-        }
-        return result;
-    }
-
-
-//    C: AUTH LOGIN
-//    S: 334 VXNlcm5hbWU6
-//    C: d2VsZG9u
-//    S: 334 UGFzc3dvcmQ6
-//    C: dzNsZDBu
-//    S: 235 2.0.0 OK Authenticated
-//
-//    Lines 2-5 of the conversation contain base64-encoded information. The same conversation, with base64 strings decoded, reads:
-//
-//
-//    C: AUTH LOGIN
-//    S: 334 Username:
-//    C: weldon
-//    S: 334 Password:
-//    C: w3ld0n
-//    S: 235 2.0.0 OK Authenticated
-
-    private void saslAuthLogin(String username, String password) throws MessagingException,
-        AuthenticationFailedException, IOException {
-        try {
-            executeSimpleCommand("AUTH LOGIN");
-            executeSimpleCommand(new String(Base64.encodeBase64(username.getBytes())));
-            executeSimpleCommand(new String(Base64.encodeBase64(password.getBytes())));
-        }
-        catch (MessagingException me) {
-            if (me.getMessage().length() > 1 && me.getMessage().charAt(1) == '3') {
-                throw new AuthenticationFailedException("AUTH LOGIN failed (" + me.getMessage()
-                        + ")");
-            }
-            throw me;
-        }
-    }
-
-    private void saslAuthPlain(String username, String password) throws MessagingException,
-            AuthenticationFailedException, IOException {
-        byte[] data = ("\000" + username + "\000" + password).getBytes();
-        data = new Base64().encode(data);
-        try {
-            executeSimpleCommand("AUTH PLAIN " + new String(data));
-        }
-        catch (MessagingException me) {
-            if (me.getMessage().length() > 1 && me.getMessage().charAt(1) == '3') {
-                throw new AuthenticationFailedException("AUTH PLAIN failed (" + me.getMessage()
-                        + ")");
-            }
-            throw me;
-        }
-    }
-}
Index: src/com/android/email/activity/SizeFormatter.java
===================================================================
--- src/com/android/email/activity/SizeFormatter.java	(revision 718)
+++ src/com/android/email/activity/SizeFormatter.java	(working copy)
@@ -1,26 +0,0 @@
-package com.android.email.activity;
-
-import android.content.Context;
-
-import com.android.email.R;
-
-public class SizeFormatter
-{
-  public static String formatSize(Context context, long size)
-  {
-    if (size > 1024000000)
-    {
-      return ((float)(size / 102400000) / 10) + context.getString(R.string.abbrev_gigabytes);
-    }
-    if (size > 1024000)
-    {
-      return ((float)(size / 102400) / 10) + context.getString(R.string.abbrev_megabytes);
-    }
-    if (size > 1024)
-    {
-      return ((float)(size / 102) / 10) + context.getString(R.string.abbrev_kilobytes);
-    }
-    return size + context.getString(R.string.abbrev_bytes);
-  }
-  
-}
Index: src/com/android/email/Email.java
===================================================================
--- src/com/android/email/Email.java	(revision 718)
+++ src/com/android/email/Email.java	(working copy)
@@ -1,248 +1,15 @@
-
 package com.android.email;
 
-import java.io.File;
-
-import android.app.Application;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.pm.PackageManager;
-import android.util.Config;
-import android.util.Log;
-
-import com.android.email.activity.MessageCompose;
-import com.android.email.mail.internet.BinaryTempFileBody;
-import com.android.email.mail.internet.MimeMessage;
-import com.android.email.service.BootReceiver;
-import com.android.email.service.MailService;
-
-public class Email extends Application {
-    public static Application app = null;
-    public static File tempDirectory;
-    public static final String LOG_TAG = "k9";
-    
-    /**
-     * Some log messages can be sent to a file, so that the logs
-     * can be read using unprivileged access (eg. Terminal Emulator)
-     * on the phone, without adb.  Set to null to disable
-     */
-    public static final String logFile = null;
-    //public static final String logFile = "/sdcard/k9mail/debug.log";
-
-    /**
-     * If this is enabled there will be additional logging information sent to
-     * Log.d, including protocol dumps.
-     */
-    public static boolean DEBUG = false;
-
-    /**
-     * If this is enabled than logging that normally hides sensitive information
-     * like passwords will show that information.
-     */
-    public static boolean DEBUG_SENSITIVE = false;
-
-    /**
-     * Can create messages containing stack traces that can be forwarded
-     * to the development team.
-     */
-    public static boolean ENABLE_ERROR_FOLDER = true;
-    public static String ERROR_FOLDER_NAME = "K9mail-errors";
-
-    /**
-     * The MIME type(s) of attachments we're willing to send. At the moment it is not possible
-     * to open a chooser with a list of filter types, so the chooser is only opened with the first
-     * item in the list. The entire list will be used to filter down attachments that are added
-     * with Intent.ACTION_SEND.
-     */
-    public static final String[] ACCEPTABLE_ATTACHMENT_SEND_TYPES = new String[] {
-        "*/*"
-    };
-
-    /**
-     * The MIME type(s) of attachments we're willing to view.
-     */
-    public static final String[] ACCEPTABLE_ATTACHMENT_VIEW_TYPES = new String[] {
-        "image/*",
-        "audio/*",
-        "text/*",
-    };
-
-    /**
-     * The MIME type(s) of attachments we're not willing to view.
-     */
-    public static final String[] UNACCEPTABLE_ATTACHMENT_VIEW_TYPES = new String[] {
-    };
-
-    /**
-     * The MIME type(s) of attachments we're willing to download to SD.
-     */
-    public static final String[] ACCEPTABLE_ATTACHMENT_DOWNLOAD_TYPES = new String[] {
-        "*/*",
-    };
-
-    /**
-     * The MIME type(s) of attachments we're not willing to download to SD.
-     */
-    public static final String[] UNACCEPTABLE_ATTACHMENT_DOWNLOAD_TYPES = new String[] {
-    };
-
-    /**
-     * The special name "INBOX" is used throughout the application to mean "Whatever folder
-     * the server refers to as the user's Inbox. Placed here to ease use.
-     */
-    public static final String INBOX = "INBOX";
-    
-    /**
-     * For use when displaying that no folder is selected
-     */
-    public static final String FOLDER_NONE = "-NONE-";
-
-    public static final String LOCAL_UID_PREFIX = "K9LOCAL:";
- 
-    public static final String REMOTE_UID_PREFIX = "K9REMOTE:";
- 
-    public static final String K9MAIL_IDENTITY = "X-K9mail-Identity";
-    
-    /**
-     * Specifies how many messages will be shown in a folder by default. This number is set
-     * on each new folder and can be incremented with "Load more messages..." by the
-     * VISIBLE_LIMIT_INCREMENT
-     */
-    public static int DEFAULT_VISIBLE_LIMIT = 25;
-
-    /**
-     * Number of additioanl messages to load when a user selectes "Load more messages..."
-     */
-    public static int VISIBLE_LIMIT_INCREMENT = 25;
-    
-    public static int MAX_SEND_ATTEMPTS = 5;
-
-    /**
-     * The maximum size of an attachment we're willing to download (either View or Save)
-     * Attachments that are base64 encoded (most) will be about 1.375x their actual size
-     * so we should probably factor that in. A 5MB attachment will generally be around
-     * 6.8MB downloaded but only 5MB saved.
-     */
-    public static final int MAX_ATTACHMENT_DOWNLOAD_SIZE = (5 * 1024 * 1024);
-    
-    /**
-     * Max time (in millis) the wake lock will be held for when background sync is happening 
-     */
-    public static final int WAKE_LOCK_TIMEOUT = 600000;
-    
-    public static final int MANUAL_WAKE_LOCK_TIMEOUT = 120000;
-
-    /**
-     * LED color used for the new email notitication
-     */
-    public static final int NOTIFICATION_LED_COLOR = 0xffff00ff;
-
-    /**
-     * Time the LED is on when blicking on new email notification
-     */
-    public static final int NOTIFICATION_LED_ON_TIME = 500; 
-
-    /**
-     * Time the LED is off when blicking on new email notification
-     */
-    public static final int NOTIFICATION_LED_OFF_TIME = 2000;
-    
-    public static final boolean NOTIFICATION_LED_WHILE_SYNCING = false;
-    public static final int NOTIFICATION_LED_DIM_COLOR = 0x77770077;
-    public static final int NOTIFICATION_LED_FAST_ON_TIME = 100;
-    public static final int NOTIFICATION_LED_FAST_OFF_TIME = 100;
-    
-    public static final int NOTIFICATION_LED_SENDING_FAILURE_COLOR = 0xffff0000;
-
-    // Must not conflict with an account number
-    public static final int FETCHING_EMAIL_NOTIFICATION_ID      = -4; 
-    public static final int FETCHING_EMAIL_NOTIFICATION_MULTI_ACCOUNT_ID      = -1;
-    public static final int FETCHING_EMAIL_NOTIFICATION_NO_ACCOUNT = -2;
-    
-    // Backup formats in case they can't be fetched from the system
-    public static final String BACKUP_DATE_FORMAT = "MM-dd-yyyy";
-    public static final String TIME_FORMAT_12 = "h:mm a";
-    public static final String TIME_FORMAT_24 = "H:mm";
-    
-    public static final int FLAGGED_COLOR = 0xff4444;
-
-    public static final String INTENT_DATA_URI_SCHEMA           = "content";
-    public static final String INTENT_DATA_UR_PATH_PREFIX       = "email";
-    public static final String INTENT_DATA_URI_PREFIX           = INTENT_DATA_URI_SCHEMA + "://" + INTENT_DATA_UR_PATH_PREFIX;
-
-    /**
-     * Called throughout the application when the number of accounts has changed. This method
-     * enables or disables the Compose activity, the boot receiver and the service based on
-     * whether any accounts are configured.
-     */
-    public static void setServicesEnabled(Context context) {
-        setServicesEnabled(context, Preferences.getPreferences(context).getAccounts().length > 0);
-    }
-
-    public static void setServicesEnabled(Context context, boolean enabled) {
-        PackageManager pm = context.getPackageManager();
-        if (!enabled && pm.getComponentEnabledSetting(new ComponentName(context, MailService.class)) ==
-                PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {
-            /*
-             * If no accounts now exist but the service is still enabled we're about to disable it
-             * so we'll reschedule to kill off any existing alarms.
-             */
-            MailService.actionReschedule(context);
-        }
-        pm.setComponentEnabledSetting(
-                new ComponentName(context, MessageCompose.class),
-                enabled ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED :
-                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
-                PackageManager.DONT_KILL_APP);
-        pm.setComponentEnabledSetting(
-                new ComponentName(context, BootReceiver.class),
-                enabled ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED :
-                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
-                PackageManager.DONT_KILL_APP);
-        pm.setComponentEnabledSetting(
-                new ComponentName(context, MailService.class),
-                enabled ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED :
-                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
-                PackageManager.DONT_KILL_APP);
-        if (enabled && pm.getComponentEnabledSetting(new ComponentName(context, MailService.class)) ==
-                PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {
-            /*
-             * And now if accounts do exist then we've just enabled the service and we want to
-             * schedule alarms for the new accounts.
-             */
-            MailService.actionReschedule(context);
-        }
-    }
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-        app = this;
-        Preferences prefs = Preferences.getPreferences(this);
-        DEBUG = prefs.getEnableDebugLogging();
-        DEBUG_SENSITIVE = prefs.getEnableSensitiveLogging();
-        MessagingController.getInstance(this).resetVisibleLimits(prefs.getAccounts());
 
-        
-        /*
-         * We have to give MimeMessage a temp directory because File.createTempFile(String, String)
-         * doesn't work in Android and MimeMessage does not have access to a Context.
-         */
-        BinaryTempFileBody.setTempDirectory(getCacheDir());
+public class Email {
 
-        /* 
-         * Enable background sync of messages
-         */
-   
-        setServicesEnabled(this);
+	public static final String LOG_TAG = "SmsBackup-Backend";
+	
+	// TODO(chstuder): Disable
+	public static final boolean DEBUG = true;
+	public static final boolean DEBUG_SENSITIVE = true;
+	
+	public static final String INBOX = "INBOX";
+	public static final String K9MAIL_IDENTITY = "X-SmsBackup-Identity";
 
-    }
 }
-
-
-
-
-
-
-
-
Index: src/com/android/email/EmailAddressAdapter.java
===================================================================
--- src/com/android/email/EmailAddressAdapter.java	(revision 718)
+++ src/com/android/email/EmailAddressAdapter.java	(working copy)
@@ -1,88 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.email;
-
-import static android.provider.Contacts.ContactMethods.CONTENT_EMAIL_URI;
-import android.content.ContentResolver;
-import android.content.Context;
-import android.database.Cursor;
-import android.database.DatabaseUtils;
-import android.provider.Contacts.ContactMethods;
-import android.provider.Contacts.People;
-import android.view.View;
-import android.widget.ResourceCursorAdapter;
-import android.widget.TextView;
-
-import com.android.email.mail.Address;
-
-public class EmailAddressAdapter extends ResourceCursorAdapter {
-    public static final int NAME_INDEX = 1;
-
-    public static final int DATA_INDEX = 2;
-
-    private static final String SORT_ORDER = People.TIMES_CONTACTED + " DESC, " + People.NAME;
-
-    private ContentResolver mContentResolver;
-
-    private static final String[] PROJECTION = {
-            ContactMethods._ID, // 0
-            ContactMethods.NAME, // 1
-            ContactMethods.DATA
-    // 2
-    };
-
-    public EmailAddressAdapter(Context context) {
-        super(context, R.layout.recipient_dropdown_item, null);
-        mContentResolver = context.getContentResolver();
-    }
-
-    @Override
-    public final String convertToString(Cursor cursor) {
-        String name = cursor.getString(NAME_INDEX);
-        String address = cursor.getString(DATA_INDEX);
-
-        return new Address(address, name).toString();
-    }
-
-    @Override
-    public final void bindView(View view, Context context, Cursor cursor) {
-        TextView text1 = (TextView)view.findViewById(R.id.text1);
-        TextView text2 = (TextView)view.findViewById(R.id.text2);
-        text1.setText(cursor.getString(NAME_INDEX));
-        text2.setText(cursor.getString(DATA_INDEX));
-    }
-
-    @Override
-    public Cursor runQueryOnBackgroundThread(CharSequence constraint) {
-        String where = null;
-
-        if (constraint != null) {
-            String filter = DatabaseUtils.sqlEscapeString(constraint.toString() + '%');
-
-            StringBuilder s = new StringBuilder();
-            s.append("(people.name LIKE ");
-            s.append(filter);
-            s.append(") OR (contact_methods.data LIKE ");
-            s.append(filter);
-            s.append(")");
-
-            where = s.toString();
-        }
-
-        return mContentResolver.query(CONTENT_EMAIL_URI, PROJECTION, where, null, SORT_ORDER);
-    }
-}
